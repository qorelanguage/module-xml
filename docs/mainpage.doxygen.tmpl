/** @mainpage Qore XML Module

    Contents of this documentation:
    - @ref intro
    - @ref optionconstants
    - @ref serialization
    - @ref XMLRPC
    - @ref codetags

    @section intro Introduction

    XML functionality in the Qore xml module is provided by the <a href="http://xmlsoft.org">libxml2 library</a>, which provides a powerful, stable, clean, and thread-safe basis for XML integration in Qore.

    XML provides a way to describe hierarchical data, and thanks to  <a href="http://xmlsoft.org">libxml2</a>, Qore can allow for easy serialization and deserialization between XML strings and Qore data structures.

    @section optionconstants Module Option Constants
    
    The following constants give information about the availability of XML functionality (dependent on libxml2 features at compile time):

    <b>XML Option Constants</b>
    |!Name|!Type|!Description
    |\c HAVE_PARSEXMLWITHRELAXNG|\c bool|Indicates if parseXMLWithRelaxNG() and XmlReader::relaxNGValidate() are available
    |\c HAVE_PARSEXMLWITHSCHEMA|\c bool|Indicates if parseXMLWithSchema() and XmlReader::schemaValidate() are available

    If either of the above constants are \c False, then calling any of the dependent functions or methods will result in a run-time exception.

    @section serialization Automatic XML Serialization and Deserialization

    This section describes automatic XML serialization and deserialization; for iterative or user-controlled XML parsing, see @ref xmlclasses "XML Classes".

    XML serialization (conversion from Qore data structures to XML strings) in Qore relies on the fact that Qore hashes retain insertion order, which means that conversion to and from Qore data structures and XML strings can be done without data loss and without reordering the XML elements. In general, XML serialization is relatively straighforward, but there are a few issues to be aware of, particularly regarding element attributes and lists. These issues are described in the following paragraphs.

    First, a straightforward example:

    @code
$h = ( "record" : ( "name" : ( "first" : "Fred", "last" : "Smith" ) ) );
printf("%s\n", makeFormattedXMLString($h));@endcode

    This produces the following result

    @verbatim
<?xml version="1.0" encoding="UTF-8"?>
<record>
  <name>
    <first>Fred</first>
    <last>Smith</last>
  </name>
</record>@endverbatim

    To set XML attributes, the Qore value must be a hash and the attributes are stored in another hash in the key \c ^attributes^. That is; the value of the \c ^attributes^ key must be a hash, and each member of this hash will represent an attribute-value pair.

    For example:

    @code
$h = ( "record" : ( "^attributes^" : ( "type" : "customer" ) , 
	            "name" : ( "first" : "Fred", "last" : "Smith" ) ) );
printf("%s\n", makeFormattedXMLString($h));@endcode

    This produces the following results:

    @verbatim
<?xml version="1.0" encoding="UTF-8"?>
<record type="customer">
  <name>
    <first>Fred</first>
    <last>Smith</last>
  </name>
</record> @endverbatim

    If instead we wanted to have text instead of child data under the "record" node, we must set the ^value^ key of the hash along with the ^attributes^ key as follows:

    @code
$h = ( "record" : ( "^attributes^" : ( "type" : "customer" ) , 
	            "^value^" : "NO-RECORD" ) );
printf("%s\n", makeFormattedXMLString($h)); @endcode

    Giving the following results:

    @verbatim <?xml version="1.0" encoding="UTF-8"?>
<record type="customer">NO-RECORD</record>@endverbatim

    Arrays are serialized with repeating node names as follows:

    @code
$h = ( "record" : ( "part" : ( "part-02-05", "part-99-23", "part-34-28" ) ) );
printf("%s\n", makeFormattedXMLString($h));@endcode

    Producing the following results:

    @verbatim
<?xml version="1.0" encoding="UTF-8"?>
<record type="customer">
  <part>part-02-05</part>
  <part>part-99-23</part>
  <part>part-34-28</part>
</record>@endverbatim

    It gets a little trickier when a key should repeated at the same level in an XML string, but other keys come between, for example, take the following XML string:

    @verbatim
<?xml version="1.0" encoding="UTF-8"?>
<para>Keywords: <code>this</code>, <code>that</code>, and <code>the_other</code>.</para>@endverbatim

    It's not possible to use a list, because text is required in between. As described earlier, the ^value^ hash key can be used to serialize text in an XML string. In this case, we need to have several text nodes and several code nodes in a mixed-up order to give us the XML string we want. Because qore hases have unique keys (we can't use the same key twice in the same hash), we resort to a key naming trick that allows us to virtually duplicate our key names and therefore arrive at the XML string we want. We do this by appending a \c '^' character to the end of the key name and then some unique text. When serializing hash keys, any text after (and including) the '^' character is ignored. For the special key name ^value^, we do not need to duplicate the final \c '^' character. Instead we just add unique text to ensure that our hash can contain all the data we want and that it will be serialized in the right order to the XML string as follows:

    @code
$h = ( "para" : ( "^value^" : "Keywords: ", 
                  "code" : "this", 
                  "^value^1" : ", ", 
                  "code^1" : "that", 
                  "^value^2" : ", and ", 
                  "code^2" : "the_other", 
                  "^value^3" : "." ) );
printf("%s\n", makeFormattedXMLString($h));@endcode

    By ignoring the text after the \c '^' character, the above code will serialize to the XML string we want. In general, by using this convention, we can properly serialize multiple out-of-order keys without losing data and still have unique names for our hash keys.

    Note than when deserializing XML strings to Qore data structures, the above rules are applied in reverse. If any out-of-order duplicate keys are detected, Qore will automatically generate unique hash key names based on the above rules.

    Also note that \c CDATA text will be generated if a hash key starts with \c '^cdata'; such text will not be processed for escape code substitution. When deserializing XML strings to qore data structures, CDATA text will be placed unmodified under such a hash key as well.

    <b>Functions For XML Serialization and Deserialization</b>
    |!Function Name|!Description
    |makeFormattedXMLFragment()|Serializes a hash into an XML string with formatting without an XML header.
    |makeFormattedXMLString()|Serializes a hash into an XML string with formatting and an XML header.
    |makeXMLFragment()|Serializes a hash into an XML string without an XML header or formatting.
    |makeXMLString()|Serializes a hash into a complete XML string with an XML header and without formatting.
    |parseXMLAsData()|parses an XML string as data (duplicate, out-of-order XML elements are collapsed into lists) and returns a Qore hash structure.
    |parseXMLAsDataWithRelaxNG()|parses an XML string as data (duplicate, out-of-order XML elements are collapsed into lists) and validates against a RelaxNG schema string and returns a Qore hash structure.
    |parseXMLAsDataWithSchema()|parses an XML string as data (duplicate, out-of-order XML elements are collapsed into lists) and validates against an XSD schema string and returns a Qore hash structure.
    |parseXML()|parses an XML string (XML element order is preserved by appending numeric suffixes to Qore hash key names when necessary) and returns a Qore hash structure.
    |parseXMLWithRelaxNG()|parses an XML string (XML element order is preserved by appending numeric suffixes to Qore hash key names when necessary) and validates against a RelaxNG schema string and returns a Qore hash structure.
    |parseXMLWithSchema()|parses an XML string (XML element order is preserved by appending numeric suffixes to Qore hash key names when necessary) and validates against an XSD schema string and returns a Qore hash structure.

    @anchor xmlclasses
    <b>Classes Providing XML Functionality</b>
    |!Class|!Description
    |XmlDoc|For analyzing and manipulating XML documents.
    |XmlNode|Gives information about XML data in an XML document.
    |XmlReader|For parsing or iterating through the elements of an XML document.

    @section XMLRPC XML-RPC

    XML-RPC is a lightweight but powerful XML over HTTP web service protocol. Qore includes builtin support for this protocol. You can find more information about XML-RPC, including specifications and examples at http://xmlrpc.org.

    Information about Qore's XML-RPC serialization can be found below.

    <b>XML-RPC Serialization in Qore</b>
    |!Qore Type|!XML-RPC Type|!Description
    |\c string|\c string|direct conversion to UTF-8 string
    |\c integer|\c i4 or \c string|If the integer requires more than 32 bits to represent, then it is sent as a string
    |\c float|\c double|direct conversion
    |\c boolean|\c boolean|direct conversion
    |\c date|\c iso8601|Absolute date/time values will convert to the default time zone for the calling context for the output string if necessary. Note that relative date/time values (durations) will be serialized with the same format as absolute date/time values.
    |\c binary|\c base64|direct conversion
    |\c list|\c array|direct conversion
    |\c hash|\c struct|direct conversion
    |all others|n/a|All other types will cause an \c XML-RPC-SERIALIZATION-ERROR to be raised.
	 
    <b>Classes Providing XML-RPC Functionality</b>
    |!Class|!Description
    |XmlRpcClient|For communicating with XML-RPC servers

    <b>Functions Providing XML-RPC Functionality</b>
    |!Function Name|!Description
    |makeFormattedXMLRPCCallString()|Serializes a hash into an XML string formatted for an XML-RPC call with formatting.
    |makeFormattedXMLRPCCallStringArgs()|Serializes a hash into an XML string formatted for an XML-RPC call with formatting, taking a single list argument for the argument list.
    |makeFormattedXMLRPCCallStringWithEncoding()|Serializes a hash into an XML string formatted for an XML-RPC call with formatting and an explicit output encoding
    |makeFormattedXMLRPCCallStringArgsWithEncoding()|Serializes a hash into an XML string formatted for an XML-RPC call with formatting, taking a single list argument for the argument list and an explicit output encoding
    |makeFormattedXMLRPCFaultResponseString()|Serializes a hash into an XML string formatted for an XML-RPC fault response with formatting.
    |makeFormattedXMLRPCFaultResponseStringWithEncoding()|Serializes a hash into an XML string formatted for an XML-RPC fault response with formatting and an explicit output encoding.
    |makeFormattedXMLRPCResponseString()|Serializes a hash into an XML string formatted for an XML-RPC response with formatting.
    |makeFormattedXMLRPCResponseStringWithEncoding()|Serializes a hash into an XML string formatted for an XML-RPC response with formatting and an explicit output encoding.
    |makeFormattedXMLRPCValueString()|Serializes a hash into an XML string in XML-RPC value format with formatting.
    |makeXMLRPCCallString()|Serializes a hash into an XML string formatted for an XML-RPC call without formatting.
    |makeXMLRPCCallStringArgs()|Serializes a hash into an XML string formatted for an XML-RPC call without formatting, taking a single list argument for the argument list.
    |makeXMLRPCCallStringWithEncoding()|Serializes a hash into an XML string formatted for an XML-RPC call without formatting and an explicit output encoding.
    |makeXMLRPCCallStringArgsWithEncoding()|Serializes a hash into an XML string formatted for an XML-RPC call without formatting, taking a single list argument for the argument list and an explicit output encoding.
    |makeXMLRPCFaultResponseString()|Serializes a hash into an XML string formatted for an XML-RPC fault response without formatting.
    |makeXMLRPCFaultResponseStringWithEncoding()|Serializes a hash into an XML string formatted for an XML-RPC fault response without formatting and an explicit output encoding.
    |makeXMLRPCResponseString()|Serializes a hash into an XML string formatted for an XML-RPC response without formatting.
    |makeXMLRPCResponseStringWithEncoding()|Serializes a hash into an XML string formatted for an XML-RPC response without formatting and an explicit output encoding.
    |makeXMLRPCValueString()|Serializes a hash into an XML string in XML-RPC value format without formatting.
    |parseXMLRPCCall()|deserializies an XML-RPC call string, returning a Qore hash respresenting the call information.
    |parseXMLRPCResponse()|deserializies an XML-RPC response string, returning a Qore hash respresenting the response information.
    |parseXMLRPCValue()|deserializies an XML-RPC value tree, returning a Qore hash respresenting the information.

    @section codetags Function and Method Tags

    @subsection NOOP

    Code with this flag makes no calculations, but rather returns a constant value. This flag is given to function and method variants that return a default value depending on the type of argument(s).  When variants with this flag are resolved at parse time, a \c "call-with-type-errors" warning is raised (assuming this warning is enabled), unless \c PO_REQUIRE_TYPES or \c PO_STRICT_ARGS is set.  If \c PO_REQUIRE_TYPES or \c PO_STRICT_ARGS is set, then these variants are inaccessible at parse time; resolving to a variant with this flag set at parse time causes an exception to be thrown.

    These variants are included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments.

    This tag is equal to @ref RUNTIME_NOOP, except no runtime effect is caused by resolving a function or method tagged with \c NOOP at runtime; this tag only affects parse time resolution.

    @subsection RUNTIME_NOOP

    Code with this flag makes no calculations, but rather returns a constant value.  This flag is given to function and method variants that return a default value depending on the type of argument(s).  When variants with this flag are resolved at parse time, a \c "call-with-type-errors" warning is raised (assuming this warning is enabled), unless \c PO_REQUIRE_TYPES or \c PO_STRICT_ARGS is set.  If \c PO_REQUIRE_TYPES or \c PO_STRICT_ARGS is set, then these variants are inaccessible; resolving to a variant with this flag set at parse time or run time causes an exception to be thrown.

    These variants are included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments.

    This tag is equal to @ref NOOP, except that \c RUNTIME_NOOP is also enforced at runtime.

    @subsection RET_VALUE_ONLY
	
    This flag indicates that the function or method has no side effects; it only returns a value, for example.

    This tag is identical to @ref CONSTANT except that functions or methods tagged with \c RET_VALUE_ONLY could throw exceptions.

    @subsection CONSTANT
	
    This flag indicates that the function or method has no side effects and does not throw any exceptions.

    This tag is identical to @ref RET_VALUE_ONLY except that functions or methods tagged with \c CONSTANT do not throw exceptions.

    @subsection DEPRECATED
	
    Code with this flag is deprecated and may be removed in a future version of Qore; if a variant with this flag is resolved at parse time, a \c "deprecated" warning is raised (assuming this warning is enabled).
*/
