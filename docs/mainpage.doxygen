/** @mainpage Qore XML Module

    @section intro Introduction

    XML functionality in the Qore xml module is provided by the <a href="http://xmlsoft.org">libxml2 library</a>, which provides a powerful, stable, clean, and thread-safe basis for XML integration in Qore.

    XML provides a way to describe hierarchical data, and thanks to  <a href="http://xmlsoft.org">libxml2</a>, Qore can allow for easy serialization and deserialization between XML strings and Qore data structures.

    @section optionconstants
    
    The following constants give information about the availability of XML functionality (dependent on libxml2 features at compile time):

    <b>XML Option Constants</b>
    @htmlonly <style><!-- td.qore { background-color: #5b9409; color: white; } --></style> @endhtmlonly
    <table>
      <tr>
        <td class="qore"><b>Name</b></td>
        <td class="qore"><b>Type</b></td>
        <td class="qore"><b>Description</b></td>
      </tr>
      <tr>
        <td>\c HAVE_PARSEXMLWITHRELAXNG</td>
        <td>\c bool</td>
        <td>Indicates if parseXMLWithRelaxNG() and XmlReader::relaxNGValidate() are available</td>
      </tr>
      <tr>
        <td>\c HAVE_PARSEXMLWITHSCHEMA</td>
        <td>\c bool</td>
        <td>Indicates if parseXMLWithSchema() and XmlReader::schemaValidate() are available</td>
      </tr>
    </table>

    If either of the above constants are \c False, then calling any of the dependent functions or methods will result in a run-time exception.

    @section serialization Automatic XML Serialization and Deserialization

    This section describes automatic XML serialization and deserialization; for iterative or user-controlled XML parsing, see @ref xmlclasses "XML Classes".

    XML serialization (conversion from Qore data structures to XML strings) in Qore relies on the fact that Qore hashes retain insertion order, which means that conversion to and from Qore data structures and XML strings can be done without data loss and without reordering the XML elements. In general, XML serialization is relatively straighforward, but there are a few issues to be aware of, particularly regarding element attributes and lists. These issues are described in the following paragraphs.

    First, a straightforward example:

    @code
__6_h = ( "record" : ( "name" : ( "first" : "Fred", "last" : "Smith" ) ) );
printf("%s\n", makeFormattedXMLString(__6_h));@endcode

    This produces the following result

    @verbatim
<?xml version="1.0" encoding="UTF-8"?>
<record>
  <name>
    <first>Fred</first>
    <last>Smith</last>
  </name>
</record>@endverbatim

    To set XML attributes, the Qore value must be a hash and the attributes are stored in another hash in the key \c ^attributes^. That is; the value of the \c ^attributes^ key must be a hash, and each member of this hash will represent an attribute-value pair.

    For example:

    @code
__6_h = ( "record" : ( "^attributes^" : ( "type" : "customer" ) , 
	            "name" : ( "first" : "Fred", "last" : "Smith" ) ) );
printf("%s\n", makeFormattedXMLString(__6_h));@endcode

    This produces the following results:

    @verbatim
<?xml version="1.0" encoding="UTF-8"?>
<record type="customer">
  <name>
    <first>Fred</first>
    <last>Smith</last>
  </name>
</record> @endverbatim

    If instead we wanted to have text instead of child data under the "record" node, we must set the ^value^ key of the hash along with the ^attributes^ key as follows:

    @code
__6_h = ( "record" : ( "^attributes^" : ( "type" : "customer" ) , 
	            "^value^" : "NO-RECORD" ) );
printf("%s\n", makeFormattedXMLString(__6_h)); @endcode

    Giving the following results:

    @verbatim <?xml version="1.0" encoding="UTF-8"?>
<record type="customer">NO-RECORD</record>@endverbatim

    Arrays are serialized with repeating node names as follows:

    @code
__6_h = ( "record" : ( "part" : ( "part-02-05", "part-99-23", "part-34-28" ) ) );
printf("%s\n", makeFormattedXMLString(__6_h));@endcode

    Producing the following results:

    @verbatim
<?xml version="1.0" encoding="UTF-8"?>
<record type="customer">
  <part>part-02-05</part>
  <part>part-99-23</part>
  <part>part-34-28</part>
</record>@endverbatim

    It gets a little trickier when a key should repeated at the same level in an XML string, but other keys come between, for example, take the following XML string:

    @verbatim
<?xml version="1.0" encoding="UTF-8"?>
<para>Keywords: <code>this</code>, <code>that</code>, and <code>the_other</code>.</para>@endverbatim

    It's not possible to use a list, because text is required in between. As described earlier, the ^value^ hash key can be used to serialize text in an XML string. In this case, we need to have several text nodes and several code nodes in a mixed-up order to give us the XML string we want. Because qore hases have unique keys (we can't use the same key twice in the same hash), we resort to a key naming trick that allows us to virtually duplicate our key names and therefore arrive at the XML string we want. We do this by appending a \c '^' character to the end of the key name and then some unique text. When serializing hash keys, any text after (and including) the '^' character is ignored. For the special key name ^value^, we do not need to duplicate the final \c '^' character. Instead we just add unique text to ensure that our hash can contain all the data we want and that it will be serialized in the right order to the XML string as follows:

    @code
__6_h = ( "para" : ( "^value^" : "Keywords: ", 
                  "code" : "this", 
                  "^value^1" : ", ", 
                  "code^1" : "that", 
                  "^value^2" : ", and ", 
                  "code^2" : "the_other", 
                  "^value^3" : "." ) );
printf("%s\n", makeFormattedXMLString(__6_h));@endcode

    By ignoring the text after the \c '^' character, the above code will serialize to the XML string we want. In general, by using this convention, we can properly serialize multiple out-of-order keys without losing data and still have unique names for our hash keys.

    Note than when deserializing XML strings to Qore data structures, the above rules are applied in reverse. If any out-of-order duplicate keys are detected, Qore will automatically generate unique hash key names based on the above rules.

    Also note that \c CDATA text will be generated if a hash key starts with \c '^cdata'; such text will not be processed for escape code substitution. When deserializing XML strings to qore data structures, CDATA text will be placed unmodified under such a hash key as well.

    <b>Functions For XML Serialization and Deserialization</b>
    <table>
      <tr>
        <td class="qore"><b>Function Name</b></td>
        <td class="qore"><b>Description</b></td>
      </tr>
      <tr>
        <td>makeFormattedXMLFragment()</td>
        <td>Serializes a hash into an XML string with formatting without an XML header.</td>
      </tr>
      <tr>
        <td>makeFormattedXMLString()</td>
        <td>Serializes a hash into an XML string with formatting and an XML header.</td>
      </tr>
      <tr>
        <td>makeXMLFragment()</td>
        <td>Serializes a hash into an XML string without an XML header or formatting.</td>
      </tr>
      <tr>
        <td>makeXMLString()</td>
        <td>Serializes a hash into a complete XML string with an XML header and without formatting.</td>
      </tr>
      <tr>
        <td>parseXMLAsData()</td>
        <td>parses an XML string as data (duplicate, out-of-order XML elements are collapsed into lists) and returns a Qore hash structure.</td>
      </tr>
      <tr>
        <td>parseXMLAsDataWithSchema()</td>
        <td>parses an XML string as data (duplicate, out-of-order XML elements are collapsed into lists) and validates against an XSD schema string and returns a Qore hash structure.</td>
      </tr>
      <tr>
        <td>parseXML()</td>
        <td>parses an XML string (XML element order is preserved by appending numeric suffixes to Qore hash key names when necessary) and returns a Qore hash structure.</td>
      </tr>
      <tr>
        <td>parseXMLWithSchema()</td>
        <td>parses an XML string (XML element order is preserved by appending numeric suffixes to Qore hash key names when necessary) and validates against an XSD schema string and returns a Qore hash structure.</td>
      </tr>
    </table>

    @anchor xmlclasses
    <b>Classes Providing XML Functionality</b>
    <table>
      <tr>
        <td class="qore"><b>Class</b></td>
        <td class="qore"><b>Description</b></td>
      </tr>
      <tr>
        <td>XmlDoc</td>
        <td>For analyzing and manipulating XML documents.</td>
      </tr>
      <tr>
        <td>XmlNode</td>
        <td>Gives information about XML data in an XML document.</td>
      </tr>
      <tr>
        <td>XmlReader</td>
        <td>For parsing or iterating through the elements of an XML document.</td>
      </tr>
    </table>

    @section XMLRPC XML-RPC

    XML-RPC is a lightweight but powerful XML over HTTP web service protocol. Qore includes builtin support for this protocol. You can find more information about XML-RPC, including specifications and examples at http://xmlrpc.org.

    Information about Qore's XML-RPC serialization can be found below.

    <b>XML-RPC Serialization in Qore</b>
    <table>
      <tr>
        <td class="qore"><b>Qore Type</b></td>
        <td class="qore"><b>XML-RPC Type</b></td>
        <td class="qore"><b>Description</b></td>
      </tr>
      <tr>
        <td>\c string</td>
        <td>\c string</td>
        <td>direct conversion to UTF-8 string</td>
      </tr>
      <tr>
        <td>\c integer</td>
        <td>\c i4 or \c string</td>
        <td>If the integer requires more than 32 bits to represent, then it is sent as a string</td>
      </tr>
      <tr>
        <td>\c float</td>
        <td>\c double</td>
        <td>direct conversion</td>
      </tr>
      <tr>
        <td>\c boolean</td>
        <td>\c boolean</td>
        <td>direct conversion</td>
      </tr>
      <tr>
        <td>\c date</td>
        <td>\c iso8601</td>
        <td>Absolute date/time values will convert to the default time zone for the calling context for the output string if necessary. Note that relative date/time values (durations) will be serialized with the same format as absolute date/time values.</td>
      </tr>
      <tr>
        <td>\c binary</td>
        <td>\c base64</td>
        <td>direct conversion</td>
      </tr>
      <tr>
        <td>\c list</td>
        <td>\c array</td>
        <td>direct conversion</td>
      </tr>
      <tr>
        <td>\c hash</td>
        <td>\c struct</td>
        <td>direct conversion</td>
      </tr>
      <tr>
        <td>all others</td>
        <td>n/a</td>
        <td>All other types will cause an \c XML-RPC-SERIALIZATION-ERROR to be raised.</td>
      </tr>
    </table>
	 
    <b>Classes Providing XML-RPC Functionality</b>
    <table>
      <tr>
        <td class="qore"><b>Class</b></td>
        <td class="qore"><b>Description</b></td>
      </tr>
      <tr>
        <td>XmlRpcClient</td>
        <td>For communicating with XML-RPC servers</td>
      </tr>
    </table>

    <b>Functions Providing XML-RPC Functionality</b>
    <table>
      <tr>
        <td class="qore"><b>Function Name</b></td>
        <td class="qore"><b>Description</b></td>
      </tr>
      <tr>
        <td>makeFormattedXMLRPCCallString()</td>
        <td>Serializes a hash into an XML string formatted for an XML-RPC call with formatting.</td>
      </tr>
      <tr>
        <td>makeFormattedXMLRPCCallStringArgs()</td>
        <td>Serializes a hash into an XML string formatted for an XML-RPC call with formatting, taking a single list argument for the argument list.</td>
      </tr>
      <tr>
        <td>makeFormattedXMLRPCFaultResponseString()</td>
        <td>Serializes a hash into an XML string formatted for an XML-RPC fault response with formatting.</td>
      </tr>
      <tr>
        <td>makeFormattedXMLRPCResponseString()</td>
        <td>Serializes a hash into an XML string formatted for an XML-RPC response with formatting.</td>
      </tr>
      <tr>
        <td>makeFormattedXMLRPCValueString()</td>
        <td>Serializes a hash into an XML string in XML-RPC value format with formatting.</td>
      </tr>
      <tr>
        <td>makeXMLRPCCallString()</td>
        <td>Serializes a hash into an XML string formatted for an XML-RPC call without formatting.</td>
      </tr>
      <tr>
        <td>makeXMLRPCCallStringArgs()</td>
        <td>Serializes a hash into an XML string formatted for an XML-RPC call without formatting, taking a single list argument for the argument list.</td>
      </tr>
      <tr>
        <td>makeXMLRPCFaultResponseString()</td>
        <td>Serializes a hash into an XML string formatted for an XML-RPC fault response without formatting.</td>
      </tr>
      <tr>
        <td>makeXMLRPCResponseString()</td>
        <td>Serializes a hash into an XML string formatted for an XML-RPC response without formatting.</td>
      </tr>
      <tr>
        <td>makeXMLRPCValueString()</td>
        <td>Serializes a hash into an XML string in XML-RPC value format without formatting.</td>
      </tr>
      <tr>
        <td>parseXMLRPCCall()</td>
        <td>deserializies an XML-RPC call string, returning a Qore hash respresenting the call information.</td>
      </tr>
      <tr>
        <td>parseXMLRPCResponse()</td>
        <td>deserializies an XML-RPC response string, returning a Qore hash respresenting the response information.</td>
      </tr>
      <tr>
        <td>parseXMLRPCValue()</td>
        <td>deserializies an XML-RPC value tree, returning a Qore hash respresenting the information.</td>
      </tr>
    </table>

*/
