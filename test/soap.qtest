#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

# requires at least this qore version to run
%requires qore >= 0.8.12

%new-style
%require-types
%strict-args
%enable-all-warnings

%requires QUnit

%requires ../qlib/WSDL.qm
%requires xml

%exec-class SoapTest

# maps from namespace prefixes to URIs and vice-versa
class NsMap {
    public {
        # maps from prefixes to URIs
        hash pmap;
        # maps from URIs to prefixes
        hash umap;

        # soap envelope name
        string se;
    }

    set(string prefix, string uri) {
        if (exists pmap{prefix})
            throw "SOAP-ENVELOPE-ERROR", sprintf("prefix %y given more than once in SOAP envelope attributes", prefix);

        pmap{prefix} = uri;
        umap{uri} = prefix;

        if (uri == SOAP_12_ENV || uri == SOAP_11_ENV)
            se = prefix;
    }

    # returns the SOAP envelope URI
    string getSoapUri() {
        return pmap{se};
    }
}

class SoapTest inherits QUnit::Test {
    public {
        const SoapEnvAttr = (
            "^attributes^": (
                "xmlns:soap": "http://www.w3.org/2003/05/soap-envelope",
                "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
                "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
                "xmlns:st": "http://qore.org/simpletest",
                "xmlns:st1": "http://qore.org/simpletest1",
            ),
            );

        # all values are strings here because we do raw XML parsing and not SOAP deserialization for the comparison
        # to avoid comparing values generated and parsed with the same code which would result in an identity test
        const Req_1 = (
            "soap:Envelope": SoapEnvAttr + (
                "soap:Body": (
                    "st:setInfo": (
                        "st:SetInfo": (
                            "^attributes^": (
                                "infoType": "test",
                                "code": "1",
                            ),
                            "st:name": "QORE",
                            "st:id": "500",
                        ),
                        "st:Test": (
                            "^attributes^": (
                                "info": "test",
                            ),
                            "^value^": "test",
                        ),
                        "st:issue86": (
                            "st1:issue86_1_1": "i86_1",
                            "st:issue86_1_2": "i86_2",
                        ),
                        "st:issue87": (
                            "st:issue87e1": "i87",
                            "st:choice12": "i87c12",
                        ),
                        "st:issue97": (
                            "st:i97list": NOTHING,
                        ),
                        "st:issue468": (
                            "st:issue468_1": (
                                "^attributes^": (
                                    "xsi:nil": "true",
                                ),
                            ),
                        ),
                        "st:issue560": (
                            "st:issue560_3": "A",
                            "st:issue560_2": "A",
                            "st:issue560_1": "A",
                        ),
                        "st:issue984": (
                            "st:i984_empty": NOTHING,
                        ),
                        "st:issue985": (
                            "^attributes^": (
                                "xsi:type": "st:i985_2",
                            ),
                            "st:i985_e1": "test",
                            "st:i985_e2": "test",
                        ),
                        "logo": "dGVzdA==",
                    ),
                ),
            ),
            );

        const Res_1 = (
            "SetInfoResult": "test",
            "issue663": (
                "i663list": (),
            ),
            );

        const SoapUiReq_1 = "<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:sim=\"http://qore.org/simpletest\" xmlns:sim1=\"http://qore.org/simpletest1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">
   <soap:Header/>
   <soap:Body>
      <sim:setInfo>
         <sim:SetInfo infoType=\"test\" code=\"1\">
            <!--You may enter the following 2 items in any order-->
            <sim:name>QORE</sim:name>
            <sim:id>500</sim:id>
         </sim:SetInfo>
         <sim:Test info=\"test\">test</sim:Test>
         <sim:issue86>
            <sim1:issue86_1_1>i86_1</sim1:issue86_1_1>
            <sim:issue86_1_2>i86_2</sim:issue86_1_2>
         </sim:issue86>
         <sim:issue87>
            <sim:issue87e1>i87</sim:issue87e1>
            <!--You have a CHOICE of the next 2 items at this level-->
            <sim:choice12>i87c12</sim:choice12>
         </sim:issue87>
         <sim:issue97>
            <sim:i97list/>
         </sim:issue97>
         <sim:issue468>
            <sim:issue468_1 xsi:nil=\"true\"/>
         </sim:issue468>
         <sim:issue560>
            <sim:issue560_1>A</sim:issue560_1>
            <sim:issue560_2>A</sim:issue560_2>
            <sim:issue560_3>A</sim:issue560_3>
         </sim:issue560>
         <sim:issue984>
            <sim:i984_empty/>
         </sim:issue984>
         <sim:issue985 xsi:type=\"sim:i985_2\">
            <sim:i985_e1>test</sim:i985_e1>
            <sim:i985_e2>test</sim:i985_e2>
         </sim:issue985>
         <logo>dGVzdA==</logo>
      </sim:setInfo>
   </soap:Body>
</soap:Envelope>";

        const EmptyReq = (
            "soap:Envelope": SoapEnvAttr,
            );

        const EmptyRes = EmptyReq;

        const TestRes = (
            "soap:Envelope": SoapEnvAttr + (
                "soap:Body": (
                    "st:setInfoResponse": (
                        "st:SetInfoResult": "test",
                        "st:issue663": (
                            "st:i663list": NOTHING,
                        ),
                    ),
                ),
            ),
            );

        const RMap = (
            "body": "SetInfoResult",
            "issue663": "issue663",
            );

        const SoapEnvAttr1 = (
            "^attributes^": (
                "xmlns:soap": SOAP_11_ENV,
                "xmlns:tes": "http://example.com/test1/test1_ws",
            ),
            );

        # all values are strings here because we do raw XML parsing and not SOAP deserialization for the comparison
        # to avoid comparing values generated and parsed with the same code which would result in an identity test
        const Req1_1 = (
            "soap:Envelope": SoapEnvAttr1 + (
                "soap:Body": (
                    "tes:test1": (
                        "tes:arg1": "x",
                        "tes:arg2": "y",
                    ),
                ),
            ),
            );

        const SoapEnvAttr1Res = (
            "^attributes^": (
                "xmlns:soap": SOAP_11_ENV,
                "xmlns:tes": "http://example.com/test1/test1_ws",
                "xmlns:oth": "http://example.com/test1/other",
            ),
            );

        const Test1Res = (
            "soap:Envelope": SoapEnvAttr1Res + (
                "soap:Body": (
                    "tes:test1Response": (
                        "oth:Root": (
                            "Struct": (
                                "arg1": "1",
                                "arg2": "2",
                                "arg3": "3",
                                "arg4": "4",
                            ),
                            "res1": "a",
                            "res2": "b",
                        ),
                    ),
                ),
            ),
            );

        const Res1_1 = (
            "Root": (
                "Struct": (
                    "arg1": "1",
                    "arg2": "2",
                    "arg3": "3",
                    "arg4": "4",
                ),
                "res1": "a",
                "res2": "b",
            ),
            );
    }

    constructor() : QUnit::Test("SoapTest", "1.0") {
        addTestCase("SoapTestCase", \soapTestCase());
        addTestCase("Test1", \test1());
        addTestCase("globalweather", \globalWeather());
        set_return_value(main());
    }

    soapTestCase() {
        WebService ws(ReadOnlyFile::readTextFile(get_script_dir() + "/test.wsdl"));
        WSOperation op = ws.getOperation("setInfo");

        hash req = (
            "body": ("name": "QORE", "id": 500),
            "test": (
                "^attributes^": ("info": "test"),
                "^value^": "test",
            ),
            "issue86": (
                "issue86_1_1": "i86_1",
                "issue86_1_2": "i86_2",
            ),
            "issue87": (
                "issue87e1": "i87",
                "choice12": "i87c12",
            ),
            "issue97": (
                "i97list": NOTHING,
            ),
            "issue468": (
                "issue468_1": NOTHING,
            ),
            "issue560": (
                "issue560_1": "A",
                "issue560_2": "A",
                "issue560_3": "A",
            ),
            "issue984": (
                "i984_empty": NOTHING,
            ),
            "issue985": ws.getType("i985_2", ("i985_e1": "test", "i985_e2": "test",)),
            "logo": binary("test"),
            );

        # negative test w/o attributes
        assertThrows("SOAP-SERIALIZATION-ERROR", \op.serializeRequest(), req, "attr-ser-neg");

        req.body."^attributes^" = (
            "infoType": "test",
            "code": 1,
            );

        hash h = op.serializeRequest(req, NOTHING, NOTHING, NOTHING, XGF_ADD_FORMATTING, "TEST");
        assertEq("TEST", h.hdr.SOAPAction);
        hash xh = parse_xml(h.body);
        compareSoapMsgs("attr-ser", Req_1, xh);

        h = op.deserializeRequest(xh);
        assertEq(NOTHING, h.hdr.SOAPAction);

        hash req_r = req + (
            "issue985": (
                "i985_e1": "test", "i985_e2": "test",
            ),
            );

        assertEq(req_r, h, "attr-deser-our");

        # do negative tests to ensure that namespace handling is correct in our test code
        {
            NsMap nh = SoapTest::getNamespaceMap(Req_1);
            string ek = SoapTest::getKey(nh.se, "Envelope");
            string bk = SoapTest::getKey(nh.se, "Body");
            string pfx = nh.umap."http://qore.org/simpletest";
            string sik1 = SoapTest::getKey(pfx, "setInfo");
            string sik2 = SoapTest::getKey(pfx, "SetInfo");

            hash r1 = Req_1;

            # rename key with an undefined namespace
            r1{ek}{bk}{sik1}."xxx:SetInfo" = remove r1{ek}{bk}{sik1}{sik2};
            assertThrows("SOAP-NAMESPACE-ERROR", \compareSoapMsgs(), ("attr-ser", r1, xh), "attr-ser-neg-1");

            # rename key with a defined but incorrect namespace
            string sik = sprintf("%s:SetInfo", nh.umap."http://www.w3.org/2003/05/soap-envelope");
            r1{ek}{bk}{sik1}{sik} = remove r1{ek}{bk}{sik1}."xxx:SetInfo";
            assertThrows("TEST-EXCEPTION", \compareSoapMsgs(), ("attr-ser", r1, xh), "attr-ser-neg-2");
        }

        {
            NsMap nh = SoapTest::getNamespaceMap(xh);
            string ek = SoapTest::getKey(nh.se, "Envelope");
            string bk = SoapTest::getKey(nh.se, "Body");
            string pfx = nh.umap."http://qore.org/simpletest";
            string sik1 = SoapTest::getKey(pfx, "setInfo");
            string sik2 = SoapTest::getKey(pfx, "SetInfo");

            # rename key with an undefined namespace
            xh{ek}{bk}{sik1}."xxx:SetInfo" = remove xh{ek}{bk}{sik1}{sik2};
            assertThrows("TEST-EXCEPTION", \compareSoapMsgs(), ("attr-ser", Req_1, xh), "attr-ser-neg-3");

            # rename key with a defined but incorrect namespace
            pfx = nh.umap."http://www.w3.org/2003/05/soap-envelope";
            xh{ek}{bk}{sik1}{pfx} = remove xh{ek}{bk}{sik1}."xxx:SetInfo";
            assertThrows("TEST-EXCEPTION", \compareSoapMsgs(), ("attr-ser", Req_1, xh), "attr-ser-neg-4");
        }

        h = parse_xml(SoapUiReq_1);
        h = op.deserializeRequest(h);

        assertEq(req_r, h, "attr-deser-soapui");

        h = op.serializeResponse(Res_1);
        xh = parse_xml(h.body);
        compareSoapMsgs("output", TestRes, xh);
        *hash eh = op.deserializeResponse(xh);
        # map message part names to element names
        eh = map {RMap{$1.key}: $1.value}, eh.pairIterator();
        if (!exists eh.issue663.i663list)
            eh.issue663.i663list = ();
        assertEq(Res_1, eh);

        op = ws.getOperation("noInput");
        h = op.serializeRequest();
        xh = parse_xml(h.body);
        compareSoapMsgs("no-input", EmptyReq, xh);
        eh = op.deserializeRequest(h);
        assertEq(NOTHING, eh);

        op = ws.getOperation("noOutput");
        h = op.serializeResponse();
        xh = parse_xml(h.body);
        compareSoapMsgs("no-output", EmptyRes, xh);
        eh = op.deserializeResponse(h);
        assertEq(NOTHING, eh);
    }

    test1() {
        WebService ws(ReadOnlyFile::readTextFile(get_script_dir() + "/test1.wsdl"));

        WSOperation op = ws.getOperation("test1");

        hash req = (
            "arg1": "x",
            "arg2": "y",
            );

        hash h = op.serializeRequest(req, NOTHING, NOTHING, NOTHING, XGF_ADD_FORMATTING);
        hash xh = parse_xml(h.body);
        #printf("xh: %N\n", xh);
        #printf("r1: %N\n", Req1_1);
        compareSoapMsgs("attr-ser", Req1_1, xh);

        h = op.serializeResponse(Res1_1);
        xh = parse_xml(h.body);
        compareSoapMsgs("output", Test1Res, xh);
        *hash eh = op.deserializeResponse(xh);
        assertEq(Res1_1, eh, "deserialize response");
    }

    globalWeather() {
        assertThrows("WSDL-ERROR", sub () { WebService ws(ReadOnlyFile::readTextFile(get_script_dir() + "/globalweather.wsdl")); }, NOTHING, "http binding");
    }

    compareSoapMsgs(string assert, hash h1, hash h2) {
        # get namespace hashes and soap envelope prefix
        NsMap nh1 = SoapTest::getNamespaceMap(h1);
        NsMap nh2 = SoapTest::getNamespaceMap(h2);

        # compare soap version in envelope
        assertEq(nh1.getSoapUri(), nh2.getSoapUri());

        *hash b1 = SoapTest::getValue(h1, nh1.se, "Envelope", "Body");
        *hash b2 = SoapTest::getValue(h2, nh2.se, "Envelope", "Body");

        compareSoapValue(assert, "Envelope.Body", b1, b2, nh1, nh2);
    }

    compareSoapValue(string assert, string loc, any v1, any v2, NsMap nh1, NsMap nh2) {
        if (v1.typeCode() == NT_STRING) {
            # check if value is a namespace-prefixed string and processing accordingly if so
            if ((*string nv1, *string kv1) = (v1 =~ x/^(\w+):(\w+)$/)) {
                *string uri1 = nh1.pmap{nv1};
                if (!exists uri1)
                    throw "SOAP-NAMESPACE-ERROR", sprintf("%s (%s) namespace prefix in %y in the expected value is not defined", assert, loc, v1);
                *string nv2 = nh2.umap{uri1};
                if (!exists nv2)
                    throw "SOAP-NAMESPACE-ERROR", sprintf("%s (%s) expected namespace URI %y in value %y is not defined in the given value", assert, loc, uri1, v1);
                # generate expected value
                string str = sprintf("%s:%s", nv2, kv1);
                assertEq(str, v2);
            }
            else
                assertEq(v1, v2, sprintf("%s (%s) values match", assert, loc));
            return;
        }

        if (v1.typeCode() != NT_HASH) {
            assertEq(v1, v2, sprintf("%s (%s)", assert, loc));
            return;
        }

        # check attributes
        foreach hash h in (v2."^attributes^".pairIterator()) {
            (*string nsp1, *string key) = (h.key =~ x/^(\w+):(\w+)$/);
            if (nsp1 && key) {
                *string uri2 = nh2.pmap{nsp1};
                if (!uri2)
                    throw "SOAP-NAMESPACE-ERROR", sprintf("%s (%s) namespace prefix in %y in the generated value is not defined", assert, loc, h.key);

                # check type value
                if (key == "type" && uri2 == XSI_NS && h.value =~ / /)
                    throw "SOAP-TYPE-ERROR", sprintf("%s (%s) xsi:type=%y is invalid", assert, loc, h.value);
            }
        }

        foreach string rkey in (v1.keyIterator()) {
            (*string nsp1, *string key) = (rkey =~ x/^(\w+):(\w+)$/);
            if (!nsp1) {
                assertTrue(v2.hasKey(rkey), sprintf("%s (%s) has element %y", assert, loc, rkey));
                compareSoapValue(assert, sprintf("%s.%s", loc, rkey), v1{rkey}, v2{rkey}, nh1, nh2);
                remove v2{rkey};
                continue;
            }
            *string uri1 = nh1.pmap{nsp1};
            if (!exists uri1)
                throw "SOAP-NAMESPACE-ERROR", sprintf("%s (%s) namespace prefix in %y in the expected value is not defined", assert, loc, rkey);
            *string nsp2 = nh2.umap{uri1};
            if (!exists nsp2)
                throw "SOAP-NAMESPACE-ERROR", sprintf("%s (%s) expected namespace URI %y in key %y is not defined in the given value", assert, loc, uri1, rkey);
            string k2 = SoapTest::getKey(nsp2, key);
            assertTrue(v2.hasKey(k2), sprintf("expected value %s has key %y", loc, k2));
            compareSoapValue(assert, sprintf("%s.%s", loc, key), v1{rkey}, v2{k2}, nh1, nh2);
            remove v2{k2};
        }

        assertEq((), v2.keys(), sprintf("%s all keys matched", loc));
    }

    static any getValue(hash h, string nsp, string key) {
        any rv = h{SoapTest::getKey(nsp, key)};
        map rv = rv{SoapTest::getKey(nsp, $1)}, argv;
        return rv;
    }

    static string getKey(string nsp, string key) {
        return sprintf("%s:%s", nsp, key);
    }

    static NsMap getNamespaceMap(hash h) {
        string fk = h.firstKey();
        h = h{fk};

        NsMap rv();
        foreach hash ah in (h."^attributes^".pairIterator()) {
            (*string xmlns, *string prefix) = (ah.key =~ x/^(\w+):(\w+)$/);
            if (xmlns != "xmlns")
                continue;
            rv.set(prefix, ah.value);
        }
        if (!rv.se)
            throw "SOAP-ENVELOPE-ERROR", sprintf("no SOAP envelope namespace provided in SOAP envelope attributes: %y", h."^attributes^");

        if (fk != sprintf("%s:Envelope", rv.se))
            throw "SOAP-ENVELOPE-ERROR", sprintf("SOAP envelope key %y is not in the SOAP envelope namespace: %y", fk, rv.se);

        return rv;
    }
}
