#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

# requires at least this qore version to run
%requires qore >= 0.8.13

%new-style
%require-types
%strict-args
%enable-all-warnings

%requires QUnit
%requires Util

%requires ../qlib/WSDL.qm
%requires xml

%exec-class SoapTest

# maps from namespace prefixes to URIs and vice-versa
class NsMap {
    public {
        # maps from prefixes to URIs
        hash pmap;
        # maps from URIs to prefixes
        hash umap;

        # soap envelope name
        string se;
    }

    set(string prefix, string uri) {
        if (exists pmap{prefix})
            throw "SOAP-ENVELOPE-ERROR", sprintf("prefix %y given more than once in SOAP envelope attributes", prefix);

        pmap{prefix} = uri;
        umap{uri} = prefix;

        if (uri == SOAP_12_ENV || uri == SOAP_11_ENV)
            se = prefix;
    }

    # returns the SOAP envelope URI
    string getSoapUri() {
        return pmap{se};
    }
}

class SoapTest inherits QUnit::Test {
    public {
        const SoapEnvAttr = (
            "^attributes^": (
                "xmlns:soap": "http://www.w3.org/2003/05/soap-envelope",
                "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
                "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
                "xmlns:st": "http://qore.org/simpletest",
                "xmlns:st1": "http://qore.org/simpletest1",
            ),
        );

        # all values are strings here because we do raw XML parsing and not SOAP deserialization for the comparison
        # to avoid comparing values generated and parsed with the same code which would result in an identity test
        const Req_1 = (
            "soap:Envelope": SoapEnvAttr + (
                "soap:Body": (
                    "st:setInfo": (
                        "st:SetInfo": (
                            "^attributes^": (
                                "infoType": "test",
                                "code": "1",
                            ),
                            "st:name": "QORE",
                            "st:id": "500",
                        ),
                        "st:Test": (
                            "^attributes^": (
                                "info": "test",
                            ),
                            "^value^": "test",
                        ),
                        "st:issue86": (
                            "st1:issue86_1_1": "i86_1",
                            "st:issue86_1_2": "i86_2",
                        ),
                        "st:issue87": (
                            "st:issue87e1": "i87",
                            "st:choice12": "i87c12",
                        ),
                        "st:issue97": (
                            "st:i97list": NOTHING,
                        ),
                        "st:issue468": (
                            "st:issue468_1": (
                                "^attributes^": (
                                    "xsi:nil": "true",
                                ),
                            ),
                        ),
                        "st:issue560": (
                            "st:issue560_3": "A",
                            "st:issue560_2": "A",
                            "st:issue560_1": "A",
                        ),
                        "st:issue984": (
                            "st:i984_empty": NOTHING,
                        ),
                        "st:issue985": (
                            "^attributes^": (
                                "xsi:type": "st:i985_2",
                            ),
                            "st:i985_e1": "test",
                            "st:i985_e2": "test",
                        ),
                        #/*
                        "st:issue2190": (
                            "^attributes^": (
                                "attr": "val",
                            ),
                            "^value^": "string",
                        ),
                        #*/
                        "logo": "dGVzdA==",
                    ),
                ),
            ),
        );

        const Res_1 = (
            "SetInfoResult": "test",
            "issue663": (
                "i663list": (),
            ),
        );

        const SoapUiReq_1 = "<soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:sim=\"http://qore.org/simpletest\" xmlns:sim1=\"http://qore.org/simpletest1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">
   <soap:Header/>
   <soap:Body>
      <sim:setInfo>
         <sim:SetInfo infoType=\"test\" code=\"1\">
            <!--You may enter the following 2 items in any order-->
            <sim:name>QORE</sim:name>
            <sim:id>500</sim:id>
         </sim:SetInfo>
         <sim:Test info=\"test\">test</sim:Test>
         <sim:issue86>
            <sim1:issue86_1_1>i86_1</sim1:issue86_1_1>
            <sim:issue86_1_2>i86_2</sim:issue86_1_2>
         </sim:issue86>
         <sim:issue87>
            <sim:issue87e1>i87</sim:issue87e1>
            <!--You have a CHOICE of the next 2 items at this level-->
            <sim:choice12>i87c12</sim:choice12>
         </sim:issue87>
         <sim:issue97>
            <sim:i97list/>
         </sim:issue97>
         <sim:issue468>
            <sim:issue468_1 xsi:nil=\"true\"/>
         </sim:issue468>
         <sim:issue560>
            <sim:issue560_1>A</sim:issue560_1>
            <sim:issue560_2>A</sim:issue560_2>
            <sim:issue560_3>A</sim:issue560_3>
         </sim:issue560>
         <sim:issue984>
            <sim:i984_empty/>
         </sim:issue984>
         <sim:issue985 xsi:type=\"sim:i985_2\">
            <sim:i985_e1>test</sim:i985_e1>
            <sim:i985_e2>test</sim:i985_e2>
         </sim:issue985>
         <sim:issue2190 attr=\"val\">string</sim:issue2190>
         <logo>dGVzdA==</logo>
      </sim:setInfo>
   </soap:Body>
</soap:Envelope>";
#         <sim:issue2190 attr=\"attr\">string</sim:issue2190>

        const EmptyReq = (
            "soap:Envelope": SoapEnvAttr,
        );

        const EmptyRes = EmptyReq;

        const TestRes = (
            "soap:Envelope": SoapEnvAttr + (
                "soap:Body": (
                    "st:setInfoResponse": (
                        "st:SetInfoResult": "test",
                        "st:issue663": (
                            "st:i663list": NOTHING,
                        ),
                    ),
                ),
            ),
        );

        const RMap = (
            "body": "SetInfoResult",
            "issue663": "issue663",
        );

        const SoapEnvAttr1 = (
            "^attributes^": (
                "xmlns:soap": SOAP_11_ENV,
                "xmlns:tes": "http://example.com/test1/test1_ws",
            ),
        );

        # all values are strings here because we do raw XML parsing and not SOAP deserialization for the comparison
        # to avoid comparing values generated and parsed with the same code which would result in an identity test
        const Req1_1 = (
            "soap:Envelope": SoapEnvAttr1 + (
                "soap:Body": (
                    "tes:test1": (
                        "tes:arg1": "x",
                        "tes:arg2": "y",
                    ),
                ),
            ),
        );

        const SoapEnvAttr1Res = (
            "^attributes^": (
                "xmlns:soap": SOAP_11_ENV,
                "xmlns:tes": "http://example.com/test1/test1_ws",
                "xmlns:oth": "http://example.com/test1/other",
            ),
        );

        const Test1Res = (
            "soap:Envelope": SoapEnvAttr1Res + (
                "soap:Body": (
                    "tes:test1Response": (
                        "oth:Root": (
                            "Struct": (
                                "arg1": "1",
                                "arg2": "2",
                                "arg3": "3",
                                "arg4": "4",
                            ),
                            "res1": "a",
                            "res2": "b",
                        ),
                    ),
                ),
            ),
            );

        const Res1_1 = (
            "Root": (
                "Struct": (
                    "arg1": "1",
                    "arg2": "2",
                    "arg3": "3",
                    "arg4": "4",
                ),
                "res1": "a",
                "res2": "b",
            ),
        );

        const HeaderVal1 = (
            "tickerSymbol": "EET1",
            "docs": "DOCS-M2",
            "m3": ("SetInfo": ("name": "NAME-M3", "id": 457, "^attributes^": ("infoType": "ATW", "code": 58 ) )),
        );
        const HeaderValReq1 = (
            "soap:Envelope": SoapEnvAttr + (
                "soap:Header": (
                    "st:GetInfo": ("st:tickerSymbol": "EET1"),
                    "docs": (
                        "^attributes^": (
                            "xsi:type" : "xsd:string",
                        ),
                        "^value^": HeaderVal1.docs,
                    ),
                    "st:SetInfo": ("st:name": "NAME-M3", "st:id": "457", "^attributes^": ("infoType": "ATW", "code": "58" )),
                ),
            ),
        );
        const HeaderValBody = (
            "tickerSymbol": "EET1",
            "docs": "DOCS-M2",
        );
        const HeaderValBodyReq = (
            "soap:Envelope": SoapEnvAttr + (
                "soap:Header": (
                    "docs": (
                        "^attributes^": (
                            "xsi:type" : "xsd:string",
                        ),
                        "^value^": HeaderValBody.docs,
                    ),
                ),
                "soap:Body": (
                    "st:headerValBody": (
                        "st:GetInfo": ("st:tickerSymbol": "EET1"),
                    )
                ),
            ),
        );
        const OneElemBody = (
            "soap:Envelope": SoapEnvAttr + (
                "soap:Body":
                    ("info": "XYZ"),
            ),
        );
        const UrlReplVal1 = (
            "country": "CZ",
            "city": "Prague 2",
            "zip": 12000,
            );

        const MultiReq = (
            "OrderNumber": "TEST-123",
            "DealerCode": "DEALER-1",
            "IsUpdate": False,
            "IsCancelled": False,
            "IsGiftWrapped": False,
            "ShipToStore": True,
            "GiftWrapped": False,
            "DeliveryType": "TEST",
            "EmailAddress": "test@test.com",
            "ContactNumber": "+420 555 121 212",
            "Name": (
                "FirstName": "Testie",
                "LastName": "O'Test",
            ),
            "DeliveryAddress": (
                "AddressLine1": "Premyslovska 1939/28",
                "AddressLine2": "130 00",
                "AddressLine3": "Prague",
                "AddressLine4": "",
                "County": "Prague",
                "Country": "Czech Republic",
            ),
            "InvoiceAddress": (
                "AddressLine1": "Premyslovska 1939/28",
                "AddressLine2": "130 00",
                "AddressLine3": "Prague",
                "AddressLine4": "",
                "County": "Prague",
                "Country": "Czech Republic",
            ),
            "OrderGrossPrice": 149.99n,
            "OrderDiscount": 0.00n,
            "OrderNetPrice": 130.00n,
            "OrderItem": (
                "Price": 130.00n,
                "FTC": True,
            ),
            );

        const SoapEnvAttrMult = (
            "^attributes^": (
                "xmlns:soap": "http://www.w3.org/2003/05/soap-envelope",
                "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
                "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
                "xmlns:fu": "http://www.example.com/shop/fulfillment",
            ),
            );

        const Multi_Req_1 = (
            "soap:Envelope": SoapEnvAttrMult + (
                "soap:Body": (
                    "fu:OrderRequests": (
                        "fu:OrderRequest": (
                            "fu:OrderNumber": "TEST-123",
                            "fu:DealerCode": "DEALER-1",
                            "fu:IsUpdate": "false",
                            "fu:IsCancelled": "false",
                            "fu:IsGiftWrapped": "false",
                            "fu:ShipToStore": "true",
                            "fu:GiftWrapped": "false",
                            "fu:DeliveryType": "TEST",
                            "fu:EmailAddress": "test@test.com",
                            "fu:ContactNumber": "+420 555 121 212",
                            "fu:Name": (
                                "fu:FirstName": "Testie",
                                "fu:LastName": "O'Test",
                            ),
                            "fu:DeliveryAddress": (
                                "fu:AddressLine1": "Premyslovska 1939/28",
                                "fu:AddressLine2": "130 00",
                                "fu:AddressLine3": "Prague",
                                "fu:AddressLine4": NOTHING,
                                "fu:County": "Prague",
                                "fu:Country": "Czech Republic",
                            ),
                            "fu:InvoiceAddress": (
                                "fu:AddressLine1": "Premyslovska 1939/28",
                                "fu:AddressLine2": "130 00",
                                "fu:AddressLine3": "Prague",
                                "fu:AddressLine4": NOTHING,
                                "fu:County": "Prague",
                                "fu:Country": "Czech Republic",
                            ),
                            "fu:OrderGrossPrice": "149.99",
                            "fu:OrderDiscount": "0",
                            "fu:OrderNetPrice": "130",
                            "fu:OrderItem": (
                                "fu:Price": "130",
                                "fu:FTC": "true",
                            ),
                        ),
                    ),
                    "fu:swaBinary": NOTHING,
                ),
            ),
            );

        const Timestamp = now_us().toString();
        const TxId = get_random_string();

        const Multi_Res_1 = (
            "soap:Envelope": SoapEnvAttrMult + (
                "soap:Body": (
                    "fu:Receipt": (
                        "fu:OrderNumber": "16685422",
                        "fu:Timestamp": Timestamp,
                        "fu:ReceiptAck": (
                            "fu:OriginalTXID": TxId,
                            "fu:RequestStatus": "Success",
                        ),
                    ),
                ),
            ),
            );
    }

    constructor() : QUnit::Test("SoapTest", "1.0") {
        addTestCase("SoapTestCase", \soapTestCase());
        addTestCase("Test1", \test1());
        addTestCase("multi", \multiTest());
        set_return_value(main());
    }

    *hash parseMessage(hash msg, WSOperation op, bool request) {
        msg."content-type" = msg.hdr."Content-Type";
        *hash pdata = WSDLLib::parseSOAPMessage(msg);
        if (request) {
            return op.deserializeRequest(pdata);
        } else {
            return op.deserializeResponse(pdata);
        }
    }

    soapTestCase() {
        WebService ws(ReadOnlyFile::readTextFile(get_script_dir() + "/test.wsdl"));
        WSOperation op = ws.getOperation("setInfo");

        hash req = (
            "body": ("name": "QORE", "id": 500),
            "test": (
                "^attributes^": ("info": "test"),
                "^value^": "test",
            ),
            "issue86": (
                "issue86_1_1": "i86_1",
                "issue86_1_2": "i86_2",
            ),
            "issue87": (
                "issue87e1": "i87",
                "choice12": "i87c12",
            ),
            "issue97": (
                "i97list": NOTHING,
            ),
            "issue468": (
                "issue468_1": NOTHING,
            ),
            "issue560": (
                "issue560_1": "A",
                "issue560_2": "A",
                "issue560_3": "A",
            ),
            "issue984": (
                "i984_empty": NOTHING,
            ),
            "issue985": ws.getType("i985_2", ("i985_e1": "test", "i985_e2": "test",)),
            "issue2190": ("^attributes^": ("attr": "val"), "^value^": "string"),
            "logo": binary("test"),
            );

        # negative test w/o attributes
        assertThrows("SOAP-SERIALIZATION-ERROR", \op.serializeRequest(), req, "attr-ser-neg");

        req.body."^attributes^" = (
            "infoType": "test",
            "code": 1,
            );

        hash h = op.serializeRequest(req, NOTHING, NOTHING, NOTHING, XGF_ADD_FORMATTING, "TEST");
        assertEq("TEST", h.hdr.SOAPAction);
        hash xh = parse_xml(h.body);
        compareSoapMsgs("attr-ser", Req_1, xh);

        h = op.deserializeRequest(xh);
        assertEq(NOTHING, h.hdr.SOAPAction);

        hash req_r = req + (
            "issue985": (
                "i985_e1": "test", "i985_e2": "test",
            ),
        );

        assertEq(req_r, h, "attr-deser-our");

        # do negative tests to ensure that namespace handling is correct in our test code
        {
            NsMap nh = SoapTest::getNamespaceMap(Req_1);
            string ek = SoapTest::getKey(nh.se, "Envelope");
            string bk = SoapTest::getKey(nh.se, "Body");
            string pfx = nh.umap."http://qore.org/simpletest";
            string sik1 = SoapTest::getKey(pfx, "setInfo");
            string sik2 = SoapTest::getKey(pfx, "SetInfo");

            hash r1 = Req_1;

            # rename key with an undefined namespace
            r1{ek}{bk}{sik1}."xxx:SetInfo" = remove r1{ek}{bk}{sik1}{sik2};
            assertThrows("SOAP-NAMESPACE-ERROR", \compareSoapMsgs(), ("attr-ser", r1, xh), "attr-ser-neg-1");

            # rename key with a defined but incorrect namespace
            string sik = sprintf("%s:SetInfo", nh.umap."http://www.w3.org/2003/05/soap-envelope");
            r1{ek}{bk}{sik1}{sik} = remove r1{ek}{bk}{sik1}."xxx:SetInfo";
            assertThrows("TEST-EXCEPTION", \compareSoapMsgs(), ("attr-ser", r1, xh), "attr-ser-neg-2");
        }

        {
            NsMap nh = SoapTest::getNamespaceMap(xh);
            string ek = SoapTest::getKey(nh.se, "Envelope");
            string bk = SoapTest::getKey(nh.se, "Body");
            string pfx = nh.umap."http://qore.org/simpletest";
            string sik1 = SoapTest::getKey(pfx, "setInfo");
            string sik2 = SoapTest::getKey(pfx, "SetInfo");

            # rename key with an undefined namespace
            xh{ek}{bk}{sik1}."xxx:SetInfo" = remove xh{ek}{bk}{sik1}{sik2};
            assertThrows("TEST-EXCEPTION", \compareSoapMsgs(), ("attr-ser", Req_1, xh), "attr-ser-neg-3");

            # rename key with a defined but incorrect namespace
            pfx = nh.umap."http://www.w3.org/2003/05/soap-envelope";
            xh{ek}{bk}{sik1}{pfx} = remove xh{ek}{bk}{sik1}."xxx:SetInfo";
            assertThrows("TEST-EXCEPTION", \compareSoapMsgs(), ("attr-ser", Req_1, xh), "attr-ser-neg-4");
        }

        h = parse_xml(SoapUiReq_1);
        h = op.deserializeRequest(h);

        assertEq(req_r, h, "attr-deser-soapui");

        h = op.serializeResponse(Res_1);
        xh = parse_xml(h.body);
        compareSoapMsgs("output", TestRes, xh);
        *hash eh = op.deserializeResponse(xh);
        # map message part names to element names
        eh = map {RMap{$1.key}: $1.value}, eh.pairIterator();
        if (!exists eh.issue663.i663list)
            eh.issue663.i663list = ();
        assertEq(Res_1, eh);

        op = ws.getOperation("noInput");
        h = op.serializeRequest();
        xh = parse_xml(h.body);
        compareSoapMsgs("no-input", EmptyReq, xh);
        eh = op.deserializeRequest(h);
        assertEq(NOTHING, eh);

        op = ws.getOperation("noOutput");
        h = op.serializeResponse();
        xh = parse_xml(h.body);
        compareSoapMsgs("no-output", EmptyRes, xh);
        eh = op.deserializeResponse(h);
        assertEq(NOTHING, eh);

        op = ws.getOperation("headerVal");
        h = op.serializeRequest(NOTHING, HeaderVal1);
        xh = parse_xml(h.body);
        compareSoapMsgs("header-val", HeaderValReq1, xh);
        *hash h2 = op.deserializeRequest(xh);

        hash headerDeser = ("m1": ("body": ("tickerSymbol" : "EET1")), "m2": ("docs": "DOCS-M2"), "m3": ("body": ("name": "NAME-M3", "id": 457, "^attributes^": ("infoType": "ATW", "code": 58))));
        assertEq(headerDeser, h2);

        op = ws.getOperation("headerVal-doc");
        h = op.serializeRequest(NOTHING, HeaderVal1);
        xh = parse_xml(h.body);
        compareSoapMsgs("header-val", HeaderValReq1, xh);

        # test if the body arguments can be used to serialize the headers
        op = ws.getOperation("headerVal-doc");
        h = op.serializeRequest(HeaderVal1, NOTHING, NOTHING, NOTHING, XGF_ADD_FORMATTING);
        xh = parse_xml(h.body);
        compareSoapMsgs("header-val", HeaderValReq1, xh);

        assertThrows("SOAP-SERIALIZATION-ERROR", \op.serializeRequest(), (HeaderVal1, ("unknown": "dummy") ) );
        assertThrows("SOAP-SERIALIZATION-ERROR", \op.serializeRequest(), (HeaderVal1 + ("unknown": "dummy") ) );

        h2 = op.deserializeRequest(xh);
        assertEq(headerDeser, h2);

        op = ws.getOperation("headerValBody");
        h = op.serializeRequest(HeaderValBody);
        xh = parse_xml(h.body);
        compareSoapMsgs("header-valBody", HeaderValBodyReq, xh);

        h2 = op.deserializeRequest(xh);
        headerDeser = ("tickerSymbol": "EET1", "m2": ("docs": "DOCS-M2"));
        assertEq(headerDeser, h2);

        op = ws.getOperation("oneElem");
        h = op.serializeRequest(("info": "XYZ"));
        xh = parse_xml(h.body);
        compareSoapMsgs("one-Part1", OneElemBody, xh);

        h = op.serializeRequest("XYZ");
        xh = parse_xml(h.body);
        compareSoapMsgs("one-Part2", OneElemBody, xh);

        h = op.serializeRequest(("m6": ("info": "XYZ")));
        xh = parse_xml(h.body);
        compareSoapMsgs("one-Part3", OneElemBody, xh);

        op = ws.getPortTypeOperation("pt2", "urlRepl");
        h = op.serializeRequest(UrlReplVal1);
        assertEq("get/CZ/12000-Prague%202", h.path);
        assertEq("GET", h.method);

        op = ws.getPortTypeOperation("pt2", "urlEncoded1");
        h = op.serializeRequest(UrlReplVal1);
        assertEq("get?country=CZ&city=Prague%202&zip=12000", h.path);
        assertEq("GET", h.method);
        assertFalse(exists h.hdr."Content-Type");
        assertThrows("SOAP-DESERIALIZATION-ERROR", \parseMessage(), (h, op, True));

        op = ws.getBindingOperation("b2", "urlEncoded2");
        h = op.serializeRequest(UrlReplVal1);
        assertEq("get?test&country=CZ&city=Prague%202&zip=12000", h.path);
        assertEq("GET", h.method);
        h = op.deserializeRequestPath(h.path, "b2");
        assertEq(UrlReplVal1, h);

        op = ws.getBindingOperation("b2", "postForm");
        h = op.serializeRequest(UrlReplVal1);
        assertEq("country=CZ&city=Prague%202&zip=12000", h.body);
        assertEq("POST", h.method);

        h2 = parseMessage(h, op, True);
        assertEq(UrlReplVal1, h2, h.path);

        op = ws.getPortTypeOperation("pt2", "postText");
        h = op.serializeRequest(("info": "important info &"));
        assertEq("important info &", h.body);
        assertTrue(h.hdr."Content-Type".regex("^text/"), "Content type");
        assertEq("POST", h.method);

        h2 = parseMessage(h, op, True);
        assertEq("important info &", get_xml_value(h2.info));
        assertEq("text/plain", h2.info."^attributes^"."^content-type^");

        op = ws.getPortTypeOperation("pt2", "postImg");
        h = op.serializeRequest(("img": <ABCDEF>));
        assertEq(h.hdr."Content-Type", "image/png");
        assertEq(<ABCDEF>, h.body);
        assertEq("POST", h.method);

        h2 = parseMessage(h, op, True);
        assertEq(<ABCDEF>, get_xml_value(h2.img));
        assertEq(h2.img."^attributes^"."^content-type^", "image/png");

        op = ws.getPortTypeOperation("pt2", "postImg");
        assertThrows("SOAP-MESSAGE-ERROR", \op.serializeRequest(), ("img": ("^value^": "xxx", "^attributes^": ("^content-type^": "text/plain"))), "post img wrong content type");

        op = ws.getPortTypeOperation("pt2", "postImg2");
        assertThrows("SOAP-SERIALIZATION-ERROR", \op.serializeRequest(), ("img": <ABCDEF>), "post img no content type");

        op = ws.getPortTypeOperation("pt2", "postImg2");
        h = op.serializeRequest(("img": ("^value^": <ABCDEF>, "^attributes^": ("^content-type^": "image/jpeg"))));
        assertEq("image/jpeg", h.hdr."Content-Type");
        assertEq(<ABCDEF>, h.body);

        op = ws.getPortTypeOperation("pt2", "postImg3");
        h = op.serializeRequest(("img": ("^value^": <ABCDEF>, "^attributes^": ("^content-type^": "image/jpeg"))));
        assertEq("image/jpeg", h.hdr."Content-Type");
        assertEq(<ABCDEF>, h.body);

        h2 = parseMessage(h, op, True);
        assertEq(<ABCDEF>, get_xml_value(h2.img));
        assertEq("image/jpeg", h2.img."^attributes^"."^content-type^");

        op = ws.getPortTypeOperation("pt2", "postImg3");
        assertThrows("SOAP-SERIALIZATION-ERROR", \op.serializeRequest(), ("img": <ABCDEF>), "post img no content type");

        op = ws.getPortTypeOperation("pt2", "postImg3");
        assertThrows("SOAP-MESSAGE-ERROR", \op.serializeRequest(), ("img": ("^value^": "xxx", "^attributes^": ("^content-type^": "text/plain"))), "post img wrong content type");

        op = ws.getPortTypeOperation("pt2", "postData");
        h = op.serializeRequest(("payload": ("^value^": "012", "^attributes^": ("^content-type^": "application/x-data"))));
        assertTrue(h.hdr."Content-Type".regex("^application/x-data"), "Content type");
        assertEq(<303132>, h.body);

        op = ws.getPortTypeOperation("pt2", "postData");
        assertThrows("SOAP-SERIALIZATION-ERROR", \op.serializeRequest(), ("payload": "xxx"), "post img no content type");

        op = ws.getPortTypeOperation("pt2", "getMimeXml");
        h = op.deserializeResponse(("string": "xxx"));
        assertEq("xxx", h.STR, "deserialize mimeXml");

        h = op.serializeResponse(h);
        assertTrue(h.hdr."Content-Type".regex("^text/xml"), "Content type");
        assertTrue(h.body.regex("^\\<\\?xml version.*\n.*string.*xxx"), "serialize mimexml");
    }

    test1() {
        WebService ws(ReadOnlyFile::readTextFile(get_script_dir() + "/test1.wsdl"));

        WSOperation op = ws.getOperation("test1");

        hash req = (
            "arg1": "x",
            "arg2": "y",
            );

        hash h = op.serializeRequest(req, NOTHING, NOTHING, NOTHING, XGF_ADD_FORMATTING);
        hash xh = parse_xml(h.body);
        #printf("xh: %N\n", xh);
        #printf("r1: %N\n", Req1_1);
        compareSoapMsgs("attr-ser", Req1_1, xh);

        h = op.serializeResponse(Res1_1);
        xh = parse_xml(h.body);
        compareSoapMsgs("output", Test1Res, xh);
        *hash eh = op.deserializeResponse(xh);
        assertEq(Res1_1, eh, "deserialize response");
    }

    multiTest() {
        WebService ws(ReadOnlyFile::readTextFile(get_script_dir() + "/multi-soap.wsdl"));
        WSOperation op = ws.getOperation("Send");

        hash req = (
            "OrderRequests": (
                "OrderRequest": MultiReq,
            ),
            "swaBinary": NOTHING,
            );
        hash h = op.serializeRequest(req);
        assertEq(NOTHING, h.hdr.SOAPAction);
        hash xh = parse_xml(h.body);
        compareSoapMsgs("multi-1", Multi_Req_1, xh);

        h = op.deserializeRequest(xh);
        # FIXME: check that req == h (must process req)

        hash res = (
            "OrderNumber": "16685422",
            "Timestamp": Timestamp,
            "ReceiptAck": (
                "OriginalTXID": TxId,
                "RequestStatus": "Success",
            ),
            );
        h = op.serializeResponse(res);
        #printf("h: %N\n", h);
        xh = parse_xml(h.body);
        #printf("%N\n", xh);
        compareSoapMsgs("multi-2", Multi_Res_1, xh);

        h = op.deserializeResponse(xh);
        # FIXME: check that res == h (must process res)
    }

    compareSoapMsgs(string assert, hash h1, hash h2) {
        try {
            # get namespace hashes and soap envelope prefix
            NsMap nh1 = SoapTest::getNamespaceMap(h1);
            NsMap nh2 = SoapTest::getNamespaceMap(h2);

            # compare soap version in envelope
            assertEq(nh1.getSoapUri(), nh2.getSoapUri());

            *hash hdr1 = SoapTest::getValue(h1, nh1.se, "Envelope", "Header");
            *hash hdr2 = SoapTest::getValue(h2, nh2.se, "Envelope", "Header");
            #printf("COMPARE\n%N\n%N\n%N\n%N\n\n", h1, h2, hdr1, hdr2);
            compareSoapValue(assert, "Envelope.Header", hdr1, hdr2, nh1, nh2);

            *hash b1 = SoapTest::getValue(h1, nh1.se, "Envelope", "Body");
            *hash b2 = SoapTest::getValue(h2, nh2.se, "Envelope", "Body");

            compareSoapValue(assert, "Envelope.Body", b1, b2, nh1, nh2);
        } catch (hash ex) {
            # to provide real info what failed
            list stack = get_all_thread_call_stacks(){gettid()};
            int i = 1;
            while (exists stack[i]) {
                if (stack[i].file == stack[0].file) {
                    #printf("test: %N\n%N\nExpected: %N\nActual: %N\n", stack[i], ex, h1, h2);
                    break;
                }
                i++;
            }
            rethrow;
        }
    }

    compareSoapValue(string assert, string loc, any v1, any v2, NsMap nh1, NsMap nh2) {
        if (v1.typeCode() == NT_STRING) {
            # check if value is a namespace-prefixed string and processing accordingly if so
            if ((*string nv1, *string kv1) = (v1 =~ x/^(\w+):(\w+)$/)) {
                *string uri1 = nh1.pmap{nv1};
                if (!exists uri1)
                    throw "SOAP-NAMESPACE-ERROR", sprintf("%s (%s) namespace prefix in %y in the expected value is not defined", assert, loc, v1);
                *string nv2 = nh2.umap{uri1};
                if (!exists nv2)
                    throw "SOAP-NAMESPACE-ERROR", sprintf("%s (%s) expected namespace URI %y in value %y is not defined in the given value", assert, loc, uri1, v1);
                # generate expected value
                string str = sprintf("%s:%s", nv2, kv1);
                assertEq(str, v2);
            }
            else
                assertEq(v1, v2, sprintf("%s (%s) values match", assert, loc));
            return;
        }

        if (v1.typeCode() != NT_HASH) {
            assertEq(v1, v2, sprintf("%s (%s)", assert, loc));
            return;
        }

        # check attributes
        foreach hash h in (v2."^attributes^".pairIterator()) {
            (*string nsp1, *string key) = (h.key =~ x/^(\w+):(\w+)$/);
            if (nsp1 && key) {
                *string uri2 = nh2.pmap{nsp1};
                if (!uri2)
                    throw "SOAP-NAMESPACE-ERROR", sprintf("%s (%s) namespace prefix in %y in the generated value is not defined", assert, loc, h.key);

                # check type value
                if (key == "type" && uri2 == XSI_NS && h.value =~ / /)
                    throw "SOAP-TYPE-ERROR", sprintf("%s (%s) xsi:type=%y is invalid", assert, loc, h.value);
            }
        }

        foreach string rkey in (v1.keyIterator()) {
            (*string nsp1, *string key) = (rkey =~ x/^(\w+):(\w+)$/);
            if (!nsp1) {
                assertTrue(v2.hasKey(rkey), sprintf("%s (%s) has element %y", assert, loc, rkey));
                compareSoapValue(assert, sprintf("%s.%s", loc, rkey), v1{rkey}, v2{rkey}, nh1, nh2);
                remove v2{rkey};
                continue;
            }
            *string uri1 = nh1.pmap{nsp1};
            if (!exists uri1)
                throw "SOAP-NAMESPACE-ERROR", sprintf("%s (%s) namespace prefix in %y in the expected value is not defined", assert, loc, rkey);
            *string nsp2 = nh2.umap{uri1};
            if (!exists nsp2)
                throw "SOAP-NAMESPACE-ERROR", sprintf("%s (%s) expected namespace URI %y in key %y is not defined in the given value", assert, loc, uri1, rkey);
            string k2 = SoapTest::getKey(nsp2, key);
            assertTrue(v2.hasKey(k2), sprintf("expected value %s has key %y", loc, k2));
            compareSoapValue(assert, sprintf("%s.%s", loc, key), v1{rkey}, v2{k2}, nh1, nh2);
            remove v2{k2};
        }

        assertEq((), v2.keys(), sprintf("%s all keys matched", loc));
    }

    static any getValue(hash h, string nsp, string key) {
        any rv = h{SoapTest::getKey(nsp, key)};
        map rv = rv{SoapTest::getKey(nsp, $1)}, argv;
        return rv;
    }

    static string getKey(string nsp, string key) {
        return sprintf("%s:%s", nsp, key);
    }

    static NsMap getNamespaceMap(hash h) {
        string fk = h.firstKey();
        h = h{fk};

        NsMap rv();
        foreach hash ah in (h."^attributes^".pairIterator()) {
            (*string xmlns, *string prefix) = (ah.key =~ x/^(\w+):(\w+)$/);
            if (xmlns != "xmlns")
                continue;
            rv.set(prefix, ah.value);
        }
        if (!rv.se)
            throw "SOAP-ENVELOPE-ERROR", sprintf("no SOAP envelope namespace provided in SOAP envelope attributes: %y", h."^attributes^");

        if (fk != sprintf("%s:Envelope", rv.se))
            throw "SOAP-ENVELOPE-ERROR", sprintf("SOAP envelope key %y is not in the SOAP envelope namespace: %y", fk, rv.se);

        return rv;
    }
}
