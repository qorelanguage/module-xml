#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

# make sure we have the right version of qore
%requires qore >= 0.8.12

%new-style
%require-types
%strict-args
%enable-all-warnings
%no-child-restrictions
%require-our

# test deprecated functions as well
%disable-warning deprecated

%requires QUnit
%requires HttpServer
%requires ../qlib/WSDL.qm
%requires ../qlib/SoapHandler.qm
%requires ../qlib/SoapClient.qm

%requires Util
%requires xml
%requires HttpServerUtil >= 0.3.11

const DefaultPort = 0;

%exec-class SoapClientTest

const ResponseBody = ("result": 99.9);

class TestSoapHandler inherits SoapHandler {
    public {
        list msglogs;
    }
    constructor(HttpServer::AbstractAuthenticator auth, *code n_getLogMessage, bool dbg = False): SoapHandler(auth, n_getLogMessage, dbg) {}

    nothing msglog(hash cx, hash msg) {
        push msglogs, msg;
    }
}

class TestSoapServer inherits HttpServer {

    public {
        TestSoapHandler soap;
    }

    private {
        int verbose;
    }

    constructor(WebService ws, int port, int verbose = 0) : HttpServer(\self.log(), \self.errlog(), verbose > 2) {
        self.verbose = verbose;

        # setup SOAP handler
        soap = new TestSoapHandler(new PermissiveAuthenticator(), NOTHING, verbose > 2);
        setDefaultHandler("soap", soap);

        # setup operation handler
        soap.addMethod(ws, ws.getOperation("getInfo"), \getInfo());

        addListener(port);
    }

    hash getInfo(hash cx, hash h) {
        if (h.tickerSymbol == "ERR")
            throw "ERR", "ERR";
        return (
            "body": ResponseBody,
            "docs": h.tickerSymbol,
            "logo": binary(cx.http_header.soapaction),
            );
    }

    errlog(string fmt) {
        if (verbose > 2)
            vprintf(fmt + "\n", argv);
    }

    log(string fmt) {
        if (verbose > 2)
            vprintf(fmt + "\n", argv);
    }

}

class TestSoapClient inherits SoapClient {
    public {
        list msglogs;
    }
    constructor(hash h): SoapClient(h) {}
    nothing msglog(hash msg) {
        push msglogs, msg;
    }
}

class SoapClientTest inherits QUnit::Test {
    public {
        TestSoapServer server;
    }

    private {
        const WsdlUrl = "file://" + get_script_dir() + "/test.wsdl";

        #! command-line options
        const MyOpts = Opts + (
            "port": "p,port=i",
            "verbose": "verbose=i",  # do not add "v" because Jenkins raises short option requires argument
            );

        const OptionColumn = 25;
        int serverPort;
    }

    constructor() : QUnit::Test("SoapClientTest", "1.0", \ARGV, MyOpts) {
        WebService ws(WSDLLib::getFileFromURL(WsdlUrl));

        # start SOAP server server
        server = new TestSoapServer(ws, m_options.port ?? DefaultPort, m_options.verbose);
        on_exit server.stop();
        serverPort = server.getListenerInfo(0).port;

        # add test cases
        addTestCase("SoapClientTest", \soapClientTest());
        # execute tests
        set_return_value(main());
    }

    soapClientTest() {
        string url = sprintf("http://%s:%d", gethostname(), serverPort);
        #printf("url: %y\n", url);
        TestSoapClient sc(("wsdl": WsdlUrl, "url": url));

        hash h = sc.callOperation("getInfo", ("GetInfo": ("tickerSymbol": "ABC")), ("soapaction": ""));
        assertEq(99.9, h.body.result);
        assertEq("ABC", h.docs);
        assertEq(binary(), h.logo);
        assertEq("request", sc.msglogs[0].reason);
        assertEq(True, sc.msglogs[0].body =~ /GetInfo/);
        assertEq("response", sc.msglogs[1].reason);
        assertEq(True, sc.msglogs[1].body =~ /GetInfoResult/);
        assertEq(server.soap.msglogs[0].('reason', 'code', 'body'), sc.msglogs[0].('reason', 'code', 'body'));
        assertEq(server.soap.msglogs[1].('reason', 'code', 'body'), sc.msglogs[1].('reason', 'code', 'body'));

        sc.msglogs = ();
        server.soap.msglogs = ();

        h = sc.callOperation("getInfo", ("GetInfo": ("tickerSymbol": "QOR")), ("soapaction": "TestAction"));
        assertEq(99.9, h.body.result);
        assertEq("QOR", h.docs);
        assertEq(binary("TestAction"), h.logo);

        sc.msglogs = ();
        server.soap.msglogs = ();

        assertThrows("HTTP-CLIENT-RECEIVE-ERROR", \sc.callOperation(), ("getInfo", ("GetInfo": ("tickerSymbol": "ERR"))));
        assertEq("error", sc.msglogs[1].reason);
        assertEq(500, sc.msglogs[1].code);
        assertEq(True, sc.msglogs[1].body =~ /Fault/);
        assertEq(server.soap.msglogs[0].('reason', 'code', 'body'), sc.msglogs[0].('reason', 'code', 'body'));
        assertEq(server.soap.msglogs[1].('reason', 'code', 'body'), sc.msglogs[1].('reason', 'code', 'body'));

        assertThrows("WSDL-OPERATION-ERROR", \sc.callOperation(), "xxx");

        WebService ws(WSDLLib::getWSDL(WsdlUrl));
        sc = new TestSoapClient(("wsdl": ws));
        assertEq(True, sc instanceof SoapClient, "issue 1424");
    }
}

