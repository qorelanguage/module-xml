#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

# make sure we have the right version of qore
%requires qore >= 0.8.12

%new-style
%require-types
%strict-args
%enable-all-warnings
%no-child-restrictions
%require-our

# test deprecated functions as well
%disable-warning deprecated

%requires QUnit
%requires HttpServer
%requires ../qlib/WSDL.qm
%requires ../qlib/SoapHandler.qm
%requires ../qlib/SoapClient.qm

%requires Util
%requires xml
%requires HttpServerUtil >= 0.3.11

const DefaultPort = 0;

%exec-class SoapClientTest

const ResponseBody = ("result": 99.9);

class TestSoapHandler inherits SoapHandler {
    public {
        list msglogs;
    }
    constructor(HttpServer::AbstractAuthenticator auth, *code n_getLogMessage, bool dbg = False): SoapHandler(auth, n_getLogMessage, dbg) {}

    nothing msglog(hash cx, hash msg) {
        push msglogs, msg;
    }
}

class TestSoapServer inherits HttpServer {

    public {
        TestSoapHandler soap;
    }

    private {
        int verbose;
    }

    constructor(WebService ws, int port, int verbose = 0) : HttpServer(\self.log(), \self.errlog(), verbose > 2) {
        self.verbose = verbose;

        # setup SOAP handler
        soap = new TestSoapHandler(new PermissiveAuthenticator(), NOTHING, verbose > 2);
        setHandler("soap", "SOAP", MimeTypeSoapXml, soap, "soapaction", False);

        # setup operation handler
        soap.addMethod(ws, ws.getOperation("getInfo"), \getInfo(),
                NOTHING, NOTHING, NOTHING, "InfoService");
        soap.addMethod(ws, ws.getOperation("urlRepl"), \urlRepl(),
                NOTHING, NOTHING, NOTHING, /*path*/NOTHING, NOTHING, NOTHING, "b2");
        addListener(port);
    }

    hash getInfo(hash cx, hash h) {
        if (h.tickerSymbol == "ERR")
            throw "ERR", "ERR";
        return (
            "body": ResponseBody,
            "docs": h.tickerSymbol,
            "logo": binary(cx.http_header.soapaction),
            );
    }

    hash urlRepl(hash cx, hash h) {
printf("URLREPL\n");
    }

    errlog(string fmt) {
        if (verbose > 2)
            vprintf(fmt + "\n", argv);
    }

    log(string fmt) {
        if (verbose > 2)
            vprintf(fmt + "\n", argv);
    }

}

class TestSoapClient inherits SoapClient {
    public {
        list msglogs;
    }
    constructor(hash h): SoapClient(h) {}
    nothing msglog(hash msg) {
        push msglogs, msg;
    }
}

class SoapClientTest inherits QUnit::Test {
    public {
        TestSoapServer server;
    }

    private {
        const WsdlUrl = "file://" + normalize_dir(get_script_dir()) + "/test.wsdl";

        #! command-line options
        const MyOpts = Opts + (
            "port": "p,port=i",
            #"verbose": "verbose=i",  # already in Opts
            "host": "host=s",
        );

        const OptionColumn = 25;
        string url;
        int serverPort;
    }

    constructor() : QUnit::Test("SoapClientTest", "1.0", \ARGV, MyOpts) {
        WebService ws(WSDLLib::getFileFromURL(WsdlUrl));

        # start SOAP server server
        server = new TestSoapServer(ws, m_options.port ?? DefaultPort, m_options.verbose);
        on_exit server.stop();
        serverPort = server.getListenerInfo(0).port;
        # when dual IPv4/IPv6 stack then may resolve gethostname() with unsupposed IP address where server is not listening
        url = sprintf("http://%s:%d", m_options.host ? m_options.host : gethostname(), serverPort);

        # add test cases
        addTestCase("SoapClientTest", \soapClientTest());
        addTestCase("HttpGetClientTest", \httpGetClientTest());
        addTestCase("SoapConnectionTest", \soapConnectionTest());

        # execute tests
        set_return_value(main());
    }

    soapClientTest() {
        #printf("url: %y\n", url);
        TestSoapClient sc(("wsdl": WsdlUrl, "port": "SoapPort", "url": url));

        server.soap.msglogs = ();

        hash h = sc.callOperation("getInfo", ("GetInfo": ("tickerSymbol": "ABC")), ("soapaction": ""));
        assertEq(99.9, h.body.result);
        assertEq("ABC", h.docs);
        assertEq(binary(), h.logo);
        assertEq("request", sc.msglogs[0].reason);
        assertEq(True, sc.msglogs[0].body =~ /GetInfo/);
        assertEq("response", sc.msglogs[1].reason);
        assertEq(True, sc.msglogs[1].body =~ /GetInfoResult/);
        assertEq(server.soap.msglogs[0].('reason', 'code', 'body'), sc.msglogs[0].('reason', 'code', 'body'));
        assertEq(server.soap.msglogs[1].('reason', 'code', 'body'), sc.msglogs[1].('reason', 'code', 'body'));

        sc.msglogs = ();
        server.soap.msglogs = ();

        h = sc.callOperation("getInfo", ("GetInfo": ("tickerSymbol": "QOR")), ("soapaction": "TestAction"));
        assertEq(99.9, h.body.result);
        assertEq("QOR", h.docs);
        assertEq(binary("TestAction"), h.logo);

        sc.msglogs = ();
        server.soap.msglogs = ();

        assertThrows("HTTP-CLIENT-RECEIVE-ERROR", \sc.callOperation(), ("getInfo", ("GetInfo": ("tickerSymbol": "ERR"))));
        assertEq("error", sc.msglogs[1].reason);
        assertEq(500, sc.msglogs[1].code);
        assertEq(True, sc.msglogs[1].body =~ /Fault/);
        assertEq(server.soap.msglogs[0].('reason', 'code', 'body'), sc.msglogs[0].('reason', 'code', 'body'));
        assertEq(server.soap.msglogs[1].('reason', 'code', 'body'), sc.msglogs[1].('reason', 'code', 'body'));

        assertThrows("WSDL-OPERATION-ERROR", \sc.callOperation(), "xxx");

        WebService ws(WSDLLib::getWSDL(WsdlUrl));
        sc = new TestSoapClient(("wsdl": ws, "port": "SoapPort"));
        assertEq(True, sc instanceof SoapClient, "issue 1424");

        HTTPClient hc(("url": url));
        hash info;
        *string str = hc.get("/SOAP/InfoService", NOTHING, \info);
        assertEq(True, str && str =~ /http:\/\/[^\/]*\/SOAP\/InfoService/, "issue 1631");
    }

    httpGetClientTest() {
        #printf("url: %y\n", url);
        TestSoapClient sc(("wsdl": WsdlUrl, "port": "HttpGetPort", "url": url));

        server.soap.msglogs = ();
        hash h;
        try {
        h = sc.callOperation("urlRepl", ("country": "CZ", "city": "Prague 2", "zip": 12000), ("soapaction": ""));
        } catch (ex) {
            printf("Exception: %N\n\n", ex);
        }

printf("client: %N\n", sc.msglogs);
printf("server: %N\n", server.soap.msglogs);
printf("result: %N\n", h);
        assertEq("get/CZ/12000-Prague%202", sc.msglogs[0].path);

        sc.msglogs = ();
        server.soap.msglogs = ();

    }

    soapConnectionTest() {
        string conn_url = WsdlUrl;
        conn_url =~ s/^file/soap/;

        printf("conn_url: %y\n", conn_url);

        SoapConnection conn("test", "test", conn_url, False, ("target_url": url, "port": "SoapPort"), parse_url(conn_url));
        SoapClient sc = conn.get();
        hash h = sc.callOperation("getInfo", ("GetInfo": ("tickerSymbol": "ABC")), ("soapaction": ""));
        assertEq(99.9, h.body.result);
        assertEq("ABC", h.docs);
        assertEq(binary(), h.logo);
    }
}
