# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file SoapClient.qm SOAP Client module implementation based on the WSDL classes

/*  SoapClient.qm Copyright (C) 2012 - 2014 David Nichols

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# make sure we have the required qore version
%requires qore >= 0.8.8

# requires XML functionality
%requires xml

# requires the WSDL module
%requires WSDL

# need mime definitions
%requires Mime >= 1.1

module SoapClient {
    version = "0.2.4";
    desc = "SoapClient module";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2014-04-22 v0.2.4: David Nichols <david@qore.org>
    *  + handle SOAP fault messages returned with 500-series error codes as Fault messages

    * 2014-03-14 v0.2.4: David Nichols <david@qore.org>
    *  + added optional logging closures, added SOAP headers to info hash when available

    * 2014-03-04 v0.2.4: David Nichols <david@qore.org>
    *  + fixed URI request path, fixed agent string

    * 2012-05-31 v0.2.3: David Nichols <david@qore.org>
    *  + updated to a user module
*/

/** @mainpage SoapClient Module
    
    @section soapclientintro Introduction to the SoapClient Module

    The SoapClient module implements a minimal SOAP client using WSDL, XSD, SOAP support implemented in the WSDL module.

    Create outgoing request messages by setting up a Qore data structure corresponding to the SOAP message.  Exceptions will be thrown if either the outgoing or the response message do not corespond to the WSDL.   The exceptions should be fairly verbose to allow you to quickly correct any mistakes.

    Currently the WSDL implementation is fairly basic so any messages using unimplemented features of SOAP or XSD will fail.

    @section Example

    Here is an example of how to use this module:
    @code
%requires SoapClient
my SoapClient $sc = new SoapClient(("wsdl" : "http://soap.server.org:8080/my-service?wsdl"));
my hash $msg = getMessage();
my any $result = $sc.call("SubmitDocument", $msg);
    @endcode

    The SoapClient::constructor() takes named arguments in the form of a hash; valid arguments are:
    - required keys: one of:
      - \c "wsdl" or \c "wsdl_file": a string defining the WSDL or the URL of the WSDL
    - optional keys:
      - \c "service": the name of the "portType" to use (if more than 1 portType is defined in the WSDL then this key is mandatory
      - \c "url": to override the URL defined in the WSDL
      - \c "headers": to override any HTTP headers sent in outgoing messages
      - \c "event_queue": to set an I/O event queue on the HTTPClient
      - \c "log": a @ref closure "closure" or @ref call_reference "call reference" taking a single string argument for informational logging
      - \c "dbglog": a @ref closure "closure" or @ref call_reference "call reference" taking a single string argument for verbose technical debugging logging
    
    Also the following keys can be set to set HTTP options:
    - \c "connect_timeout"
    - \c "http_version"
    - \c "max_redirects"
    - \c "proxy"
    - \c "timeout"
*/

#! main SoapClient namespace
public namespace SoapClient {
    #! SOAP client class implementation, publically inherits qore's HTTPClient class
    public class SoapClient inherits HTTPClient {
        #! version of the implementation of this class
        const Version = "0.2.4";

        #! default HTTP headers
        const Headers = ("Accept": (MimeTypeSoapXml + "," + MimeTypeXml + "," + MimeTypeXmlApp), "User-Agent": ("Qore-Soap-Client/" + SoapClient::Version));

        #! option keys passed to the HTTPClient constructor
        const HTTPOptions = ( "connect_timeout", "http_version", "max_redirects", "proxy", "timeout" );

        #! @cond nodoc
        private {
            WSDL::WebService $.wsdl;  # web service definition
            string $.portType;   # service name

            *code $.log;
            *code $.dbglog;
        }
        #! @endcond

        public {
            #! target URL
            string $.url;
            #! HTTP headers to use
            hash $.headers = Headers;
        }

        #! creates the object based on a %WSDL which is parsed to a @ref WSDL::WebService "WebService" object which provides the basis for all communication with this object
        /** one of either the \c wsdl or \c wsdl_file keys is required in the hash given to the constructor or an exception will be thrown
            @param h valid option keys:
            - \c wsdl: the URL of the web service or a @ref WSDL::WebService "WebService" object itself
            - \c wsdl_file: a path to use to load the %WSDL and create the @ref WSDL::WebService "WebService" object
            - \c url: override the target URL given in the %WSDL
            - [\c portType]: in case multiple portType entries are found in the WSDL, give the one to be used here
            - [\c port]: in case multiple port entries are found in the WSDL, give the one to be used here
            - [\c log]: a log closure or call reference taking a single string giving the log message
            - [\c dbglog]: a log closure or call reference taking a single string giving the debug log message
            - also all options from SoapClient::SoapClient::HTTPOptions, which are passed to the HTTPClient constructor
        */
        constructor(hash $h) : HTTPClient($h{HTTPOptions}) {
            if (exists $h.wsdl_file && exists $h.wsdl)
                throw "SOAP-CLIENT-ERROR", "only one of 'wsdl' or 'wsdl_file' keys can be given; both were passed";

            if ($h.event_queue)
                $.setEventQueue($h.event_queue);

            my any $wsdl;
            # get web service definition
            if (exists $h.wsdl_file)
                $wsdl = WSDLLib::getWSDL($h.wsdl_file, $self, $h.headers);
            else if (exists $h.wsdl)
                $wsdl = WSDLLib::getWSDL($h.wsdl, $self, $h.headers);
            else
                throw "SOAP-CLIENT-ERROR", "neither one of required 'wsdl' or 'wsdl_file' keys is present in the hash argument to SoapClient::constructor()";

            if (!exists $wsdl)
                throw "SOAP-CLIENT-ERROR", "missing wsdl in SoapClient::constructor()";

            $.wsdl = $wsdl instanceof WebService ? $wsdl : new WebService($wsdl, ("http_client" : $self, "http_headers" : $h.headers) + $h.wsdl_opt);

            # set service
            # get list of services in this wsdl
            my list $portTypes = keys $.wsdl.portType;
            if (elements $portTypes > 1 && !exists $h.portType)
                throw "SOAP-CLIENT-ERROR", sprintf("no 'portType' key passed in the option hash argument to SoapClient::constructor() (WSDL defines the following services: %n)", $portTypes);
            
            if (exists $h.portType) {
                if (!inlist($h.portType, $portTypes))
                    throw "SOAP-CLIENT-ERROR", sprintf("portType %n is not defined by this WSDL (valid portTypes: %y)", $h.portType, $portTypes);
                $.portType = $h.portType;
            }
            else
                $.portType = $portTypes[0];
            
            if (exists $h.url)
                $.url = $h.url;
            else {
                my string $port;
                if (!$.wsdl.services.port)
                    throw "SOAP-CLIENT-ERROR", sprintf("cannot find any port definitions in WSDL");

                if (elements $.wsdl.services.port > 1) {
                    if (exists $h.binding) {
                        foreach my string $p in ($.wsdl.services.port.keyIterator()) {
                            #printf("b=%y == %y\n", $.wsdl.services.port.$p.binding.val, $h.binding);
                            if ($.wsdl.services.port.$p.binding.val === $h.binding) {
                                $port = $p;
                                break;
                            }
                        }
                        if (!exists $port)
                            throw "SOAP-CLIENT-ERROR", sprintf("cannot find any port with binding: %y (valid ports: %y)", $h.binding, keys $.wsdl.services.port);
                    }
                    else if ($h.port) {
                        if (!exists $.wsdl.services.port.($h.port))
                            throw "SOAP-CLIENT-ERROR", sprintf("cannot find any port %y (valid ports: %y)", $h.port, keys $.wsdl.services.port);
                        $port = $h.port;
                    }
                }

                if (!$port)
                    $port = ($.wsdl.services.port).firstKey();

                $.url = $.wsdl.services.port.$port.address;
            }

            $.headers += $h.headers;
            # setup default headers
            if ($.wsdl.isSoap12())
                $.headers += ("Content-Type": MimeTypeSoapXml);
            else
                $.headers += ("Content-Type": MimeTypeXml);

            # set URL
            $.setURL($.url);

            if ($h.log)
                $.log = $h.log;
            if ($h.dbglog)
                $.dbglog = $h.dbglog;
        }

        #! returns a hash representing the serialized SOAP request for a given @ref WSDL::WSOperation "WSOperation"
        /** the returned hash can be passed to makeXMLString() to make the actual SOAP message

            @param operation the SOAP operation to use to serialize the request; if the operation is not known to the underlying @ref WSDL::WebService "WebService" class, an exception will be thrown
            @param args the arguments to the SOAP operation
            @param header data structure for the SOAP header, if required by the message
            @param op a reference to return the @ref WSDL::WSOperation "WSOperation" object found

            @throw SOAP-CLIENT-ERROR the operation is not defined in the WSDL
        */
        hash getMsg(string $operation, any $args, *hash $header, reference $op, *hash $nsh) {
            if (!exists $.wsdl.portType.$.portType.operations.$operation)
                throw "SOAP-CLIENT-ERROR", sprintf("operation %n does not exist (operations defined by service %n: %y)", 
                                                   $operation, $.portType, keys $.wsdl.portType.$.portType.operations);

            $op = $.wsdl.portType.$.portType.operations.$operation;
            my hash $msg = $op.serializeRequest($args, $header, $.getEncoding(), $nsh);
            if ($msg.hdr."Content-Type" !~ /charset=/i)
                $msg.hdr."Content-Type" += ";charset=" + $.getEncoding();
            return $msg;
        }

        #! makes a server call with the given operation and arguments and returns the deserialized result
        /** @param operation the operation name for the SOAP call
            @param args the arguments to the SOAP operation
            @param header optional soap headers (if required by the operation)

            @return the deserialized result of the SOAP call to the SOAP server
        */
        any call(string $operation, any $args, *hash $header, *hash $nsh) {
            my hash $info;
            return $.makeCallIntern(\$info, $operation, $args, $header, $nsh);
        }

        #! makes a server call with the given operation and arguments and returns the deserialized result
        /** @param operation the operation name for the SOAP call
            @param args the arguments to the SOAP operation
            @param info an optional reference to return a hash of technical information about the SOAP call (raw message info and headers)

            @return the deserialized result of the SOAP call to the SOAP server
        */
        any call(string $operation, any $args, *reference $info) {
            return $.makeCallIntern(\$info, $operation, $args);
        }

        #! makes a server call with the given operation and arguments and returns the deserialized result with an output argument giving technical information about the call
        /** @param info an optional reference to return a hash of technical information about the SOAP call (raw message info and headers)
            @param operation the operation name for the SOAP call
            @param args the arguments to the SOAP operation
            @param header optional soap headers (if required by the operation)

            @return the deserialized result of the SOAP call to the SOAP server
        */
        any call(reference $info, string $operation, any $args, *hash $header, *hash $nsh) {
            return $.makeCallIntern(\$info, $operation, $args, $header, $nsh);
        }

        #! makes the call to the SOAP server and ensures that SOAP fault responses returned with a 500-series status code are processed as a SOAP fault so that error information is returned in the resulting exception
        private any makeCallIntern(*reference $info, string $operation, any $args, *hash $header, *hash $nsh) {
            my WSOperation $op;
            my hash $msg = $.getMsg($operation, $args, $header, \$op, $nsh);
            my hash $hdr = $.headers + $msg.hdr;

            # we have to write the request key after the HTTPClient::post() call
            on_exit $info.request = ("body": $msg.body, "headers": $hdr, "soap_headers": $header);

            my date $now = now_us();
            on_exit {
                $.log("completed call to %y: %y", $operation, now_us() - $now);
                $.dbglog("info: %N", $info);
            }

            try {
                $info.response = $.send($msg.body, "POST", NOTHING, $hdr, True, \$info);
            }
            catch (hash $ex) {
                # allow fault responses returned with a 500-series status code to be processed as a SOAP fault so that error information is returned in the exception
                if ($ex.err == "HTTP-CLIENT-RECEIVE-ERROR" && $ex.arg.status_code >= 500 && $ex.arg.status_code < 600 && $ex.arg.body =~ /<\?xml.*Fault/)
                    $info.response = $ex.arg;
                else
                    rethrow;
            }

            my hash $xmldata = WSDLLib::parseSOAPMessage($info.response);
            #printf("DEBUG ans: %s\n", $info.response);
            return $op.deserializeResponse($xmldata);
        }

        #! uses SoapClient::call() to transparently serialize the argument and make a call to the given operation and return the deserialized results
        /** @param op the operation name, which is the method name passed to methodGate()
            @param arg a list or arguments or a single argument (or NOTHING) for the operation

            @return the deserialized result of the SOAP call to the SOAP server
        */
        any methodGate(string $op, any $arg) {
            return $.call($op, $arg);
        }

        #! returns a hash that can be used to ensure serialization with the XSD type given as the \a type argument
        hash getType(string $type, any $v) {
            return $.wsdl.getType($type, $v);
        }
       
        #! sends a log message to the log closure or call reference, if any
        log(string $msg) {
            if ($.log)
                call_function($.log, "SoapClient: " + trim(vsprintf($msg, $argv)));
        }

        #! sends a log message to the debug log closure or call reference, if any
        dbglog(string $msg) {
            if ($.dbglog)
                call_function($.dbglog, "SoapClient: " + trim(vsprintf($msg, $argv)));
        }
    }
}
