# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file SoapHandler.qm SOAP handler module providing the SoapHandler class to be registered as a handler with the Qore HttpServer module

/*  SoapHandler.qm Copyright (C) 2012 - 2021 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# make sure we have the required qore version
%requires qore >= 1.0

# requires XML functionality
%requires xml

# requires the WSDL module
%requires WSDL

# need mime definitions
%requires Mime >= 1.1

# need definitions from the HttpServerUtil
%requires HttpServerUtil >= 0.3.11

# need Util functions
%requires Util

# do not use $ for vars
%new-style

# require type declarations everywhere
%require-types

# do not ignore errors in call arguments
%strict-args

module SoapHandler {
    version = "0.3.1";
    desc = "SoapHandler module";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage SoapHandler Module

    @tableofcontents

    @section soaphandlerintro Introduction to the SoapHandler Module

    This module implements server-side support for the <a href="http://en.wikipedia.org/wiki/SOAP">SOAP protocol</a> for serialization/deserialization of message data.

    This module provides the @ref SoapHandler::SoapHandler "SoapHandler" class which can be used to provide an RPC handler for the HttpServer class provided by the HttpServer module.

    @section soaphandler_relnotes SoapHandler Release History

    @subsection soaphandler_0_3_1 SoapHandler 0.3.1
    - fixed a type error processing messages on listeners with no "hostname" socket info value
      (<a href="https://github.com/qorelanguage/qore/issues/4307">issue 4307</a>)

    @subsection soaphandler_0_3 SoapHandler 0.3
    - do not run SOAP operations in the SoapHandler lock
      (<a href="https://github.com/qorelanguage/qore/issues/4178">issue 4178</a>)

    @subsection soaphandler_0_2_7 SoapHandler 0.2.7
    - fixed a bug where HTTP request headers were not reported correctly in log callbacks
      (<a href="https://github.com/qorelanguage/qore/issues/2874">issue 2874</a>)
    - fixed a bug where duplicate \c soapAction values would cause an invalid error
      to be thrown even if there were unique paths for each operation
      (<a href="https://github.com/qorelanguage/qore/issues/2871">issue 2871</a>)

    @subsection soaphandler_0_2_6 SoapHandler 0.2.6
    - <b>Compatibility Warnings</b>
      - Because the SoapHandler module now supports HTTP bindings, it will only return
        WSDLs from GET requests if the URI path includes <tt>?wsdl</tt> at the end of the string
    - reimplemented operation to support multiple SOAP bindings, SOAP operations can be assigned to multiple bindings
    - HTTP binding support
    - implemented supoprt for handling SOAP faults based on the exception \c err string (must correspond to the fault name)
      (<a href="https://github.com/qorelanguage/qore/issues/2804">issue 2804</a>)

    @subsection soaphandler_0_2_5 SoapHandler 0.2.5
    - added support for matching requests with soap action values
    - added the err_func argument so SOAP response serialization errors can be logged at the source
    - added support for debugging (verbose exception info/logging)
    - fixes to service creation and GET WSDL handling
    - Content-type in exceptional cases follows Soap version
    - added support for logging content of SOAP messages

    @subsection soaphandler_0_2_4 SoapHandler 0.2.4
    - updated to a user module

    @subsection soaphandler_0_2_3 SoapHandler 0.2.3
    - return correct soap fault structure according to request

    @subsection soaphandler_0_2_2 SoapHandler 0.2.2
    - soap 1.2 improvements

    @subsection soaphandler_0_2_1 SoapHandler 0.2.1
    - matched to new WSDL and HttpServer implementation

    @subsection soaphandler_0_2_0 SoapHandler 0.2.0
    - better WSDL support

    @subsection soaphandler_0_1_0 SoapHandler 0.1.0
    - initial WSDL-based SOAP support (still incomplete)
*/

#! main SoapHandler namespace
public namespace SoapHandler {
    #! SoapHandler implementation; to be registered as a request handler in the HttpServer class
    public class SoapHandler inherits public AbstractHttpRequestHandler {
        #! version of the SoapHandler implementation
        const Version = "0.2.6";

        #! @cond nodoc
        private {
            # method mappings: method name -> method hash
            hash<auto> methods;

            # reverse mappings for methods: unique_id -> method -> True
            hash<string, hash<string, bool>> rmethods;

            # URI path -> method name -> method mappings
            hash<string, hash> uri_methods;

            # reverse URI path method mappings: unique_id -> URI path -> method name -> true
            hash<string, hash<string, hash<string, bool>>> ruri_methods;

            # service name -> WebService objects
            hash<string, WebService> wsh;

            # reverse mapping to remove wsh mappings; unique_id -> path -> True
            hash<string, hash<string, bool>> rwsh;

            # operation name -> WebService object
            hash<string, WebService> owsh;

            # reverse operation mappings; unique_id -> op name -> true
            hash<string, hash<string, bool>> rowsh;

            # lookup URI path -> WebService object
            hash<string, WebService> wsph;

            # reverse URI path lookups: unique_id -> URI path -> true
            hash<string, hash<string, bool>> rwsph;

            # URI path -> SOAP Action -> method mappings
            hash<string, hash<string, hash>> uri_sam;

            # reverse URI path -> SOAP Action mappings: unique_id -> URI path -> SOAPAction -> true
            hash<string, hash<string, hash<string, bool>>> ruri_sam;

            # soapaction map: action -> binding -> operation
            hash<string, hash> sam;

            # reverse mapping: unique_id -> soapaction -> True
            hash<string, hash<string, bool>> rsam;

            int loglevel;

            # if True then verbose exception info will be logged
            bool debug;

            # a closure/call reference to get the log message and/or process arguments in incoming requests
            *code getLogMessage;

            # for atomicity when adding / removing methods
            RWLock rwl();

            # path TreeMap for each HTTP method
            hash<string, TreeMap> mapMethodPathToOperation;

            # soapaction -> method -> binding
        }
        #! @endcond

        #! creates the handler with the given method list
        /** @param auth an authentication object (use new AbstractAuthenticator() for no authentication)
            @param n_getLogMessage an optional closure or call reference to be called when an incoming request is received; if this is set then it will be called with the following arguments: a context hash (see HttpServer::AbstractHttpRequestHandler::handleRequest() for a description of the context hash), the method definition as passed in the methods argument to this constructor, and a reference to the arguments in this call
            @param dbg this parameter is set to @ref Qore::True "True", then additional information will be logged when errors occur
         */
        constructor(AbstractAuthenticator auth, *code n_getLogMessage, bool dbg = False) : AbstractHttpRequestHandler(auth) {
            getLogMessage = n_getLogMessage;
            debug = dbg;
        }

        #! adds a method to the handler dynamically
        /** @param ws the WebService object for the method
            @param op the WSOperation object for the web service operation the method corresponds to
            @param func a call reference, a closure, or a string function name to call with the deserialized arguments to the method; the return value will be serialized to SOAP according to the WSDL and sent back to the caller
            @param help optional help text for the method
            @param logopt log options which can be used by a custom logger (see the \a getLogMessage parameter in the constructor)
            @param cmark an optional "context marker" for the method
            @param path an optional path for the method (assumed to be the name of the service)
            @param err_func a call reference, a closure, or a string function name to call with error information if an exception is thrown with SOAP data
            @param altpath an alternate path for the service / WSDL
            @param binding SOAP binding name, leave empty to use the first assigned binding
            @param unique_id the unique ID for the backend service implementation for all operations on this WSDL; necessary for any removeService() call
         */
        addMethod(WebService ws, WSOperation op, auto func, *string help, *int logopt, auto cmark, *string path, auto err_func, *string altpath, *string binding, *string unique_id) {
            if (!func.callp() && func.TypeCode() != NT_STRING) {
                throw "SOAP-SERVER-ADDMETHOD-PARAMETER-ERROR", sprintf("second argument is not a function name or callable value type (got: %y)", func);
            }

            addMethodInternal(ws, {
                "operation" : op,
                "name"      : op.name,
                "binding"   : binding,
                "function"  : func,
                "err_func"  : err_func,
                "help"      : help,
                "logopt"    : logopt,
                "cmark"     : cmark,
                "path"      : path,
                "altpath"   : altpath,
                "unique_id" : unique_id,
            });
            #printf("methods=%N\n", methods);
        }

        #! turns on or off debugging; when debugging is enabled more verbose error messages are reported
        setDebug(bool dbg = True) {
            debug = dbg;
        }

        #! returns the current status of the debug flag
        bool getDebug() {
            return debug;
        }

        #! call to remove the given service
        /** @param unique_id must correspond to the \a unique_id in any addMethod() calls
        */
        removeService(string unique_id) {
            rwl.writeLock();
            on_exit rwl.writeUnlock();

            # remove URI path -> method mappings
            foreach hash<auto> h in (ruri_methods{unique_id}.pairIterator()) {
                map remove uri_methods{h.key}{$1}, keys h.value;
                if (!uri_methods{h.key}) {
                    remove uri_methods{h.key};
                }
            }
            remove ruri_methods{unique_id};

            # remove method link mappings
            map delete methods.$1, keys rmethods{unique_id};
            delete rmethods{unique_id};

            # remove service operational mappings for service
            map remove owsh{$1}, keys rowsh{unique_id};
            remove rowsh{unique_id};

            # remove operation path mappings for service
            map remove wsh{$1}, keys rwsh{unique_id};
            remove rwsh{unique_id};

            # remove URI path mappings for service
            map remove wsph{$1}, keys rwsph{unique_id};
            remove rwsph{unique_id};

            # remove URI path -> SOAPAction mappings for service
            foreach hash<auto> h in (ruri_sam{unique_id}.pairIterator()) {
                map remove uri_sam{h.key}{$1}, keys h.value;
                if (!uri_sam{h.key}) {
                    remove uri_sam{h.key};
                }
            }
            remove ruri_sam{unique_id};

            # remove SOAPAction mappings for service
            map remove sam{$1}, keys rsam{unique_id};
            remove rsam{unique_id};
        }

        #! @cond nodoc
        # don't reimplement this method; fix/enhance it in the module
        final private addMethodInternal(WebService ws, hash<auto> method) {
            #printf("DEBUG: SoapHandler::addMethodInternal() method: %N\n", method);
            OperationalBinding binding = method.operation.getBinding(method.binding);

            if (binding instanceof SoapBinding) {
                SoapBinding sb = binding;

                # issue #2783: use the URI path for the service if possible
                if (!method.altpath && method.path) {
                    try {
                        # assume that "path" is the name of the service
                        hash<auto> svch = ws.getService(method.path);
                        if (svch.port) {
                            # if we have a simple path with no directory separators and no scheme, then the value will
                            # be in the "host" field after parse_url()
                            hash<auto> h = parse_url(svch.port.firstValue().address);
                            method.altpath = h.path ?? h.host;
                        }
                    } catch () {
                        # ignore all exceptions
                    }
                }

                # issue #2783: remove any leading slash from altpath
                if (method.altpath =~ /^\//) {
                    method.altpath = method.altpath.substr(1);
                }

                #printf("DEBUG: method: %y\n", method - "operation");
                # soap binding
                *string sa = sb.soapAction;
                if (sa) {
                    method.soap_action = sa;
                }

                rwl.writeLock();
                on_exit rwl.writeUnlock();

                # verify if the operation mapping can be added first
                if (!method.altpath && sa && sam{sa}.operation && sam{sa}.operation != method.operation) {
                    throw "SOAPACTION-ERROR", sprintf("cannot register soapAction %y for operation %y because it is "
                        "already registered for operation %y", sa, method.operation.name, sam{sa}.operation.name);
                }
                if (method.altpath && wsph{method.altpath} && wsph{method.altpath} != ws) {
                    # find conflicting ID
                    string conflicting_id;
                    foreach hash<auto> i in (rwsph.pairIterator()) {
                        if (i.value{method.altpath}) {
                            conflicting_id = i.key;
                            break;
                        }
                    }
                    throw "SOAP-PATH-ERROR", sprintf("URI path %y is already bound to another WebService with unique "
                        "ID %y; remove the existing WebService before binding another service to the same URI path",
                        method.altpath, conflicting_id);
                }

                # add SOAPAction mapping if possible
                if (sa) {
                    if (!sam{sa}) {
                        # add mapping from SOAPAction to method
                        sam{sa} = method;

                        # add path / soapaction mapping for service removal
                        if (method.unique_id) {
                            rsam{method.unique_id}{sa} = True;
                        }
                    }

                    # add URI path -> SOAPAction mappings if possible
                    if (method.altpath && !uri_sam{method.altpath}{sa}) {
                        uri_sam{method.altpath}{sa} = method;
                        #printf("DEBUG: added SA mapping %y -> %y -> method\n", method.altpath, sa);

                        # add reverse mappings for removal
                        if (method.unique_id) {
                            ruri_sam{method.unique_id}{method.altpath}{sa} = True;
                        }
                    }
                }

                # add URI path mapping if possible
                if (method.altpath && !wsph{method.altpath}) {
                    wsph{method.altpath} = ws;

                    if (method.unique_id) {
                        # add reverse lookup for service removal
                        rwsph{method.unique_id}{method.altpath} = True;
                    }
                }

                # add operation path mapping if possible
                if (method.path && !wsh{method.path}) {
                    # add link to WebService object
                    wsh{method.path} = ws;

                    # add reverse mapping for service removal
                    if (method.unique_id) {
                        rwsh{method.unique_id}{method.path} = True;
                    }
                }

                # map operation names to WebService objects
                foreach hash<OperationInfo> oph in (ws.listOperations()) {
                    if (!owsh{oph.operation.name}) {
                        owsh{oph.operation.name} = ws;

                        if (method.unique_id) {
                            rowsh{method.unique_id}{oph.operation.name} = True;
                        }
                    }
                }

                #printf("DEBUG: operation request names: %y\n", method.operation.getTopLevelRequestNames());

                # add request name mappings
                foreach string rn in (method.operation.getTopLevelRequestNames()) {
                    #printf("DEBUG: rn: %y methods: %y\n", rn, keys methods);
                    if (!methods{rn}) {
                        methods{rn} = method;

                        if (method.unique_id) {
                            rmethods{method.unique_id}{rn} = True;
                        }
                    }

                    #printf("DEBUG: method.altpath: %y rn: %y uri_methods: %y uri_methods{%y}: %y\n", method.altpath, rn, keys uri_methods, method.altpath, keys uri_methods{method.altpath});
                    if (method.altpath && !uri_methods{method.altpath}{rn}) {
                        uri_methods{method.altpath}{rn} = method;

                        #printf("DEBUG: added URL mapping %y -> %s -> method\n", method.altpath, rn);

                        if (method.unique_id) {
                            ruri_methods{method.unique_id}{method.altpath}{rn} = True;
                        }
                    }
                }

                # add mapping for method name
                if (!methods{method.name}) {
                    methods{method.name} = method;

                    if (method.unique_id) {
                        rmethods{method.unique_id}{method.name} = True;
                    }
                }

                if (method.altpath && !uri_methods{method.altpath}{method.name}) {
                    uri_methods{method.altpath}{method.name} = method;
                    #printf("DEBUG: added URL mapping %y -> %s -> method\n", method.altpath, method.name);

                    if (method.unique_id) {
                        ruri_methods{method.unique_id}{method.altpath}{method.name} = True;
                    }
                }
            } else if (binding instanceof HttpBinding) {
                HttpBinding hb = binding;
                # http binding
                rwl.readLock();
                on_exit rwl.readUnlock();
                if (!mapMethodPathToOperation{hb.httpMethod}) {
                    mapMethodPathToOperation{hb.httpMethod} = new TreeMap();
                }
                method.parseUrlOnly = hb.input.urlEncoded || hb.input.urlReplacement;
                method.exactMatch = !hb.input.urlReplacement;
                method.path = ltrim(method.path ?? hb.location, "/");
                if (index(method.path, "?") >= 0) {
                    throw "SOAPACTION-ERROR", sprintf("cannot register path %y for operation %y because it contains "
                        "parameters", method.path, method.operation.name);
                }
                mapMethodPathToOperation{hb.httpMethod}.put(method.path, method);
            } else if (!exists binding) {
                throw "SOAPACTION-ERROR", sprintf("cannot register operation %y because it has no binding", 
                    method.operation.name);
            } else {
                throw "SOAPACTION-ERROR", sprintf("cannot register operation %y because it has unsupported "
                    "binding: %y", method.operation.name, binding.className());
            }
            #printf("DEBUG: SoapHandler::addMethodInternal() %N %N\n", method.name, method.path);
        }

        private *hash<auto> help(hash<auto> cx) {
            hash<auto> h;

            rwl.readLock();
            on_exit rwl.readUnlock();

            foreach string cmd in (keys methods) {
                h{cmd}.description = methods{cmd}.help;
                if (methods{cmd}.params)
                    h{cmd}.params = methods{cmd}.params;
            }
            return h;
        }

        # don't reimplement this method; fix/enhance it in the module
        final private log(hash<auto> cx, string str) {
            string msg = "SOAP ";
            if (exists cx.user)
                msg += sprintf("user %s ", cx.user);
            msg += sprintf("from %s: ", cx."peer-info".address_desc);
            msg += vsprintf(str, argv);

            call_function_args(cx.logfunc, msg);
        }

        /** Method is to be overriden to implement custom logging HTTP messages handled by this object.
            @par cx context passed from @ref HttpServer::HttpServer "HttpServer"
            @par msg information about message to be logged. There are keys 'reason' with value 'request', 'response' 
            or 'error', 'header' (HTTP header, in casew ) and 'body' containing XML data in readable form, i.e. 
            uncompressed and in case of multipart message only the related part is passed. The method is executed 
            before the message is sent or after it has been received.  This method must not throw exceptions.

            @par Example:
            @code{.py}
private nothing msglog(hash<auto> cx, hash<auto> msg) {
    log(sprintf("%s:\n%s\n", msg.reason, msg.body));
}
            @endcode

            @since %SoapHandler 0.2.5
        */
        private nothing msglog(hash<auto> cx, hash<auto> msg) {
            # implement functionality in descendant class
        }

        # don't reimplement this method; fix/enhance it in the module
        private hash<auto> makeSoapFaultResponse(hash<auto> cx, string errLog, bool soap12, string err, string desc, 
                *bool fmt) {
            hash<auto> o;
            if (soap12) {
                o = ENVELOPE_12_NS + {
                    "soapenv:Envelope": {
                        "soapenv:Body": {
                            "soapenv:Fault": {
                                "soapenv:Code": {
                                    "soapenv:Value": "soapenv:Sender",
                                },
                                "soapenv:Reason": {
                                    "soapenv:Text": sprintf("%s: %s", err, desc),
                                },
                            },
                        },
                    },
                };
                # optional Node, Role, Detail, see https://www.w3.org/TR/soap12/, 5.4 Fault
            } else {
                o = ENVELOPE_11_NS + {
                    "soapenv:Envelope": {
                        "soapenv:Body": {
                            "soapenv:Fault": {
                                "faultcode": "soapenv:Client",
                                "faultstring": sprintf("%s: %s", err, desc),
                            },
                        },
                    },
                };
                # optional faultActor,  https://www.w3.org/TR/2000/NOTE-SOAP-20000508/ 4.4 SOAP fault
            }
            #TODO: http binding https://www.w3.org/TR/2007/REC-soap12-part2-20070427/#soapinhttp
            int code = soap12 ? 400 : 500;
            hash<auto> msg = {
                "code": code,
                "errlog": errLog,
                "body": make_xml(o, fmt ? XGF_ADD_FORMATTING: 0),
                "hdr": {
                    "Content-Type": WSDLLib::getSoapMimeType12(soap12),
                },
            };
            msglog(cx, {'reason': 'error', 'code': code, 'header': msg.hdr, 'body': msg.body});
            return msg;
        }

        # don't reimplement this method; fix/enhance it in the module
        final private *hash<auto> callOperation(hash<auto> cx, auto args, hash<auto> method, bool reqsoap12) {
            # NOTE: internal methods have no operation definition and can take no parameters
            hash<auto> h;
            if (method.internal) {                
                h.body = call_object_method(self, method.function);
                return h;
            }

            # add context marker, if any
            cx.cmark = method.cmark;
            cx.function = method.function;
            cx.operation = method.operation;

            try {
                if (method.parseUrlOnly) {
                    args = method.operation.deserializeRequestPath(cx.url.path, method.binding);
                } else {
                    args = method.operation.deserializeRequest(args, method.binding);
                }
            } catch (hash<ExceptionInfo> ex) {
                if (method.err_func) {
                    hash<auto> nex = ex;
                    nex.desc = sprintf("error deserializing incoming SOAP request: %s", ex.desc);
                    call_function(method.err_func, cx, nex);
                }
                string str = debug
                    ? get_exception_string(ex)
                    : sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc);
                return makeSoapFaultResponse(cx, str, reqsoap12, ex.err, ex.desc);
            }

            if ((method.logopt & HttpServer::LP_LEVELMASK) <= loglevel && exists cx.logfunc) {
                string msg = sprintf("SOAP call from %s: %s", cx."peer-info".address_desc, method.name);

                if (method.logopt & HttpServer::LP_LOGPARAMS) {
                    msg += sprintf("(");
                    int i = 0;
                    foreach auto arg in (args) {
                        if (inlist(i++, method.maskargs))
                            msg += "<masked>, ";
                        else if (arg.typeCode() == NT_HASH && elements arg) {
                            msg += "(";
                            foreach string k in (keys arg) {
                                if (k == method.maskkey)
                                    msg += sprintf("%s=<masked>, ", k);
                                else
                                    msg += sprintf("%s=%n, ", k, arg{k});
                            }
                            splice msg, -2, 2;
                            msg += "), ";
                        } else
                            msg += sprintf("%n, ", arg);
                    }
                    # remove the last two characters from the string if any were added
                    if (i)
                        splice msg, -2, 2;
                    msg += ")";
                }

                log(cx, msg);
            }
            #printf("about to call function '%s' (method=%s params=%N)\n", method.function, method.name, args);flush();
            auto rv;

            if (args.typeCode() == NT_LIST)
                unshift args, cx;
            else if (exists args)
                args = (cx, args);
            else
                args = cx;

            try {
                if (method.internal)
                    rv = call_object_method_args(self, method.function, args);
                else
                    rv = call_function_args(method.function, args);
            } catch (hash<ExceptionInfo> ex) {
                # issue #2804: see if the exception error code is a valid fault for the operation
                #printf("err: %y has fault: %y\n", ex.err, method.operation.hasFault(ex.err));
                if (ex.err.typeCode() == NT_STRING && method.operation.hasFault(ex.err)) {
                    try {
                        auto header = remove rv."^header^";
                        h += method.operation.serializeFault(ex.err, ex.desc ?? "no description provided", ex.arg, header, NOTHING, NOTHING, NOTHING, NOTHING, method.binding);
                        h.code = reqsoap12 ? 400 : 500;
                        msglog(cx, {"reason": "error", "code": h.code, "header": h.hdr, "body": h.body});
                        return h;
                    } catch (hash<ExceptionInfo> ex) {
                        if (method.err_func) {
                            call_function(method.err_func, cx, ex);
                        }
                        rethrow;
                    }
                }
                rethrow;
            }

            # if there is an output message, then serialize the response
            if (method.operation.output) {
                try {
                    auto header = remove rv."^header^";
                    h += method.operation.serializeResponse(rv, header, NOTHING, NOTHING, reqsoap12, NOTHING, method.binding);
                    msglog(cx, ('reason': 'response', 'code': 200, 'header': h.hdr, 'body': h.body));
                } catch (hash<ExceptionInfo> ex) {
                    if (method.err_func)
                        call_function(method.err_func, cx, ex);
                    rethrow;
                }
            }
            #log(cx, "body=%N", h.body);

            return h;
        }

        private *hash<auto> matchMethod(TreeMap tm, string path, reference unmatched) {
            bool hasParams = index(path, "?") >= 0;
            *string um;
            *hash<auto> method = tm.get(path, \um);
            if (method) {
                if (method.exactMatch) {
                    if (!hasParams && um != "" || hasParams && index(um, "?") > 0) {
                        return NOTHING;
                    }
                }
                unmatched = um;
            }
            return method;
        }

        # method called by HttpServer
        # don't reimplement this method; fix/enhance it in the module
        final hash<auto> handleRequest(hash<auto> cx, hash<auto> hdr, *data body) {
            #log(LL_DEBUG_1, "soap handler context=%y hdr=%y body=%y wsh=%y", cx, hdr, body, wsh.keys());
            #printf("soap handler context=%y hdr=%y body=%y keys wsh=%y\n", cx, hdr, body, wsh.keys());
            cx.http_header = hdr;
            cx.http_body = body;
            *hash<auto> method;

            bool reqsoap12 = False; # set to True if soap 1.2 envelope is used in request

            *string path = cx.url.path;

            # remove leading / in path, if any
            path =~ s/^\///;

            *string alt_path;
            # issue #2783 respect URI paths when matching
            if (cx.root_path && path.equalPartialPath(cx.root_path)) {
                alt_path = path.substr(cx.root_path.size());
                # remove leading / in path, if any
                alt_path =~ s/^\///;
            }
            #printf("DEBUG: path: %y alt: %y root: %y hdr.method: %y\n", path, alt_path, cx.root_path, hdr.method);

            if (hdr.method == "POST") {
                # try SoapBinding
                *string soapaction = (hdr."content-type" =~ x/;action=(.+)/)[0];
                if (soapaction)
                    hdr."content-type" =~ s/;.+$/;#/;    # TODO: is regex correct should not match till ;
                else
                    soapaction = hdr.soapaction;
                if (soapaction) {
                    rwl.readLock();
                    on_exit rwl.readUnlock();

                    #printf("DEBUG: path: %y alt_path: %y soapaction: %y us: %y urs: %y s: %y\n", path, alt_path, soapaction, exists uri_sam{path}{soapaction}, exists uri_sam{alt_path}{soapaction}, exists sam{soapaction});

                    # issue #2783 respect URI paths when matching
                    method = uri_sam{path}{soapaction} ?? uri_sam{alt_path}{soapaction} ?? sam{soapaction};
                    #printf("DEBUG: request matched with SoapAction %y method: %y us: %y\n", soapaction, keys method, keys uri_sam);
                }
            }

            if (!method) {
                # SOAP action is not explicitly specified, e.g. HTTP binding, try get it from path
                # issue #4187: do not run SOAP operation calls in the lock
                *string args;
                {
                    rwl.readLock();
                    on_exit rwl.readUnlock();

                    if (exists mapMethodPathToOperation{hdr.method}) {
                        TreeMap tm = mapMethodPathToOperation{hdr.method};
                        method = matchMethod(tm, path, \args);
                        if (!method && alt_path) {
                            method = tm.get(alt_path, \args);
                        }
                    }
                }
                if (method && method.parseUrlOnly) {
                    try {
                        msglog(cx, {'reason': 'request', 'method': hdr.method, 'path': path});  # we need to log the request
                        #printf("DEBUG: context: %N\nargs: %N\n", cx, args);
                        return {
                            "code": 200,
                         } + callOperation(cx, args, method, reqsoap12);
                    } catch (hash<ExceptionInfo> ex) {
                        string str = debug
                            ? get_exception_string(ex)
                            : sprintf("exception in %s: %s: %s", get_ex_pos(ex), ex.err, ex.desc);
                        return makeSoapFaultResponse(cx, str, reqsoap12, ex.err, ex.desc);
                    }
                }
            }

            # service the WSDL with properly-formatted GET requests
            if (hdr.method == "GET" && path =~ /\?wsdl/i) {
                # path has not been resolved to an operation, so try an heuristic to match a service
                # remove query args if present
                path =~ s/\?.*$//;

                #printf("DEBUG: PATH=%N (%n %n)\n", path, exists wsh{path}, keys wsh);

                rwl.readLock();
                on_exit rwl.readUnlock();

                *WebService ws = tryMatch(path);
                if (!ws && alt_path) {
                    ws = tryMatch(alt_path);
                }
                if (!ws) {
                    # try a match with the last component of the path, if any
                    path =~ s/.*\///g;
                    if (path)
                        ws = tryMatch(path);
                }

                if (!ws) {
                    return {
                        "code": 501,
                        "body": sprintf("invalid HTTP GET: no WebService object for path %y; known paths / services: "
                            "%y; known operations: %y; known alt paths: %y", path, wsh.keys(), owsh.keys(),
                            wsph.keys()),
                    };
                }

                # get URL for service
                # note that "socket-info".hostname is not returned for UNIX sockets
                string host;
                hash<auto> sih = cx."socket-info";
                if (sih.family == AF_UNIX) {
                    host = sprintf("socket=%s", encode_url(sih.address, True));
                } else {
                    # issue #4307: hostname is not always set, address is
                    host = sih.hostname ?? sih.address;
                    if (host == "::" || host == "0.0.0.0") {
                        host = gethostname();
                    }
                }

                string base_url = sprintf("http%s://%s", cx.ssl ? "s" : "", host);
                if (sih.port) {
                    int port = sih.port;
                    if (cx.ssl) {
                        if (port != 443)
                            base_url += ":" + port;
                    } else if (port != 80)
                        base_url += ":" + port;
                }
                if (cx.root_path) {
                    base_url += "/" + cx.root_path;
                }

                return {
                    "code": 200,
                    "body": ws.getWSDL(base_url),
                    "hdr": {"Content-Type": "text/xml"},
                };
            }

            if (method || hdr.method == "POST") {
                # still chance to get method from xml element in case of SoapBinding (i.e.POST), we need parse message now
                auto args;
                try {
                    *string ct = hdr."_qore_orig_content_type";
                    *string element = (ct =~ x/action=".*\/(.*)"/)[0];
                    # parse multipart messages
                    if (ct =~ /multipart\//) {
                        *string  x = (ct =~ x/multipart\/([^;]+)/)[0];
                        hdr."_qore_multipart" = x;
                        x = (ct =~ x/start=([^;]+)/)[0];
                        if (exists x)
                            hdr."_qore_multipart_start" = x;
                        x = (ct =~ x/boundary=([^;]+)/)[0];
                        if (exists x)
                            hdr."_qore_multipart_boundary" = x;
                        #printf("hdr=%N\n", hdr);
                    }
                    hash<auto> msg = WSDLLib::parseMultiPartSOAPMessage(hdr + ("body" : body));
                    msglog(cx, ('reason': 'request', 'header': hdr, 'method': hdr.method, 'body': msg.body));
                    args = WSDLLib::parseSOAPMessage(msg);
                    if (WSDLLib::isSOAPMessage(msg)) {
                        # it is SOAP message (or XML content)
                        WSDL::XsdBase::removeNS(\args);
                        WSDL::XsdBase::removeNS(\args.Envelope);

                        if (!method) {
                            # get SOAP operation name from top XML element
                            if (!exists element && exists args.Envelope.Body && args.Envelope.Body.typeCode() == NT_HASH ) {
                                foreach string k in (keys args.Envelope.Body) {
                                    if (k == "multiRef" || k == "^attributes^")
                                        continue;
                                    element = (k =~ x/.*:(.*)/)[0];
                                    break;
                                }
                            }
                            if (element) {
                                rwl.readLock();
                                on_exit rwl.readUnlock();

                                #printf("DEBUG: path: %y alt_path: %y element: %y um: %y urm: %y m: %y\n", path,
                                #   alt_path, element, exists uri_methods{path}{element},
                                #   exists uri_methods{alt_path}{element}, exists methods{element});
                                # issue #2783: respect UTI paths when matching
                                method = uri_methods{path}{element} ?? uri_methods{alt_path}{element} ?? methods{element};
                            }
                        }

                        # set soap version in request
                        *hash<auto> attr = args.Envelope."^attributes^";
                        foreach string k in (keys attr) {
                            if (k =~ /:soapenv$/) {
                                if (attr{k} == SOAP_12_ENV)
                                    reqsoap12 = True;
                                else if (attr{k} != SOAP_11_ENV)
                                    throw "SOAP-CALL-ERROR", sprintf("unsupported SOAP envelope received: %n", attr{k});
                                break;
                            }
                        }
                        if (!method && !exists element) {
                            throw "SOAP-CALL-ERROR", sprintf("no operation call found in message (SOAP body "
                                "args: %y)", keys args.Envelope.Body);
                        }
                        #printf("DEBUG element: %y methods: %y args: %y\n", element, methods.keys(), args);
                    }
                } catch (hash<ExceptionInfo> ex) {
                    log(cx, "exception parsing SOAP msg: %y\n%y", body, ex);
                    string str = sprintf("exception in %s:%d: %s: %s (1: %N)", ex.file, ex.line, ex.err, ex.desc,
                        ex.callstack)
                    #string str = debug
                        ? get_exception_string(ex)
                        : sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc);
                    return makeSoapFaultResponse(cx, str, reqsoap12, ex.err, ex.desc);
                }

                if (method) {
                    try {
                        #printf("DEBUG: context: %N\nargs: %N\n", cx, args);
                        return {"code": 200} + callOperation(cx, args, method, reqsoap12);
                    } catch (hash<ExceptionInfo> ex) {
                        string str = debug
                            ? get_exception_string(ex)
                            : sprintf("exception in %s: %s: %s", get_ex_pos(ex), ex.err, ex.desc);
                        return makeSoapFaultResponse(cx, str, reqsoap12, ex.err, ex.desc);
                    }
                }
            }

            return {
                "code" : 501,
                "body" : sprintf("don't know how to handle request with method %y", hdr.method),
            };
        }

        private *WebService tryMatch(string path) {
            # issue #2783: we have to try the top-level service path match first, then operation paths
            return wsph{path} ?? owsh{path} ?? wsh{path};
        }
        #! @endcond
    }
}
