# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file WSDL.qm WSDL: Web Services Description Language: http://www.w3.org/TR/wsdl

/*  WSDL.qm Copyright (C) 2012 - 2014 David Nichols

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# make sure we have the required qore version
%requires qore >= 0.8.10

# requires XML functionality
%requires xml

# need mime definitions
%requires Mime >= 1.1

%disable-warning unreferenced-variable

module WSDL {
    version = "0.3.5";
    desc = "WSDL module providing functionality for SOAP";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/*  Version History
    * 2014-01-14 v0.3.5: David Nichols <david@qore.org>: fixed msg serialization issues
    * 2012-05-31 v0.3.4: David Nichols <david@qore.org>: updated to a user module
    *            v0.3.3: added initial support for the anyAttribute element of complexType
                         added initial support for SOAP header processing
                         added initial support for multiple portType and bindings in a WSDL

    *            v0.3.2: fixed bugs de/serializing negative values for "int" and "short"
    *            v0.3.1: improved XSD imports and namespace handling

    *            v0.3.0: implemented WSDLLib class of helper functions
                         implemented support for xsd import statements in WSDLs

    *            v0.2.0: use parseXMLAsData() instead of parseXML()
                         implemented initial simpleType support
                         fixed xsd:date serialization and deserialization


    WSDL classes
    provides some minimal WSDL and XSD support for SOAP messaging used by the SoapClient class and the SoapHandler

    not complete, needs namespace verification, improved XSD support, element groups, etc
*/

/** @mainpage WSDL Module
    
    @section wsdlintro Introduction to the WSDL Module

    The %WSDL module provides functionality for <a href="http://en.wikipedia.org/wiki/SOAP">SOAP</a>.

    The main purpose of this module is to provide the infrastructure for developing SOAP client and server services.

    The main components of this module are as follows:
    - @ref WSDL::WebService "WebService": represents a WSDL file; an easy way to get an object of this type from a URL is by calling WSDL::WSDLLib::getWSDL()
    - @ref WSDL::WSDLLib "WSDLLib": a class of static functions providing helper functions for the module
    - @ref WSDL::WSOperation "WSOperation": a class representing a single operation from a web service

    See the following for modules using the %WSDL module:
    - <a href="../../SoapClient/html/index.html">SoapClient user module</a>
    - <a href="../../SoapHandler/html/index.html">SoapHandler user module</a>
*/

#! main WSDL namespace
public namespace WSDL {
    #! this WSDL implementation version
    public const version     = "0.3.5";
    
    public const XET_ALL      = "ALL";
    public const XET_CHOICE   = "CHOICE";
    public const XET_SEQUENCE = "SEQUENCE";

    #! SOAP 1.1 envelope URI
    public const SOAP_11_ENV  = "http://schemas.xmlsoap.org/soap/envelope/";
    #! SOAP 1.2 envelope URI
    public const SOAP_12_ENV  = "http://www.w3.org/2003/05/soap-envelope";

    #! SOAP 1.2 namespace URI
    public const SOAP_12_NS   = "http://schemas.xmlsoap.org/wsdl/soap12/";

    #! XSD namespace URI
    public const XSD_NS       = "http://www.w3.org/2001/XMLSchema";
    #! XSI namespace URI
    public const XSI_NS       = "http://www.w3.org/2001/XMLSchema-instance";

    #! HTTP namespace URI
    public const HTTP_NS      = "http://schemas.xmlsoap.org/wsdl/http/";
    #! MIME namespace URI
    public const MIME_NS      = "http://schemas.xmlsoap.org/wsdl/mime/";

    #! soap 1.1 envelope namespaces
    public const ENVELOPE_11_NS = 
	( "soapenv:Envelope" :
	  ( "^attributes^" : 
	    ( "xmlns:soapenv" : SOAP_11_ENV,
	      "xmlns:xsd"     : XSD_NS,
	      "xmlns:xsi"     : XSI_NS ) ) );

    #! soap 1.2 envelope namespaces
    public const ENVELOPE_12_NS = 
	( "soapenv:Envelope" :
	  ( "^attributes^" : 
	    ( "xmlns:soapenv" : SOAP_12_ENV,
	      "xmlns:xsd"     : XSD_NS,
	      "xmlns:xsi"     : XSI_NS ) ) );

    #! soap encoding URI
    public const SOAP_ENCODING = "http://schemas.xmlsoap.org/soap/encoding/";

    #! mapping from Qore types to xsd types for xsd type "anyType"
    public const any_type_map = 
	( Type::String      : "string",
	  Type::Int         : "long",
	  Type::Boolean     : "boolean",
	  Type::Date        : "dateTime",
	  Type::Float       : "decimal",
	  Type::NothingType : "string",
	  Type::NullType    : "string",
	  Type::Binary      : "base64Binary" );

    # error codes
    const SOAP_SERIALIZATION_ERROR = "SOAP-SERIALIZATION-ERROR";
    const SOAP_DESERIALIZATION_ERROR = "SOAP-DESERIALIZATION-ERROR";
    const WSDL_ERROR = "WSDL-ERROR";

    #! SOAP transport URL
    const SOAP_TRANSPORT_HTTP = "http://schemas.xmlsoap.org/soap/http";

    #! range of "short" values (16 bits)
    public const RANGE_SHORT = (-32768, 32767);

    #! range of "int" values (32 bits)
    public const RANGE_INT = (-2147483648, 2147483647);
}

#! contains helper methods for retrieving WSDLs from a URL
public class WSDL::WSDLLib {
    #! Mime types recognized as SOAP messages
    const SoapMimeTypes = (MimeTypeSoapXml, MimeTypeXml, MimeTypeXmlApp);

    #! retrieves a local file and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "file"
    */
    static string getFile(string $fn, bool $as_string = True) {
        return $as_string ? ReadOnlyFile::readTextFile($fn) : ReadOnlyFile::readBinaryFile($fn);
    }

    #! retrieves a file from a URL with HTTP and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "http"
    */
    static string getHTTP(string $url, *string $path, *HTTPClient $hc, *hash $headers, bool $as_string = True) {
	if ($hc)
	    $hc.setURL($url);
	else
	    $hc = new HTTPClient(("url" : $url));
        my string $body = $hc.get($path ? $path : "/", $headers);
        return $as_string ? $body : binary($body);
    }

    #! retrieves a file from a URL with the FTP protocol and returns the file's contents as binary or string data
    /** called by WSDLLib::getFileFromURL() in case the scheme is "ftp"
    */
    static data getFTP(string $url, string $path, bool $as_string = True) {
	my string $file = basename($path);
	if (!$file)
	    throw "WSDL-LIB-ERROR", sprintf("missing file name in URL %n", $url);
	
	my FtpClient $f($url);
	$f.connect();
	
	my string $dir = dirname($path);
	if ($dir)
	    $f.cwd($dir);

	return $as_string ? $f.getAsString($file) : $f.getAsBinary($file);
    }

    #! retrieves a file from a URL
    static data getFileFromURL(string $url, string $def_protocol = "file", *HTTPClient $http_client, *hash $http_headers, bool $as_string = True) {
        return WSDLLib::getFileFromURL($url, parse_url($url), $def_protocol, $http_client, $http_headers, $as_string);
    }

    #! retrieves a file from an already-parsed URL
    static data getFileFromURL(string $url, hash $u, string $def_protocol = "file", *HTTPClient $http_client, *hash $http_headers, bool $as_string = False) {
	if (!exists $u.protocol)
	    $u.protocol = $def_protocol;
	
	switch ($u.protocol) {
	    case "file":
		return WSDLLib::getFile($u.host + $u.path, $as_string);

	    case /^http(s)?$/:
		return WSDLLib::getHTTP($url, $u.path, $http_client, $http_headers, $as_string);

	    case /^ftp(s)?$/:
		return WSDLLib::getFTP($url, $u.path, $as_string);

	    default:
	        throw "WSDL-LIB-ERROR", sprintf("do not know how to retrieve data with scheme %y given in URL %n", $u.protocol, $url);
	}
    }

    #! returns the argument
    static WebService getWSDL(WebService $wsdl) {
        return $wsdl;
    }

    #! returns a WSDL string form a file name, optional HTTPClient object and optional header hash
    static string getWSDL(string $wsdl, *HTTPClient $http_client, *hash $http_headers) {
	if (strlen($wsdl) > 256 && $wsdl !~ /^\w+:\/\/.*$/)
	    return $wsdl;
	return WSDLLib::getFileFromURL($wsdl, "file", $http_client, $http_headers);
    }

    #! takes a hash representation of a SOAP message and parses it to a Qore data structure; handles multipart messages, checks the content-type, and handles hrefs in the message
    static hash parseSOAPMessage(hash $msg) {
	if (exists $msg."_qore_multipart") {
	    if ($msg."_qore_multipart" != "related")
		throw "SOAP-MESSAGE-ERROR", sprintf("don't understand multipart/%s messages, expected multipart/related", $msg."_qore_multipart");

	    my any $bdry = $msg."_qore_multipart_boundary";
	    if (!strlen($bdry))
		throw "SOAP-MESSAGE-ERROR", sprintf("multipart message received without multipart boundary; headers=%n", $msg - "body");

	    my hash $mpmsg;
	    my list $l = split("\r\n--" + $bdry, $msg.body);

	    for (my int $i = 1; $i < (elements $l - 1); ++$i) {
		my string $m = $l[$i];
		
		my int $ie = index($m, "\r\n\r\n");
		if ($ie == -1) {
		    throw "SOAP-MESSAGE-ERROR", sprintf("part %d has no headers: %n", $i, $m);
		}
		my hash $hh;
		foreach my string $hl in (split("\r\n", substr($m, 2, $ie))) {
		    trim $hl;
		    my (string $hi, any $ignore, string $ha) = $hl =~ x/^(.*):([ \t])*(.*)$/;
		    $hi = tolower($hi);
		    #printf("hl=%n hi=%n ha=%n\n", $hl, $hi, $ha);exit();
		    $hh.$hi = $ha;		    
		}
		if (!exists $hh."content-id")
		    throw "SOAP-MESSAGE-ERROR", sprintf("expecting part header Content-ID in part %d; headers: %n", $i, $hh);

		my any $b;
		if ($hh."content-transfer-encoding" == "binary") {
		    # unfortunately we have to do some tricks to get the binary data out here
                    # FIXME: tricks probably not necessary with qore 0.8.1+
		    $m = force_encoding($m, "ascii");
		    # recalculate byte offset
		    $ie = index($m, "\r\n\r\n");
		    #printf("ie=%d m=%d\n", $ie, strlen($m));exit();
		    $b = binary(substr($m, $ie + 4));

		    #my File $f(); $f.open2("t.bin", O_CREAT|O_WRONLY|O_TRUNC); $f.write($b); exit();
		}
		else {
		    $b = substr($m, $ie + 4);

		    if ($hh."content-type" =~ /charset=/) {
			my string $c = ($hh."content-type" =~ x/charset=([^;]+)/)[0];
			$b = force_encoding($b, $c);
		    }
		}

		if ($hh."content-id" !~ /^\<.*\>$/)
		    throw "SOAP-MESSAGE-ERROR", sprintf("expected part ID to have the following format: <id>, instead got %s", $hh."content-id");

		my hash $p = ( "hdr" : $hh,
                               "body" : $b );

		if ((!exists $msg."_qore_multipart_start" && $i == 1)
		    || (exists $msg."_qore_multipart_start" && $msg."_qore_multipart_start" == $hh."content-id")) {
		    $mpmsg.body = $p;
		}
		else {
		    my string $id = substr($hh."content-id", 1, -1);
		    $mpmsg.part.$id = $p;
		}
	    }
	    # check content-type
	    WSDLLib::checkSOAPContentType($mpmsg.body.hdr."content-type");

	    #printf("part %d hh=%N\nbody=%s (%d)\n", $i, $hh, type($b), elements($b)); #exit();	
	    my hash $xmldata = parseXMLAsData($mpmsg.body.body);
	    
	    # parse entire data structure to find "href"s or href attributes
	    WSDLLib::substHref(\$xmldata, $mpmsg.part);
	    return $xmldata;
	}

	WSDLLib::checkSOAPContentType($msg."content-type");

	return parseXMLAsData($msg.body);
    }

    private static checkSOAPContentType(string $ct) {
	foreach my string $sct in (SoapMimeTypes) {
	    if (bindex($ct, $sct) != -1)
		return;
	}
	
	throw "SOAP-MESSAGE-ERROR", sprintf("don't know how to handle content-type %n (expecting one of: %y)", $ct, SoapMimeTypes);
    }

    private static processHref(reference $xmldata, string $hr, hash $parts) {
	if ($hr !~ /^cid:/)
	    throw "SOAP-MESSAGE-ERROR", sprintf("messages references non-local part %n; cannot handle non-local parts", $hr);
	$hr = substr($hr, 4);
	if (!exists $parts.$hr)
	    throw "SOAP-MESSAGE-ERROR", sprintf("message references non-existent part %n", $hr);
	$xmldata = $parts.$hr.body;
    }
    
    private static substHref(reference $xmldata, hash $parts) {
	foreach my string $k in (keys $xmldata) {
	    if (exists $xmldata.$k."^attributes^".href)
		WSDLLib::processHref(\$xmldata.$k, $xmldata.$k."^attributes^".href, $parts);
	    else if (exists $xmldata.$k.href)
		WSDLLib::processHref(\$xmldata.$k, $xmldata.$k.href, $parts);
	    else if ($xmldata.$k.typeCode() == NT_LIST) {
		foreach my any $e in (\$xmldata.$k)
		    WSDLLib::substHref(\$e, $parts);
	    }
	    else if ($xmldata.$k.typeCode() == NT_HASH)
		WSDLLib::substHref(\$xmldata.$k, $parts);
	}
    }
}

#! base class with helper methods for XSD data processing
public class WSDL::XSDBase {
    /*
    static private hash doType(string $t) {
	#printf("DEBUG: XSDBase::doType(%y)\n", $t);
	my (*string $ns, *string $type) = $t =~ x/(\w+):(\w+)/;
	return !exists $type ? ("val": $t) : ("ns": $ns, "val": $type);
    }
    */

    static removeNS(reference $v) {
        foreach my hash $h in (\$v) {
            foreach my string $k in ($h.keyIterator()) {
                my (*string $ns, *string $name) = $k =~ x/(\w+):(\w+)/;
                if ($ns) {
                    if ($h.$k.typeCode() == NT_HASH)
                        $h.$k.ns = $ns;
                    if ($h.$name) {
                        my softlist $l = $h.$name;
                        $l += remove $h.$k;
                        $h.$name = $l;
                    }
                    else
                        $h.$name = remove $h.$k;
                }
            }
        }
    }

    static removeNS2(reference $v) {
        foreach my hash $h in (\$v) {
            foreach my string $k in ($h.keyIterator()) {
                my (*string $ns, *string $name) = $k =~ x/(\w+):(\w+)/;
                if ($ns) {
                    if ($h.$k.typeCode() == NT_HASH)
                        $h.$k.".ns" = $ns;
                    if ($h.$name) {
                        my softlist $l = $h.$name;
                        $l += remove $h.$k;
                        $h.$name = $l;
                    }
                    else
                        $h.$name = remove $h.$k;
                }
            }
        }
    }
}

#! base class for XSD data classes
public class WSDL::XSDData inherits WSDL::XSDBase {
    any getValue(*hash $mrh, any $val) {
	if (exists $val."^attributes^".href) {
	    my string $href = substr($val."^attributes^".href, 1);
	    
	    if (!exists $mrh.mrh.$href)
		throw "INVALID-REFERENCE", sprintf("multiRef id=%n does not exist", $href);
	    
	    return $mrh.mrh.$href;
	}
	return $val;	
    }
}

#! base class for XSD classes with a "name" attribute
public class WSDL::XSDNamedData inherits WSDL::XSDData {
    public {
        # name of object
        string $.name;
        #! input namespace prefix (if any given)
        *string $.ns;
    }

    constructor(string $name, string $ns) {
        $.name = $name;
        $.ns = $ns;
    }

    constructor(reference $e) {
	WSDL::XSDBase::removeNS(\$e);

        my *string $name = $e."^attributes^".name;
        $.name = exists $name ? $name : "<unnamed type>";
    }

    string getName() {
        return $.name;
    }

    *string getInputNamespacePrefix() {
	return $.ns;
    }
}

public class WSDL::XSDAbstractType inherits WSDL::XSDNamedData {
    public {
        #! reference to namespaces
        Namespaces $.nsc;
        
        #! my namespace output prefix
        string $.ons;
    }

    constructor(reference $e, Namespaces $nsc) : XSDNamedData(\$e) {
        $.nsc = $nsc;
        $.resolveNamespace();
    }

    constructor(string $name, string $ns, Namespaces $nsc) : XSDNamedData($name, $ns) {
        $.nsc = $nsc;
        $.resolveNamespace();
    }

    private resolveNamespace() {
        if (!$.ns) {
            my *string $tns = $.nsc.getTargetNamespaceUri();
            if (!$tns)
                throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace for %s %y was not given and there is no current target namespace", $self.className(), $.name);
            $.ons = $.nsc.getOutputNamespacePrefix($tns);
        }
        else
            $.ons = $.nsc.translateOutputNamespacePrefix($.ns);
        #printf("DEBUG: type %y ns: %y ons: %y\n", $.name, $.ns, $.ons);
    }

    checkExtends(XSDAbstractType $t, string $ename) {
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible", $.name, $ename, $t.name);
    }

    string getNameWithNS() {
        return $.ons + ":" + $.name;
    }

    bool required() {
        return True;
    }

    string getOutputNamespacePrefix() {
        return $.ons;
    }

    abstract any serialize(any $val, *softbool $omit_type, *softbool $omit_ns);
    abstract any deserialize(string $en, *hash $types, *hash $mrh, any $val);
}

#! class for XSD base types
public class WSDL::XSDBaseType inherits WSDL::XSDAbstractType {
    public {
    }

    constructor(string $t, Namespaces $nsc) : XSDAbstractType($t, "xsd", $nsc) {
    }

    any serialize(any $val, *softbool $omit_type, *softbool $omit_ns) {
	my *string $type;
	# set type according to Qore type if xsd type is anyType
	if ($.name == "anyType") {
	    # we have to specify the type in this case
	    $omit_type = False;
	    $type = any_type_map{type($val)};
	    if (!$type)
		throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize xsd type anyType from Qore type %y", type($val));
	}
	else {
	    $type = $.name;
	}

	switch ($type) {
	    case "byte": {
		my int $v = int($val);
		if (($v & 0xff) != $v)
		    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", $v, $type);
		break;
	    }

	    case "short": {
		my int $v = int($val);
		if ($v < RANGE_SHORT[0] || $v > RANGE_SHORT[1])
		    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", $v, $type);
		break;
	    }

	    case "int": {
		my int $v = int($val);
		if ($v < RANGE_INT[0] || $v > RANGE_INT[1])
		    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", $v, $type);
		break;
	    }

	    case "unsignedByte": {
		my int $v = int($val);
		if (($v & 0xff) != $v)
		    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", $v, $type);
	        if ($v < 0)
		    throw SOAP_SERIALIZATION_ERROR, sprintf("type %n does not accept negative values (value supplied: %d)", $type, $v);
		break;
	    }

	    case "unsignedShort": {
		my int $v = int($val);
		if ($v < 0 || $v > RANGE_SHORT[1])
		    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", $v, $type);
		break;
	    }

	    case "unsignedInt": {
		my int $v = int($val);
		if ($v < 0 || $v > RANGE_INT[1])
		    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", $v, $type);
		break;
	    }

	    case "unsignedLong": {
		my int $v = int($val);
	        if ($v < 0)
		    throw SOAP_SERIALIZATION_ERROR, sprintf("type %n does not accept negative values (value supplied: %d)", $type, $v);
		break;
	    }

	    case "positiveInteger":
	        if ($val <= 0)
		    throw SOAP_SERIALIZATION_ERROR, sprintf("type %n only accepts positive values (value supplied: %d)", $type, $val);
	        break;

	    case "date":
		$val = format_date("YYYY-MM-DD", date($val));
	        break;

	    case "dateTime":
		$val = format_date("YYYY-MM-DDTHH:mm:SS", date($val));
	        break;

	    case "boolean":
		$val = $val ? "true" : "false";
	        break;

	    case "time":
		$val = format_date("hh:mm:ss.ms", date($val));
	        break;

	    case "base64Binary":
		$val = makeBase64String($val);
	        break;

	    case "hexBinary":
		$val = makeHexString($val);
	        break;
	}

	#printf("DEBUG: FORCE: type=%n, nstype=%n, val=%n\n", $type, $.nstype, $val);
	if ($omit_type == "ns")
	    return ("^attributes^": (
                        "xmlns:xsi": XSI_NS,
                        "xsi:type": sprintf("%s:%s", $.ons, $type),
                    ),
                    "^value^": $val,
            );
        if ($omit_type)
            return $val;
        else
            return (
                "^attributes^": (
                    "xsi:type": sprintf("%s:%s", $.ons, $type),
                ),
                "^value^": $val,
            );
    }

    any deserialize(string $en, *hash $types, *hash $mrh, any $val) {
	my string $type;
	if ($val.typeCode() == NT_HASH) {
	    $type = $val."^attributes^"."xsi:type";
	    my string $t = ($type =~ x/\w+:(\w+)/)[0];
	    if (exists $t)
		$type = $t;
		
	    if ($.name != "anyType" && $type != $.name)
		throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting base type %n, got %n", $.name, $val."^attributes^"."xsi:type");
	    if (exists $val."^value^")
		$val = $val."^value^";
	}
	else
	    $type = $.name;

	switch ($type) {
	    case "string": 
	    case "anyURI":
	    # note that we do not convert xsd:integer to a qore integer to avoid losing precision
	    case "integer":
		return $val;
	    
	    case "byte":
		$val = int($val);
		if (($val & 0xff) != $val)
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %n", $val, $.name);
	        return $val;

	    case "short":
		$val = int($val);
		if ($val < RANGE_SHORT[0] || $val > RANGE_SHORT[1])
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %n", $val, $.name);
	        return $val;

	    case "int":
		$val = int($val);
		if ($val < RANGE_INT[0] || $val > RANGE_INT[1])
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %n", $val, $.name);
	        return $val;

	    case "long":
		return int($val);

	    case "unsignedByte":
		$val = int($val);
		if (($val & 0xff) != $val)
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %n", $val, $.name);
	        if ($val < 0)
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %n does not accept negative values (value supplied: %d)", $.name, $val);
	        return $val;

	    case "unsignedShort":
		$val = int($val);
		if (($val & 0xffff) != $val)
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %n", $val, $.name);
	        if ($val < 0)
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %n does not accept negative values (value supplied: %d)", $.name, $val);
	        return $val;

	    case "unsignedInt":
		$val = int($val);
		if (($val & 0xffffffff) != $val)
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %n", $val, $.name);
	        if ($val < 0)
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %n does not accept negative values (value supplied: %d)", $.name, $val);
	        return $val;

	    case "unsignedLong":
	        if ($val < 0)
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %n does not accept negative values (value supplied: %d)", $.name, $val);
		return int($val);

	    case "positiveInteger":
	        if ($val <= 0)
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %n only accepts positive values (value supplied: %d)", $.name, $val);
		return int($val);

	    case "date":
	        # remove dashes from date
		$val =~ s/-//g;
		return date($val);
		
	    case "dateTime":
		return date(substr($val, 0, 4) + substr($val, 5, 2) + substr($val, 8, 2) + 
			    substr($val, 11, 2) + substr($val, 14, 2) + substr($val, 17, 2));
    
	    case "time":
		return date("19700101" + substr($val, 0, 2) + substr($val, 3, 2) + substr($val, 6, 2)) +
		       milliseconds(substr($val, 9, 3));

	    case "boolean":
		if ($val =~ /true/i)
		    return True;
	        if ($val =~ /false/i)
		    return False;
	        return boolean($val);
		
	    case "decimal":
		return float($val);

	    case "base64Binary":
		return parseBase64String($val);

	    case "hexBinary":
		return parseHexString($val);

	    default: {
		if ($.name == "anyType")  {
		    if (exists $types.$type)
			return $types.$type.deserialize($en, $types, $mrh, $val);
		}
		throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %n", $.name);
	    }
	}
    }
}

#! class for XSD array types; currently only supports "binary"; used, for example with HTTP MultiPart messages
public class WSDL::XSDArrayType inherits WSDL::XSDAbstractType {
    constructor(string $t, Namespaces $nsc) : XSDAbstractType($t, "ns1", $nsc) {
	if ($t != "binary")
	    throw "XSD-ARRAYTYPE-ERROR", sprintf("don't know how to handle arrays of type %n", $t);
    }

    any serialize(any $val, *softbool $omit_type, *softbool $omit_ns) {
	switch ($.name) {
	    case "binary": {
		my int $t = $val.typeCode();
		if ($t === NT_STRING)
		    $val = binary($val);
		else if ($t !== NT_BINARY)
		    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize type %n from type %n; requires string or binary", $.name, $t);
                return $val;
	    }

	    default: {
		throw SOAP_SERIALIZATION_ERROR, sprintf("don't know how to handle type %n", $.name);
	    }
	}
    }

    any deserialize(string $en, *hash $types, *hash $mrh, any $val) {
	switch ($.name) {
	    case "binary": {
		if ($val.typeCode() != NT_BINARY)
		    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize type %n from type %n; requires binary", $.name, $val.typeName());
		return $val;
	    }

	    default: {
		throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %n", $.name);
	    }
	}
    }
}

#! XSD element class
public class WSDL::XSDElement inherits WSDL::XSDNamedData {
    public {
        any $.type;
        int $.minOccurs = 1;
        int $.maxOccurs = 1;
        bool $.nillable = False;
    }

    constructor(hash $e, Namespaces $nsc, *XSDAbstractType $type, XSDLateResolverHelper $unresolved) : XSDNamedData(\$e) {
	if ($type) {
	    $.type = $type;
	    return;
	}

	my any $a = $e."^attributes^";

	if (exists $a.minOccurs)
	    $.minOccurs = int($a.minOccurs);

	if (exists $a.maxOccurs)
	    if ($a.maxOccurs == "unbounded")
	        $.maxOccurs = -1;
	    else
		$.maxOccurs = int($a.maxOccurs);

	if ($.maxOccurs != -1 && $.minOccurs > $.maxOccurs)
	    throw "XSD-ELEMENT-ERROR", sprintf("minOccurs (%d) > maxOccurs (%d) for element %s", $.minOccurs, $.maxOccurs, $.name);

	if ($a.nillable == "true")
	    $.nillable = True;

	if ($a.type) {
	    $.type = $nsc.doType($a.type);

	    # add self to unresolved list if element type cannot be resolved
	    if (!($.type instanceof XSDAbstractType)) {
		#printf("DEBUG: self=%n\n", $self);
		$unresolved.add($self);
	    }
	}
	else if ($e.simpleType)
	    $.type = new XSDSimpleType($e.simpleType, $nsc, $unresolved);
	else if ($e.hasKey("complexType")) {
	    $.type = new XSDComplexType($e.complexType, $nsc, $unresolved);
            if (!$.type.required() && !exists $a.minOccurs)
                $.minOccurs = 0;
        }
    }

    bool required() {
        return !$.nillable && $.minOccurs && (($.type instanceof XSDAbstractType && $.type.required()) | True);
    }
    
    any serialize(any $h, *softbool $omit_type, *softbool $omit_ns, string $key, string $typename, reference $ons) {
        return $.serializeAsIntern($.type, $h, $omit_type, $omit_ns, $key, $typename, \$ons);
    }

    any serializeAs(XSDAbstractType $type, any $h, *softbool $omit_type, *softbool $omit_ns, string $key, string $typename, reference $ons) {
        $type.checkExtends($.type, $.name);
        return $.serializeAsIntern($type, $h, $omit_type, $omit_ns, $key, $.name, $ons);
    }

    private any serializeAsIntern(XSDAbstractType $type, any $h, *softbool $omit_type, *softbool $omit_ns, string $key, string $typename, reference $ons) {
        #printf("DEBUG: XSDElement::serializeAsIntern() name: %y h: %y key: %y typename: %y\n", $.name, $h, $key, $typename);
        $ons = $type.getOutputNamespacePrefix();

	if (!exists $h) {
	    if (!$.minOccurs)
                return;

            if ($.nillable) {
                my hash $rh = ("xsi:nil" : "true");
                if (!$omit_type)
                    $rh += ("xsi:type" : $type.getNameWithNS());
                return ("^attributes^" : $rh);
            }

            if (!$type.required())
                return;
            
            throw SOAP_SERIALIZATION_ERROR, sprintf("missing element %y value for %s.%s (minOccurs=%d, type %n)", $.name, $typename, $key, $.minOccurs, $type.getName());
	}

        my *hash $pf;
        if ($omit_type && $type != $.type)
            $pf = ("^attributes^": ("xsi:type": $omit_ns ? $type.getName() : $type.getNameWithNS()));

	if ($h.typeCode() == NT_LIST) {
	    if ($h.size() == 1)
		$h = $h[0];
	    else {
		if ($.maxOccurs == 1)
		    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y of type %y from a list because maxOccurs = 1", $.name, $type.getName());
		if (elements $h > $.maxOccurs && $.maxOccurs > 0)
		    throw SOAP_SERIALIZATION_ERROR, sprintf("list for element %y of type %y has %d element%s, but maxOccurs = %d", $.name, $type.getName(), elements $h, elements $h == 1 ? "" : "s", $.maxOccurs);
		if (elements $h < $.minOccurs)
		    throw SOAP_SERIALIZATION_ERROR, sprintf("list for element %y of type %y has %d element%s, but minOccurs = %d", $.name, $type.getName(), elements $h, elements $h == 1 ? "" : "s", $.minOccurs);
		
		my list $l = ();
		foreach my any $e in ($h) {
		    $l += ($pf + $type.serialize($e, $omit_type, $omit_ns));
		}
                return $l;
	    }
	}
	if ($.minOccurs > 1)
	    throw SOAP_SERIALIZATION_ERROR, sprintf("only one element passed to element %y of type %y, but minOccurs = %d", $.name, $type.getName(), $.minOccurs);

	#printf("DEBUG: element %y type %s: %y omit_type: %y omit_ns: %y h: %y\n", $.name, $type.className(), $type.name, $omit_type, $omit_ns, $h);
        return ($pf + $type.serialize($h, $omit_type, $omit_ns));
    }

    any deserialize(*hash $types, *hash $mrh, any $val) {
	my any $a = $val."^attributes^";
	WSDL::XSDBase::removeNS(\$a);
	
	if (!exists $val || $a.nil == "true" && !$mrh.body.hasKey($.name)) {
	    if ($.nillable || !$.minOccurs)
		return;
	    throw SOAP_DESERIALIZATION_ERROR, sprintf("NOTHING passed for element %y, but nillable=False and minOccurs=%d", $.name, $.minOccurs);
	}

	if ($val.typeCode() == NT_LIST) {
	    my int $el = elements $val;
	    if ($.maxOccurs != -1 && $el > $.maxOccurs)
		throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, maxOccurs=%d but list is %d elements long", $.name, $.maxOccurs, $el);
	    if ($el < $.minOccurs)
		throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, minOccurs=%d but list is %d elements long", $.name, $.minOccurs, $el);

	    my list $l;
	    foreach my any $e in ($val)
		$l[elements $l] = $.type.deserialize($.name, $types, $mrh, $.getValue($mrh, $e));
	    return $l;
	}

	if ($.minOccurs > 1)
	    throw SOAP_DESERIALIZATION_ERROR, sprintf("single value passed for element %y, but minOccurs=%d", $.name, $.minOccurs);

	return $.type.deserialize($.name, $types, $mrh, $.getValue($mrh, $val));
    }
}

#! XSD simple type class
public class WSDL::XSDSimpleType inherits WSDL::XSDAbstractType {
    public {
        hash $.enum;
        any $.type;
    }

    constructor(hash $st, Namespaces $nsc, XSDLateResolverHelper $unresolved) : XSDAbstractType(\$st, $nsc) {
	#my any $a = $st."^attributes^";
	delete $st."^attributes^";

	WSDL::XSDBase::removeNS(\$st);

	if ($st.restriction) {
	    my *hash $r = $st.restriction;

	    my any $base = $r."^attributes^".base;
	    if (!$base)
		throw "XSD-SIMPLETYPE-ERROR", sprintf("missing 'base' attribute in simpleType %n restriction", $.name);

	    $.type = $nsc.doType($base);

	    # add base type to unresolved list if type cannot be resolved
	    if (!($.type instanceof XSDData))
		$unresolved.add($self);

	    WSDL::XSDBase::removeNS(\$r);
	    
	    if ($r.enumeration)
                map $.enum.($1."^attributes^".value) = True, $r.enumeration;
            #$.enum = map $1."^attributes^".value, $r.enumeration;
            /*
	    else
		throw "XSD-SIMPLETYPE-ERROR", sprintf("missing enumeration element in simpleType %n restriction", $.name);
            */
	}
	else
	    throw "XSD-SIMPLETYPE-ERROR", sprintf("missing restriction element in simpleType %n", $.name);

	#printf("DEBUG: st=%N\n", $self); exit();
    }

    any serialize(any $val, *softbool $omit_type, *softbool $omit_ns) {
	if ($.enum && !$.enum.$val)
	    throw "SOAP-SERIALIZATION-ERROR", sprintf("value %n passed to simpleType %n is not in the enumeration list (%n)", $val, $.name, $.enum.keys());

	return $.type.serialize($val, $omit_type, $omit_ns);
    }

    any deserialize(string $en, *hash $types, *hash $mrh, any $val) {
	my any $v = $.type.deserialize($en, $types, $mrh, $val);

	if ($.enum && !$.enum.$v)
	    throw "SOAP-DESERIALIZATION-ERROR", sprintf("value %n passed to simpleType %n is not in the enumeration list (%n)", $v, $.name, $.enum.keys());

	return $v;
    }
}

#! XSD complex type class
public class WSDL::XSDComplexType inherits WSDL::XSDAbstractType {
    public {
        any $.array;
        any $.restriction;
        *string $.extension;
        any $.hash_type;
        *hash $.elements;

	bool $.anyAttribute = False;

        bool $.required = False;

        # any annotated documentation
        *string $.documentation;
    }

    constructor(any $ct, Namespaces $nsc, XSDLateResolverHelper $unresolved) : XSDAbstractType(\$ct, $nsc) {
	#my any $a = $ct."^attributes^";
	delete $ct."^attributes^";

	my any $d = $ct.complexContent;
	if ($d) {
	    WSDL::XSDBase::removeNS(\$d);
	    if ($d.restriction) {
		WSDL::XSDBase::removeNS(\$d.restriction);

		my any $base = $d.restriction."^attributes^".base;

		# FIXME: handle namespace
		my (any $ns, any $tn) = $base =~ x/(\w+):(\w+)/;
		if (exists $tn) {
		    if ($tn == "Array") {
			# FIXME check that namespace is SOAP encoding
			my any $aa = $d.restriction.attribute."^attributes^";
			WSDL::XSDBase::removeNS(\$aa);
			if (!exists $aa.arrayType)
			    throw WSDL_ERROR, sprintf("cannot parse complexType restriction: %n", $d.restriction);

			# FIXME: handle multiple dimensions?
			my (any $ans, any $atn) = $aa.arrayType =~ x/(\w+):(\w+)\[\]$/;
			if (exists $atn) {
			    $.array.val = $atn;
			    $.array.ns  = $ans;
			}
			else
			    $.array.val = $aa.arrayType;
			
			delete $d.restriction.attribute;
			#printf("DEBUG: ans=%n atn=%n aa=%N\n", $ans, $atn, $aa);
			return;
		    }
		    else {
			$.restriction = $tn;
		    }
		}
		
		delete $d.restriction."^attributes^";

                $.parseData($d.restriction, $unresolved);
	    }
	    else if ($d.extension) {
		$.extension = $d.extension."^attributes^".base;

		# FIXME: check for soap encoding namespace
		$.extension =~ s/(.*:)(.*)/$2/;
		delete $d.extension."^attributes^";
		WSDL::XSDBase::removeNS(\$d.extension);

                $.parseData($d.extension, $unresolved);
	    }
	    else
		throw "XSD-COMPLEXCONTENT-ERROR", sprintf("can't parse complexContent %n information", $d.firstKey());
	}
	else if ($ct)
	    $.parseData($ct, $unresolved);
    }

    checkExtends(XSDAbstractType $t, string $ename) {
        if ($.extension == $t.name)
            return;
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible%s", $.name, $ename, $t.name, $.extension ? sprintf("; %y extends %y", $.name, $.extension) : "");
    }

    private parseData(any $d, XSDLateResolverHelper $unresolved) {
	delete $d.ns;
        if ($d.annotation) {
            my *hash $ah = remove $d.annotation;
            if ($ah.size() == 1 && $ah.firstKey() =~ /documentation$/)
                $.documentation = trim($ah.firstValue());
        }
        if (!$d)
            return;

	my list $el = keys $d;
	if (inlist("anyAttribute", $el)) {
	    $.anyAttribute = True;
	    delete $d.anyAttribute;
	    $el = keys $d;
	}

	if (elements $d > 1)
	    throw WSDL_ERROR, sprintf("%s: expecting a single element in the complexType hash, got: %n", $.name, $el);

	my string $k = $el[0];
	if ($k == "all") {
	    $.hash_type = XET_ALL;
	    WSDL::XSDBase::removeNS(\$d.all);
	    $.elements = $.parseElements($d.all.element, $unresolved);
	}
	else if ($k == "choice") {
	    $.hash_type = XET_CHOICE;
	    WSDL::XSDBase::removeNS(\$d.choice);
	    $.elements = $.parseElements($d.choice.element, $unresolved);
	}
	else if ($k == "sequence") {
	    $.hash_type = XET_SEQUENCE;
	    WSDL::XSDBase::removeNS(\$d.sequence);
	    if ($d.sequence.element)
		$.elements = $.parseElements($d.sequence.element, $unresolved);
	}
	else
	    throw "XSD-COMPLEXTYPE-ERROR", sprintf("unknown keys in %n", $d);
    }

    bool required() {
        return $.required;
    }

    private *hash parseElements(any $el, XSDLateResolverHelper $unresolved) {
	#printf("DEBUG: XSDComplexType::parseElements(%n)\n", $el);
	my hash $h;
	foreach my any $e in ($el) {
	    my XSDElement $elem($e, $.nsc, NOTHING, $unresolved);
	    $h.($elem.name) = $elem;
            if (!$.required && $elem.required())
                $.required = True;
	}
	return $h;
    }

    private *hash serializeElement(string $key, any $h, *softbool $omit_type, *softbool $omit_ns) {
        my any $e;
        my any $v = $h.$key;
        my string $ons;
        if ($v."^type^" && $v."^type^" instanceof XSDAbstractType && $v.hasKey("^val^")) {
            #printf("DBG: type: %s: %y val: %y\n", $v."^type^".className(), $v."^type^".name, $v."^val^");
            $e = $.elements.$key.serializeAs($v."^type^", $v."^val^", $omit_type, $omit_ns, $key, $.name, \$ons);
        }
        else
            $e = $.elements.$key.serialize($h.$key, $omit_type, $omit_ns, $key, $.name, \$ons);

        if ($ons != $.ons && $ons != "xsd") {
            if ($e.typeCode() != NT_HASH)
                $e = ("^value^": $e);
            $e."^attributes^" = ("xmlns": $.nsc.getOutputNamespaceUri($ons));
        }

        my hash $rv.($omit_ns ? $key : ($.ons + ":" + $key)) = $e;
        return $rv;
    }

    *hash serialize(any $h, *softbool $omit_type, *softbool $omit_ns) {
	if (exists $.array)
	    return $.array.serialize($h, $omit_type, $omit_ns);

	if ($h.typeCode() != NT_HASH)
	    throw SOAP_SERIALIZATION_ERROR, sprintf("expecting hash argument to serialize from complexType %n (got %n, type %n)", $.getName(), $h, type($h));

	my hash $rh;

	if ($.hash_type == XET_SEQUENCE || $.hash_type == XET_ALL) {
	    foreach my string $p in ($.elements.keyIterator()) {
                #printf("DEBUG element: %y (%y)\nvalue: %y\n", $p, $.elements.$p, $h.$p);
                $rh += $.serializeElement($p, $h, $omit_type, $omit_ns);
		delete $h.$p;
	    }
	    if (elements $h) {
                my any $kl = $h.size() == 1 ? $h.firstKey() : $h.keys();
		throw SOAP_SERIALIZATION_ERROR, sprintf("%n %s of type %n (valid elements: %n)", $kl, $kl.lsize() == 1 ? "is an invalid member" : "are invalid members", $.getName(), keys $.elements);
            }
	}
	else { # "choice" - union
	    if (elements $h > 1)
		throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize type %s with more than 1 member (%n)", $.getName(), keys $h);
	    my *string $key = $h.firstKey();
	    if (!$.elements.$key)
		throw SOAP_SERIALIZATION_ERROR, sprintf("%y is an invalid member of type %y", $key, $.getName());

	    # add namespace if necessary
            $rh = $.serializeElement($key, $h, $omit_type, $omit_ns);
	}
	
	if ($.name && !$omit_type)
	    $rh."^attributes^" = ( "xsi:type" : "ns1:" + $.name );
	#printf("complex type %s returning %n from %n\n", $.name, $rh, $h);
	return $rh;
    }
    
    *hash deserialize(string $en, *hash $types, *hash $mrh, any $oval) {
	if (exists $.array)
	    return $.array.deserialize($en, $types, $mrh, $oval);

        if (!exists $oval) {
            if (!$.required)
                return;
        }

	if ($oval.typeCode() != NT_HASH)
	    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y type %y from qore type %y (expecting hash)", $en, $.getName(), type($oval));

	my hash $rh;

        my hash $val = $oval;
	my any $attr = $val."^attributes^";
	delete $val."^attributes^";

	# ensure types match
	my any $tn = $attr."xsi:type";
	if (exists $tn) {
	    my (any $ns, any $name) = $tn =~ x/(.*):(.*)/;
	    if (exists $name)
		$tn = $name;
	    if ($tn != $.name) {
                #printf("DEBUG: %y: %s\n", $tn, $types.$tn ? $types.$tn.className() : "n/a");
                # check for compatible extension
                if ($types.$tn) {
                    $types.$tn.checkExtends($self, $en);
                    return $types.$tn.deserialize($en, $types, $mrh, $oval);
                }
                
		throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting ComplexType type %n for element %y, got %n", $.getName(), $en, $tn);
            }
	}

	WSDL::XSDBase::removeNS2(\$val);

	#my any $ns = $val.".ns"; 
        $val -= ".ns";

	if ($.hash_type == XET_SEQUENCE || $.hash_type == XET_ALL) {
	    foreach my string $p in ($.elements.keyIterator()) {
		#printf("element %n\n", $p);
		$rh.$p = $.elements.$p.deserialize($types, $mrh, $.getValue($mrh, $val.$p));
		delete $val.$p;
	    }
	    delete $val."^attributes^";
	    if (elements $val)
		throw SOAP_DESERIALIZATION_ERROR, sprintf("invalid element %n passed in type %n for element %y (expecting %y)", (keys $val)[0], $.getName(), $en, keys $.elements);
	}
	else { # "choice" - union
	    my any $kl = keys $val;
	    if (elements $kl > 1)
		throw SOAP_DESERIALIZATION_ERROR, sprintf("too many elements supplied for union type %y for element %y (%y)", $.getName(), $en, $kl);
	    $kl = $kl[0];
	    if (!exists $.elements.$kl)
		throw SOAP_DESERIALIZATION_ERROR, sprintf("element %y is not a valid element for union type %y for element %y", $kl, $.getName(), $en);

	    $rh.$kl = $.elements.$kl.deserialize($types, $mrh, $.getValue($mrh, $val.$kl));
	}
	return $rh;
    }
}

#! web service operation class
public class WSDL::WSOperation inherits WSDL::XSDNamedData {
    public {
        WSMessage $.input;
        WSMessage $.output;
        *string $.input_name;
        *string $.output_name;
	any $.types;

        Namespaces $.nsc;

	bool $.usedocns = False;
        *string $.soapAction;
        *string $.request_name;
        any $.in;
        any $.out;
        bool $.docstyle = False;
	
	# info about soap header requirements
	hash $.iheader;
	hash $.oheader;
    }

    constructor(any $p, *hash $types, Namespaces $nsc, *hash $messages, bool $usedocns = False) : XSDNamedData(\$p) {
	$.types = $types;
        $.nsc = $nsc;
	$.usedocns = $usedocns;

	my hash $msghash = $.processNSValue($p.input."^attributes^");

	my *WSMessage $msg = $messages.($msghash.message.val);
	if (!$msg)
	    throw WSDL_ERROR, sprintf("missing definition for input message %y required by operation %y", $msghash.name.val, $.name);
	$.input = $msg;

        #printf("DBG: WSOperation::constructor() name: %y msghash: %y\n", $.name, $msghash);
        if ($msghash.name)
            $.input_name = $msghash.name.val ? $msghash.name.val : $msghash.name;
        
	if ($p.output) {
	    $msghash = $.processNSValue($p.output."^attributes^");

	    $msg = $messages.($msghash.message.val);
	    if (!exists $msg)
		throw WSDL_ERROR, sprintf("missing definition for output message %y required by operation %y", $msghash.name.val, $.name);

	    $.output = $msg;
            if ($msghash.name)
                $.output_name = $msghash.name.val ? $msghash.name.val : $msghash.name;
	}
	
	my *string $op_ns = $.nsc.getTargetNamespaceUri();
	if ($op_ns && $op_ns !~ /\/$/)
	    $op_ns += "/";
	$.soapAction = $op_ns ? $op_ns + $.name : $.name;
    }

    setDocStyle(reference $idocmap) {
	$.docstyle = True;

        foreach my string $key in ($.input.args.keyIterator()) {
            my string $element = $.input.args.$key.element.name;
            $idocmap.$element = $.input.args.$key.element;
            if (!$.request_name)
                $.request_name = $element;
        }
    }	

    setTopLevelRequestElement(string $name) {
	$.request_name = $name;
    }

    string getTopLevelRequestName() {
	return $.request_name ? $.request_name : $.name;
    }

    #! serializes a request to an XML string for the operation
    /** @param h the request to serialize
	@param header optional soap header info to serialize if required (ex: authorization info)
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used

	@return a hash with keys:
	- \c body: XML string in the SOAP request format
	- \c hdr: hash of HTTP headers
	*/
    hash serializeRequest(any $h, *hash $header, *string $enc, *hash $nsh) {
	# setup namespaces for SOAP envelope
	my hash $rh = $.nsc.isSoap12() ? WSDL::ENVELOPE_12_NS : WSDL::ENVELOPE_11_NS;

	# ns1 (( "^attributes^" : 
	$rh."soapenv:Envelope"."^attributes^" += $.nsc.getOutputNamespaceHash($nsh);

        #printf("DEBUG header: %y\n", $header);

        if ($header) {
            if ($.iheader) {
                my hash $hh.($.iheader.part) = $header;
                $rh."soapenv:Envelope"."soapenv:Header" = $.iheader.msg.serializeDocument($.iheader.part, NOTHING, NOTHING, $hh, $.usedocns);
            }
            else {
                $rh."soapenv:Envelope"."soapenv:Header" = $header;
            }
        }

	my MultiPartRelatedMessage $mpm;
	# do we have mime/multipart input format?
	if (exists $.in.multipart)
	    $mpm = new MultiPartRelatedMessage();

	#printf("DEBUG: docstyle=%n\n", $.docstyle);
	if ($.docstyle)
	    $rh."soapenv:Envelope"."soapenv:Body" = $.input.serializeDocument(NOTHING, $.in, $mpm, $h, $.usedocns);
	else {
            my string $mname = $.input_name ? $.input_name : $.name;
	    $rh."soapenv:Envelope"."soapenv:Body" = $.input.serialize($.in, $mpm, $mname, $h);
        }

	my string $body = HAVE_LIBRARY_DEBUGGING ? makeFormattedXMLString($rh, $enc) : makeXMLString($rh, $enc);

	if ($mpm) {
	    $mpm.splicePart($body, sprintf("<%s>", $.in.body.parts), $.nsc.isSoap12() ? MimeTypeSoapXml : MimeTypeXml);
	    
	    my hash $rv = $mpm.getMsgAndHeaders();
	    if ($.soapAction) {
		if ($.nsc.isSoap12())
		    $rv.hdr."Content-Type" += sprintf(";action=%s", $.soapAction);
		$rv.hdr += ("SOAPAction" : $.soapAction);
	    }

            $rv.hdr."Content-Type" += sprintf(";charset=%s", exists $enc ? $enc : get_default_encoding());
	    return $rv;
	}

	my string $ct;
	if ($.nsc.isSoap12()) {
	    $ct = MimeTypeSoapXml;
	    if ($.soapAction)
		$ct += sprintf(";action=%s", $.soapAction);
	}
	else
	    $ct = MimeTypeXml;

        $ct += sprintf(";charset=%s", exists $enc ? $enc : get_default_encoding());

	my hash $rv = ("hdr": ("Content-Type": $ct),
                       "body": $body );

	if ($.soapAction)
	    $rv.hdr += ("SOAPAction": $.soapAction);

	return $rv;
    }

    #! serializes a SOAP response to an XML string for the operation
    /** @param h the response to serialize
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @return a hash with keys:
        - \c body: XML string in the SOAP request format
        - \c hdr: hash of HTTP headers
    */
    hash serializeResponse(any $h, *hash $header, *string $enc, *hash $nsh) {
	# setup namespaces for SOAP envelope
	my hash $rh = $.nsc.isSoap12() ? WSDL::ENVELOPE_12_NS : WSDL::ENVELOPE_11_NS;

	$rh."soapenv:Envelope"."^attributes^" += $.nsc.getOutputNamespaceHash($nsh);

        if ($header) {
            if ($.oheader) {
                my hash $hh.($.oheader.part) = $header;
                $rh."soapenv:Envelope"."soapenv:Header" = $.oheader.msg.serializeDocument($.oheader.part, NOTHING, NOTHING, $hh, $.usedocns);
            }
            else {
                $rh."soapenv:Envelope"."soapenv:Header" = $header;
            }
        }

	my MultiPartRelatedMessage $mpm;
	# do we have mime/multipart output format?
	if (exists $.out.multipart)
	    $mpm = new MultiPartRelatedMessage();

	#printf("DEBUG: docstyle=%n\n", $.docstyle);
	if ($.docstyle)
	    $rh."soapenv:Envelope"."soapenv:Body" = $.output.serializeDocument(NOTHING, $.out, $mpm, $h, $.usedocns);
	else {
            my string $mname = $.input_name ? $.input_name : $.name + "Response";
	    $rh."soapenv:Envelope"."soapenv:Body" = $.output.serialize($.out, $mpm, $mname, $h);
        }

	my string $body = HAVE_LIBRARY_DEBUGGING ? makeFormattedXMLString($rh, $enc) : makeXMLString($rh, $enc);

	my string $ct = $.nsc.isSoap12() ? MimeTypeSoapXml : MimeTypeXml;
	if (exists $mpm) {
	    $mpm.splicePart($body, sprintf("<%s>", $.out.body.parts), $ct);
	    return $mpm.getMsgAndHeaders();
	}

        $ct += sprintf(";charset=%s", exists $enc ? $enc : get_default_encoding());

	return ( "hdr"  : ( "Content-Type" : $ct ),
		 "body" : $body );
    }

    private list processMultiRef(hash $body) {
	# setup message info hash and multiRef lookup hash key, if any are present
	my hash $mrh = (
            # save original msg body hash
            "body": $body,
            );
        # remove namespacr prefixes from body element keys
        WSDL::XSDBase::removeNS2(\$mrh.body);

	if ($body.multiRef) {
	    foreach my any $mr in ($body.multiRef)
		$mrh.mrh.($mr."^attributes^".id) = $mr;

	    # resolve interior references to multiRefs
	    foreach my string $id in ($mrh.mrh.keyIterator()) {
		foreach my string $key in ($mrh.mrh.$id.keyIterator()) {
		    if ($key == "^attributes^")
			continue;

		    #printf("multiRef id=%n key=%n val=%n\n", $id, $key, $mrh.mrh.$id.$key);

		    if ($mrh.mrh.$id.$key.typeCode() == NT_LIST) {
			foreach my any $e in (\$mrh.mrh.$id.$key) {
			    my any $href = substr($e."^attributes^".href, 1);
			    if (exists $href) {
				if (!exists $mrh.mrh.$href)
				    throw "INVALID-MULTIREF", sprintf("multiRef id=%n does not exist", $href);
				$e = $mrh.mrh.$href;
			    }
			}
		    }
		    else if ($mrh.mrh.$id.$key.typeCode() == NT_HASH) {
			my any $href = substr($mrh.mrh.$id.$key."^attributes^".href, 1);
			if (exists $href) {
			    if (!exists $mrh.mrh.$href)
				throw "INVALID-MULTIREF", sprintf("multiRef id=%n does not exist", $href);
			    $mrh.mrh.$id.$key = $mrh.mrh.$href;
			}
		    }
		}
	    }

	    delete $body.multiRef;
	}
	#printf("mrh=%N\n", $mrh.mrh);
	#printf("operation=%N\n", $self); 

	# remove namespace tags from element names
	WSDL::XSDBase::removeNS2(\$body);
        remove $body.".ns";

	return ($mrh, $body);
    }

    #! parses a hash representing a parsed XML request (parsed with parseXMLAsData()) for the operation and returns the corresponding Qore data structure
    /** @param o the parsed XML request (parsed with parseXMLAsData()) for the operation
    @return the Qore data structure corresponding to the request data
    */
    any deserializeRequest(hash $o) {
	WSDL::XSDBase::removeNS(\$o);
	WSDL::XSDBase::removeNS(\$o.Envelope);

	my hash $body = $o.Envelope.Body;

	my (*hash $mrh, hash $msg) = $.processMultiRef($body);

	#my any $ns = $msg.".ns";
	$msg -= ("ns", ".ns");

        if ($.docstyle)
            return $.input.deserializeDocument($.types, $mrh, $msg);

        my string $mname = $.input_name ? $.input_name : $.name;
        if (!$msg.$mname)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("missing input message name %y as top-level element; got elements: %y", $mname, keys $msg);
        $msg = remove $msg.$mname;
        XSDBase::removeNS2(\$msg);
        remove $msg.".ns";

	return $.input.deserialize($.types, $mrh, $msg);
    }

    #! parses a hash representing a parsed XML response (parsed with parseXMLAsData()) for the operation and returns the corresponding Qore data structure
    /** @param o the parsed XML response (parsed with parseXMLAsData()) for the operation
    @return the Qore data structure corresponding to the response data
    */
    any deserializeResponse(hash $o) {
	WSDL::XSDBase::removeNS2(\$o);
	WSDL::XSDBase::removeNS2(\$o.Envelope);

	my hash $body = $o.Envelope.Body;

	my (*hash $mrh, hash $msg) = $.processMultiRef($body);

	# check for Soap Fault, if so raise an exception immediately with the fault info
	WSDL::XSDBase::removeNS2(\$body);

	if ($body.Fault) {
	    WSDL::XSDBase::removeNS(\$body.Fault);
            delete $body.Fault.".ns";
	    if ($.nsc.isSoap12()) {
		WSDL::XSDBase::removeNS(\$body.Fault.Code);
		WSDL::XSDBase::removeNS(\$body.Fault.Reason);
		my string $desc = sprintf("The following fault response was received from the server: code: %y", $body.Fault.Code.Value);
		my any $sc = $body.Fault.Code.Subcode;
		while (exists $sc) {
		    WSDL::XSDBase::removeNS(\$sc);
		    $desc += sprintf(", subcode: %y", $sc.Value);
		    $sc = $sc.Subcode;
		}
		foreach my any $rn in ($body.Fault.Reason.Text) {
		    $desc += sprintf(", text: %y", $rn);
		}
		
		throw "SOAP-SERVER-FAULT-RESPONSE", $desc, $body.Fault;
	    }
	    else {
		my string $desc = sprintf("The following fault response was received from the server: code: %y", $body.Fault.faultcode);
		if (exists $body.Fault.faultstring)
		    $desc += sprintf(", faultstring: %y", $body.Fault.faultstring);
		if (exists $body.Fault.desc)
		    $desc += sprintf(", desc: %y", $body.Fault.desc);
		
		throw "SOAP-SERVER-FAULT-RESPONSE", $desc, $body.Fault;
	    }
	}

        if ($.docstyle)
            return $.output.deserializeDocument($.types, $mrh, $msg);

        my string $mname = $.input_name ? $.input_name : $.name + "Response";
        if (!$msg.$mname)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("missing output message name %y as top-level element; got elements: %y", $mname, keys $msg);
        $msg = remove $msg.$mname;
        XSDBase::removeNS2(\$msg);
        $msg -= (".ns", "ns");

        return $.output.deserialize($.types, $mrh, $msg);
    }

    private hash processNSValue(hash $h) {
	foreach my string $k in (keys $h) {
	    my (*string $ns, *string $name) = $h.$k =~ x/(\w+):(\w+)/;
	    if (!$name)
		$h.$k.val = $h.$k;
	    else {
		$h.$k.ns = $ns;
		$h.$k.val = $name;
	    }
	}
	return $h;
    }

    #! returns True if the operation is a SOAP 1.2 operation
    /** @return True if the operation is a SOAP 1.2 operation
    */
    bool isSoap12() {
	return $.nsc.isSoap12();
    }

    #! returns the target namespace for the operation
    /** @return the target namespace for the operation
    */
    string getTargetNS() {
	return $.nsc.getTargetNamespaceUri();
    }

    setOutputMultipart(any $v) {
	$.out.multipart = $v;
	$.out.parts = ();
    }

    private parsePart(reference $msg, any $part) {
	WSDL::XSDBase::removeNS(\$part);
	#my any $a = $part."^attributes^";
	$part -= "^attributes^";

	if (exists $part.body) {
	    my any $pa = $part.body."^attributes^";
	    if ($pa.use != "literal")
		throw WSDL_ERROR, sprintf("unsupported body part without use=\"literal\": %n", $part.body);
	    $msg.body = $pa;
	}
	else if (exists $part.content) {
	    foreach my any $c in ($part.content) {
		my any $pa = $c."^attributes^";
		my any $name = $pa.part;
		if (!exists $name)
		    throw WSDL_ERROR, sprintf("unsupported content part without part attribute: %n", $c);
		my any $type = $pa.type;
		if (!exists $type)
		    throw WSDL_ERROR, sprintf("unsupported content part without type attribute: %n", $c);

		if (!exists $msg.parts.$name)
		    $msg.parts.$name = $type;
		else {
		    if ($msg.parts.$name.typeCode() != NT_LIST)
			$msg.parts.$name = list($msg.parts.$name);
		    $msg.parts.$name += $type;
		}
	    }
	}
	else
	    throw WSDL_ERROR, sprintf("cannot parse part: %n", $part);

	#printf("DEBUG: part: %N\nmsg=%N\n", $part, $msg);#exit();
    }

    addOutputPart(any $part) {
	if (!exists $.out.multipart)
	    throw WSDL_ERROR, sprintf("WSOperation::addOutputPart(): internal error: cannot add a part to a non-multipart message; part=%n", $part);

	$.parsePart(\$.out, $part);
    }

    setInputMultipart(any $v) {
	$.in.multipart = $v;
	$.in.parts = ();
    }

    addInputPart(any $part) {
	if (!exists $.in.multipart)
	    throw WSDL_ERROR, sprintf("WSOperation::addInputPart(): internal error: cannot add a part to a non-multipart message; part=%n", $part);

	$.parsePart(\$.in, $part);
    }

    setInputHeader(string $part, WSMessage $msg, bool $encoded) {
        # FIXME: additional header parts are ignored!!!
        if (!$.iheader)
            $.iheader = ("part": $part, "msg": $msg, "encoded": $encoded);
    }
}

#! web service message class
public class WSDL::WSMessage inherits WSDL::XSDNamedData {
    public {
        hash $.args;
        # part map; maps element names to part names
        hash $.pmap;
        bool $.encoded = False;

        # keep a reference to Namespaces
        Namespaces $.nsc;
    }

    constructor(hash $m, *hash $element_map, Namespaces $nsc) : XSDNamedData(\$m) {
        $.nsc = $nsc;

	#printf("DEBUG: WSMessage::constructor() m=%n element_map: %n\n", $m, $element_map);

	$.name = $m."^attributes^".name;
	foreach my any $p in ($m.part) {
	    my any $arg = $p."^attributes^";
	    if ($arg.element) {
		my (*string $ns, *string $name) = $arg.element =~ x/(\w+):(\w+)/;
		if (!$name)
		    $name = $arg.element;

                if ($arg.name && $arg.name != $name)
                    $.pmap.$name = $arg.name;

		if (!$element_map.$name) {
		    #printf("DEBUG: WSMessage::constructor() message %n element %n (%n)\n", $.name, $arg.element, keys $element_map);
		    throw WSDL_ERROR, sprintf("message %y references unknown element %y (known elements: %y)", $.name, $name, $element_map.keys());
		}
		$.args.($name).element = $element_map.$name;
	    }
	    else {
		$.args.($arg.name) = $arg;
		$.args.($arg.name).type = $nsc.doType($p."^attributes^".type);
	    }
	}
    }

    hash serialize(any $msginfo, any $mpm, string $name, any $h) {
	my hash $rh;
	#printf("DEBUG: message %s: h=%y\n", $.name ,$h);
    
	foreach my string $k in ($.args.keyIterator()) {
            my any $v;
            if ($h.hasKey($k))
                $v = remove $h.$k;
            else if ($.pmap.$k && !exists $h.$k)
                $v = remove $h.($.pmap.$k);
            
            /*
	    if (!exists $h.$k) {
                if ($.pmap.$k && !exists $h.$k)
                    $h.$k = remove $h.($.pmap.$k);
                else
                    throw SOAP_SERIALIZATION_ERROR, sprintf("missing message argument %y (got %y instead)", $k, $h.keys());
            }
            */

	    my any $hv;
	    #printf("DEBUG: arg %n with %n\n", $k, $.args.$k);
            my string $ons;
	    if ($.args.$k.element)
		$hv = $.args.$k.element.serialize($v, !$.encoded, NOTHING, $k, $.name, \$ons);
	    else {
		$hv = $.args.$k.type.serialize($v, !$.encoded, True);
                $ons = $.args.$k.type.getOutputNamespacePrefix();
            }
	    #printf("DEBUG: arg %s got %n from %n (%n)\n", $k, $hv, $v, exists $.args.$k.element ? $.args.$k.element : $.args.$k.type);

	    #printf("DEBUG: WSMessage::serialize() k=%n args=%n, parts=%n\n", $k, keys $.args, $msginfo.parts);
	    if ($msginfo.parts.$k) {
		my any $ct = $msginfo.parts.$k;
		if ($ct.typeCode() == NT_LIST)
		    $ct = shift $ct;
		$mpm.addPart($hv, sprintf("<%s>", $k), $ct);
		$hv."^attributes^".href = "cid:" + $k;
	    }

            my string $en = $.args.$k.element ? ($ons + ":" +  $k) : $k;
	    $rh.$en = $hv;
	}
	
        if ($h.typeCode() == NT_HASH && $h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", $h.keys(), $.name);

	if ($.encoded)
	    $rh."^attributes^" += 
	    ( "soapenv:encodingStyle" : SOAP_ENCODING,
	      "xmlns:soapenc"         : SOAP_ENCODING );

	my hash $rvh.("ns1:" + $name) = $rh;

	return $rvh;
    }

    hash serializeDocument(*string $k, any $msginfo, any $mpm, any $h, bool $force_ns) {
	my hash $rh;

        if ($.encoded)
            $rh."^attributes^" += (
                "soapenv:encodingStyle": SOAP_ENCODING,
                "xmlns:soapenc": SOAP_ENCODING,
            );

        if (!$k && $.args.size() == 1) {
            my string $key = $.args.firstKey();
            my any $v = ($h.typeCode() == NT_HASH && $h.hasKey($key)) ? remove $h.$key : remove $h;
            XSDBase::removeNS2(\$v);
            my string $ons;
            my any $th = $.args.$key.element.serialize($v, !$.encoded, !$force_ns, $key, $.name, \$ons);
            $rh.($ons + ":" + $.args.$key.element.name) = $th;
        }
        else {
            foreach my string $key in ($k ? $k : $.args.keyIterator()) {
                my any $val = remove $h.$key;
                if ($val.typeCode() == NT_HASH)
                    XSDBase::removeNS2(\$val);

                my string $ons;
                my any $th = $.args.$key.element.serialize($val, !$.encoded, !$force_ns, $key, $.name, \$ons);
                $rh.($ons + ":" + $.args.$key.element.name) = $th;
            }
        }

        if ($h.typeCode() == NT_HASH && $h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", $h.keys(), $.name);

	#printf("DEBUG: message %s: force_ns: %y args: %y h: %y\n", $.name, $force_ns, keys $.args, $h);
    
	return $rh;
    }

    any deserialize(*hash $types, *hash $mrh, hash $val) {
        #printf("DBG WSMessage::deserialize() args: %y pmap: %y val: %y\n", $.args.keys(), $.pmap, $val);
	my hash $ro;

	foreach my string $key in ($.args.keyIterator()) {
            my any $v = remove $val.$key;
            if ($v.typeCode() == NT_HASH)
                XSDBase::removeNS2(\$v);

            my string $rk = $key;
            if ($.pmap.$key && !$.args.($.pmap.$key))
                $rk = $.pmap.$key;
	    
	    $ro.$rk = $.args.$key.element
		? $.args.$key.element.deserialize($types, $mrh, $.getValue($mrh, $v))
		: $.args.$key.type.deserialize($.name, $types, $mrh, $.getValue($mrh, $v));
	}

        if ($val)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", $val.keys(), $.name);

	# if there is only one argument, return it directly
        return $ro.size() == 1 ? $ro.firstValue() : $ro;
    }

    any deserializeDocument(*hash $types, *hash $mrh, any $val) {
        my any $rh;

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\n", $.args.keys(), $val);
        if ($.args.size() == 1) {
            my string $key = $.args.firstKey();
            my any $v = ($val.typeCode() == NT_HASH && $val.hasKey($key)) ? remove $val.$key : remove $val;
            XSDBase::removeNS2(\$v);
            $rh = $.args.firstValue().element.deserialize($types, $mrh, $v);
        }
        else {
            foreach my string $key in ($.args.keyIterator()) {
                my any $v = remove $val.$key;
                XSDBase::removeNS2(\$v);
                $rh.$key = $.args.$key.element.deserialize($types, $mrh, $v);
            }
        }

        if ($val)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", $val.keys(), $.name);

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\nRH: %y\n", $.args.keys(), $val, $rh);
        return $rh;
    }
}

# private helper class for lazy name resolution
class WSDL::XSDLateResolverHelper {
    private { list $.l = (); }

    constructor() { 
    }

    add(any $v) { 
	$.l += $v; 
    }

    list getList() {
	return $.l;
    }
}

#! class for WSDL bindings
public class WSDL::Binding inherits WSDL::XSDNamedData {
    public {
	bool $.docStyle = False;
    }

    constructor(hash $data, Namespaces $nsc, hash $opmap, reference $idocmap, *hash $messages) : XSDNamedData(\$data) {
	# get binding attributes
        #my *hash $ba = $data."^attributes^";

	if (exists $data.binding) {
	    my *hash $bba = $data.binding."^attributes^";
	    if (exists $bba.transport && $bba.transport != SOAP_TRANSPORT_HTTP)
		throw WSDL_ERROR, sprintf("unsupported transport %y in binding %y", $bba.transport, $.name);
	    if ($bba.style == "document")
		$.docStyle = True;
	}

	foreach my hash $ophash in ($data.operation) {
	    my string $name = $ophash."^attributes^".name;

	    my *WSOperation $op = $opmap.$name;
	    if (!exists $op)
		throw WSDL_ERROR, sprintf("binding for %n references unknown operation %n", $data.name, $name);

	    WSDL::XSDBase::removeNS(\$ophash);

	    my *string $sa = $ophash.operation."^attributes^".soapAction;
	    if (exists $sa) {
		#printf("GOT: %s sa=%y\n", $name, $sa);
		$op.soapAction = $sa ? $sa : $name + "Action";
	    }

	    if ($.docStyle || $ophash.operation."^attributes^".style == "document") {
		$op.setDocStyle(\$idocmap);
	    }

	    my WSDL::WSMessage $input = $op.input;

	    WSDL::XSDBase::removeNS(\$ophash.input);
	    if (exists $ophash.input.body) {
		if ($ophash.input.body."^attributes^".use == "encoded") {
		    $input.encoded = True;
		    #printf("DEBUG: setting encoding = True for %n.%n input\n", $data.name, $name);
		}
	    }
	    else if (exists $ophash.input.multipartRelated) {
		$op.setInputMultipart(Mime::MPT_RELATED);
		WSDL::XSDBase::removeNS(\$ophash.input.multipartRelated);		

		if (!exists $ophash.input.multipartRelated.part)
		    throw WSDL_ERROR, sprintf("missing part definition(s) in input message definition for operation %n: %n", $name, $ophash);

		foreach my any $part in ($ophash.input.multipartRelated.part) {
		    WSDL::XSDBase::removeNS(\$part);
		    $op.addInputPart($part);
		}
	    }
	    else
		throw WSDL_ERROR, sprintf("cannot parse input message definition for operation %n: %n", $name, $ophash);

	    # check for header
	    foreach my hash $hh in ($ophash.input.header) {
		my *hash $ma = $hh."^attributes^";
		
		if (!$ma.message)
		    throw WSDL_ERROR, sprintf("input binding %y for operation %y specifies a soap header element without a 'message' attribute (attr: %y)", $.name, $name, $ma);

		if (!$ma.part)
		    throw WSDL_ERROR, sprintf("input binding %y for operation %y specifies a soap header element without a 'part' attribute (attr: %y)", $.name, $name, $ma);

		my hash $h = $nsc.doType($ma.message);
		my *WSMessage $msg = $messages.($h.val);
		if (!exists $msg)
		    throw WSDL_ERROR, sprintf("input binding %y references unknown message %y in the soap header element", $.name);

		#printf("header msg=%y part=%y use=%y\n", $ma.message, $ma.part, $ma.use);
		#printf("op.input=%N\n", $input);

		$op.setInputHeader($ma.part, $msg, $ma.use == "encoded");
	    }

	    WSDL::XSDBase::removeNS(\$ophash.output);
	    if (exists $ophash.output.body) {
		if ($ophash.output.body."^attributes^".use == "encoded") {
		    $op.output.encoded = True;
		    #printf("DEBUG: setting encoding = True for %n.%n output\n", $data.name, $name);
		}
	    }
	    else if (exists $ophash.output.multipartRelated) {
		$op.setOutputMultipart(Mime::MPT_RELATED);
		WSDL::XSDBase::removeNS(\$ophash.output.multipartRelated);		

		if (!exists $ophash.output.multipartRelated.part)
		    throw WSDL_ERROR, sprintf("missing part definition(s) in output message definition for operation %n: %n", $name, $ophash);

		foreach my any $part in ($ophash.output.multipartRelated.part) {
		    WSDL::XSDBase::removeNS(\$part);
		    $op.addOutputPart($part);
		}
	    }
	    else
		throw WSDL_ERROR, sprintf("cannot parse output message definition for operation %n: %n", $name, $ophash);
	}

	#$.binding = $data;
    }
}

#! namespace container class
public class WSDL::Namespaces {
    public {
    }

    private {
        #! maps output namespace prefixes to namespace URIs
        hash $.ns = (
            "xsd": XSD_NS,
            );

        #! maps namespace URIs to output namespace prefixes
        hash $.nsr = (
            XSD_NS: "xsd",
            );

        #! hash for valid XSD namespaces, maps input namespace prefixes -> True if it refers to an XSD schema
        hash $.xml_schema;

        #! hash mapping input namespace prefixes to namespaces URIs
        hash $.imap = (
            "xsd": XSD_NS,
            );

        #! integer providing a sequence for output namespace prefixes
        int $.nsn;

        #! if True then using SOAP 1.2
        bool $.soap12 = False;

        #! current target namespace
        *string $.target_ns;

        #! target namespace stack;
        list $.nss = ();
    }

    #! creates the object with the wsdl definitions attribute hash
    constructor(hash $nsh, *Namespaces $nsc) {
        $.nsn = $nsc ? $nsc.nsn : 1;

        if ($nsh.targetNamespace)
            $.target_ns = $nsh.targetNamespace;

	#printf("DEBUG: getNSPrefixes() %n\n", $a);
	foreach my string $k in ($nsh.keyIterator()) {
	    my *string $ns = ($k =~ x/xmlns:(\w+)/)[0];
	    
	    if (!$ns)
		continue;
	    $.imap.$ns = $nsh.$k;

	    if ($nsh.$k == XSD_NS)
		$.xml_schema.$ns = True;

	    if ($nsh.$k == SOAP_12_NS)
		$.soap12 = True;
	}
	# "default" has to be quoted because it's a reserved word
	if ($nsh.xmlns)
	    $.ns."default" = $nsh.xmlns;
	#$.ns.target = $nsh.targetNamespace;
    }

    #! merges namespaces when parsing imported schemas
    merge(Namespaces $nsc) {
        $.nsn = $nsc.nsn;
        foreach my string $k in ($nsc.ns.keyIterator()) {
            my string $v = $nsc.ns.$k;

            if ($.ns.$k) {
                if ($.ns.$k == $v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", $k, $v, $.ns.$k);
            }
            if (!$.nsr.$v) {
                $.ns.$k = $v;
                $.nsr.$v = $k;
            }
        }
    }

    #! returns the namespace URI for the given output namespace prefix
    string getOutputNamespaceUri(string $nsp) {
        my *string $ns = $.ns.$nsp;
        if (!$ns)
            throw "WSDL-NAMESPACE-ERROR", sprintf("output namespace prefix %y is unknown (known output namespace prefixes: %y)", $nsp, $.ns.keys());
        return $ns;
    }

    #! returns a hash of namespace attributes for outgoing SOAP messages
    *hash getOutputNamespaceHash(*hash $nsh) {
        my hash $h;
        map $h.("xmlns:" + $1.key) = $1.value, $.ns.pairIterator();

        foreach my string $k in ($nsh.keyIterator()) {
            my string $xs = "xmlns:" + $k;
            if ($h.$xs) {
                if ($h.$xs != $nsh.$k)
                    throw "WSDL-NAMESPACE-ERROR", sprintf("namespace %y has already been added automatically as %y and therefore cannot be overridden as %y", $k, $h.$xs, $nsh.$k);
            }
            else
                $h.$xs = $nsh.$k;
        }

        return $h;
    }

    #! returns the primary target namespace Uri
    *string getTargetNamespaceUri() {
        return $.target_ns;
    }

    #! pushes the previous target namespace URI on the stack when parsing schemas and sets the current target namespace URI to the current value
    pushTargetNamespace(string $ns) {
        $.nss += $.target_ns;
        $.target_ns = $ns;
    }

    #! restores any previous target namespace URI from the stack to the current target namespace URI
    popTargetNamespace() {
        $.target_ns = pop $.nss;
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getOutputNamespacePrefix(string $ns) {
        my *string $nsa = $.nsr.$ns;
        if ($nsa)
            return $nsa;

        return $.registerNamespaceIntern($ns);
    }

    #! registers a namespace internally
    private string registerNamespaceIntern(string $ns) {
        # create namespace prefix
        my string $nsa = sprintf("ns%d", $.nsn++);
        # register namespace in forward and reverse maps
        $.ns.$nsa = $ns;
        $.nsr.$ns = $nsa;

        return $nsa;
    }

    #! returns a hash of namespace prefixes to namespaces URIs actually used
    *hash getReferencedNamespaceMap() {
        return $.ns;
    }

    #! returns True if using SOAP 1.2, False if not
    bool isSoap12() {
        return $.soap12;
    }

    #! returns True if if the input namespace prefix refers to the XSD namespace URI
    *bool isSchema(string $ns) {
        return $.xml_schema.$ns;
    }

    #! returns the input namespace URI from the input namespace prefix
    string getInputNamespaceUri(string $nsa) {
        my *string $rv = $.imap.$nsa;
        if (!$rv)
            throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace %y is unknown (known input namespaces: %y)", $nsa, $.imap.keys());
        return $rv;
    }

    any doType(string $t) {
	#printf("DEBUG: XSDBase::doType(%n, %n)\n", $t, $nsinfo);
	my (*string $ns, *string $type) = $t =~ x/(\w+):(\w+)/;
	if (!$type)
	    return ("val": $t);
	
	# if this is in the XML Schema namespace, then it's a base type
	if ($.xml_schema.$ns)
	    return new XSDBaseType($type, $self);

        return ("ns": $.getOutputNamespacePrefix($.getInputNamespaceUri($ns)), "val": $type);
    }

    #! returns the output namespace prefix for the given input namespace prefix
    string translateOutputNamespacePrefix(*string $nsa) {
        return $.getOutputNamespacePrefix($.getInputNamespaceUri($nsa));
    }
}

#! main class representing a parsed WSDL file
/** This is the main class for handling SOAP communication and is based on a WSDL file
*/
public class WSDL::WebService inherits WSDL::XSDBase {
    public {
        #! the WSDL string
        string $.wsdl;

        #! namespace container
        Namespaces $.nsc;

        #! namespace info
        #hash $.ns;

        #bool $.soap12 = False;
        hash $.base_type;
        hash $.services;
        list $.wsdl_services = ();
        hash $.idocmap;
        hash $.opmap;
        hash $.binding;
        hash $.element_map;
        hash $.messages;
        hash $.types;
        bool $.usedocns = False;
        hash $.portType;
        *code $.try_import;
    }

    #! creates the WebService object
    /** @param str the XML string representing the WSDL
	@param opts an optional hash of options with the following possible keys:
        - \c try_import a call reference or closure to be passed a string name for XSD imports without any scheme to retrieve the data, must take a string argument (the resource name) and return a string (the resource data)
	- \c http_client a HTTPClient object for retrieving data from import commands
	- \c http_headers a hash of optional HTTP header info to use when retrieving data from import commands
    */
    constructor(string $str, *hash $opts) {
	my hash $h = parseXMLAsData($str);

	# save WSDL text
	$.wsdl = $str;

        $.try_import = $opts.try_import;

	# remove namespace (normally "wsdl:") prefix from keys if present
	WSDL::XSDBase::removeNS(\$h);
	WSDL::XSDBase::removeNS(\$h.definitions);
        $.nsc = new Namespaces($h.definitions."^attributes^");
	#$.getNSPrefixes($h.definitions."^attributes^");

	#printf("%N\n", $h.definitions.types);

	if (exists $h.definitions.types)
	    $.parseTypes($h.definitions.types, $opts.http_client instanceof HTTPClient ? $opts.http_client : NOTHING, $opts.http_headers);
	
	if (exists $h.definitions.message)
	    $.parseMessages($h.definitions.message);
	
	if (exists $h.definitions.portType)
	    $.parsePortType($h.definitions.portType);

	if (exists $h.definitions.binding)
	    $.parseBinding($h.definitions.binding);
	
	if (exists $h.definitions.service)
	    $.parseService($h.definitions.service);
    }

    hash getType(string $name, any $v) {
        #printf("DBG getType() %y: %N\n", $name, $.types.$name);
        if (!$.types.$name)
            throw "WSDL-TYPE-ERROR", sprintf("cannot find requested type %y (known types: %y)", $name, keys $.types);
        return ("^type^": $.types.$name, "^val^": $v);
    }

    #! returns a map of top-level element names to WSOperation objects
    /** @return a map of top-level element names to WSOperation objects
    */
    *hash getOperationMap(any $name) {
	if (!exists $name) {
	    if (elements $.wsdl_services > 2)
		throw "WSDL-GET-INPUT-OPERATION-MAP-ERROR", sprintf("no service argument passed to WSDL::getOperationMap() but the WSDL defines more than one service (%n)", keys ($.services - "port"));
	    #$name = $.wsdl_services[0];
	}
	else if (!inlist($name, ($.services - "port")))
	    throw "WSDL-GET-INPUT-OPERATION-MAP-ERROR", sprintf("service argument %n passed to WSDL::getOperationMap() is not defined by this WSDL (vaild services: %n)", $name, keys ($.services - "port"));

	return $.idocmap;
    }

    /*
    private getNSPrefixes(*hash $a) {
	#printf("DEBUG: getNSPrefixes() %n\n", $a);
	foreach my string $k in ($a.keyIterator()) {
	    my any $ns = ($k =~ x/xmlns:(\w+)/)[0];
	    
	    if (!exists $ns)
		continue;
	    $.ns.map.$ns = $a.$k;

	    if ($a.$k == XSD_NS)
		$.ns.xml_schema.$ns = True;

	    if ($a.$k == SOAP_12_NS)
		$.soap12 = True;
	}
	# "default" has to be quoted because it's a reserved word
	if (exists $a.xmlns)
	    $.ns."default" = $a.xmlns;
	$.ns.target = $a.targetNamespace;
    }
    */

    private XSDBaseType getBaseType(any $t) {
	if (exists $.base_type.$t)
	    return $.base_type.$t;

	return $.base_type.$t = new XSDBaseType($t, $.nsc);
    }

    private XSDAbstractType resolveType(hash $v) {
	if ($v.ns && $.nsc.isSchema($v.ns))
	    return $.getBaseType($v.val);

	# find type
	if (!$.types.($v.val)) {
            my string $tn = $v.val;
            if ($v.ns)
                $tn = $v.ns + ":" + $v.val;
	    throw WSDL_ERROR, sprintf("cannot resolve type %y; known types: %y", $tn, $.types.keys());
        }

	return $.types.($v.val);
    }

    # parse XSD schema types
    private parseTypes(*hash $data, any $http_client, any $http_headers) {
	WSDL::XSDBase::removeNS(\$data);

	my *hash $sa = $data.schema."^attributes^";
	if ($sa.elementFormDefault == "qualified")
	    $.usedocns = True;
        if ($sa.targetNamespace)
            $.nsc.pushTargetNamespace($sa.targetNamespace);
        on_exit if ($sa.targetNamespace)
            $.nsc.popTargetNamespace();

        my XSDLateResolverHelper $unresolved();

	foreach my *hash $schema in ($data.schema) {
            #printf("DEBUG: schema tn: %y\n", $schema."^attributes^"."targetNamespace");
	    WSDL::XSDBase::removeNS(\$schema);
	    #printf("DEBUG: WebService::parseTypes() schema=%N\n", $schema);

	    # process XSD import if present
	    if ($schema.import) {
		my *hash $a = $schema.import."^attributes^";
		# import file
		if ($a.schemaLocation) {
                    my hash $h = parse_url($a.schemaLocation);
                    my string $xsd;
                    if (!$h.protocol && $.try_import)
                        $xsd = call_function($.try_import, $a.schemaLocation);
                    else
                        $xsd = WSDLLib::getFileFromURL($a.schemaLocation, "file", $http_client, $http_headers);

		    # parse XML to Qore data structure ignoring XML element order
                    my hash $xh = parseXMLAsData($xsd);

		    # parse namespace definitions in schema attributes
                    if ($xh.size() != 1)
			throw WSDL_ERROR, sprintf("expecing a single element indicating an XSD schema in the imported file; got instead: %y", $xh.keys());

		    # get schema member name
		    my any $sk = $xh.firstKey();

                    # use temporary Namespaces object for import
                    my Namespaces $nsc = $.nsc;
                    $.nsc = new Namespaces($xh.$sk."^attributes^", $.nsc);
                    on_exit
                        $.nsc = $nsc;
                    on_success
                        $nsc.merge($.nsc);

		    # verify that the top-level key indicates an XSD schema definition
		    my (*string $ns, *string $mem) = ($sk =~ x/^(\w+):(\w+)$/);
		    if ($ns && !$.nsc.isSchema($ns))
			throw WSDL_ERROR, sprintf("expecing imported schema definition to be in XSD namespace %n, got %n=%n instead", XSD_NS, $ns, $.nsc.getInputNamespaceUri($ns));

		    $.parseTypes($xh);
		}
	    }

	    foreach my hash $st in ($schema.simpleType) {
		my XSDSimpleType $t($st, $.nsc, $unresolved);
		$.types.($t.name) = $t;
                #printf("DEBUG: st: %y\n", $t.name);
	    }

	    foreach my hash $ct in ($schema.complexType) {
		my XSDComplexType $t($ct, $.nsc, $unresolved);
		$.types.($t.name) = $t;
                #printf("DEBUG: ct: %y\n", $t.name);
	    }

            # make element map
            foreach my any $el in ($schema.element) {
                my any $attr = $el."^attributes^";
                if (exists $attr.type) {
                    my any $t = $.nsc.doType($attr.type);
                    if (!($t instanceof XSDData)) {
                        $t = $t.val;
                        if (!exists $.types.$t)
                            throw WSDL_ERROR, sprintf("cannot resolve element %n type %n", $el, $t);
                        #printf("DEBUG: adding element %n type %n\n", $attr.name, $t);
                        $.element_map.($attr.name) = new WSDL::XSDElement(("^attributes^":("name":$attr.name)), $.nsc, $.types.$t, $unresolved);
                    }
                    else {
                        #printf("DEBUG: adding element %n type %n\n", $attr.name, $t);
                        $.element_map.($attr.name) = new WSDL::XSDElement(("^attributes^":("name":$attr.name)), $.nsc, $t, $unresolved);
                    }
                }
                else {
                    #printf("DEBUG: adding element %n\n", $attr.name);
                    $.element_map.($attr.name) = new WSDL::XSDElement($el, $.nsc, NOTHING, $unresolved);
                }
            }
        }

        # resolve types
        foreach my any $e in ($unresolved.getList())
            $e.type = $.resolveType($e.type);

        foreach my string $t in ($.types.keyIterator()) {		
            if ($.types.$t instanceof XSDComplexType) {
                #foreach my any $e in (keys $.types.$t."elements")
                #    if (!($.types.$t."elements".$e.type instanceof XSDData))
                #	    $.types.$t."elements".$e.type = $.resolveType($.types.$t."elements".$e.type);
                
                # process restriction info
                if ($.types.$t.restriction) {
                    my any $et = $.types.$t.restriction;
                    if (!exists $.types.$et)
                        throw WSDL_ERROR, sprintf("complexType %s should be restricted from base type %n, but type %n is not defined", $t, $et, $et);
                    # combine base type and new type
                    $.types.$t.elements = $.types.$et.elements + $.types.$t.elements;
                    #printf("DEBUG: extended %s with %s (%n)\n", $t, $et, keys $.types.$t.elements);
                }

                # process extension info
                if ($.types.$t.extension) {
                    my any $et = $.types.$t.extension;
                    if (!exists $.types.$et)
                        throw WSDL_ERROR, sprintf("complexType %s should be extended by %n, but type %n is not defined", $t, $et, $et);
                    # combine base type and new type
                    $.types.$t.elements = $.types.$et.elements + $.types.$t.elements;
                    #printf("DEBUG: extended %s with %s (%n)\n", $t, $et, keys $.types.$t.elements);
                }

                # process array info
                if ($.types.$t.array) {
                    my any $et = $.types.$t.array.val;
                    $.types.$t.array = new XSDArrayType($.types.$et ? $.types.$et : $et, $.nsc);
                }
            }
        }

        # resolve types
        foreach my any $e in ($unresolved.getList())
            if (!($e.type instanceof XSDData))
                $e.type = $.resolveType($e.type);
    }

    private parseMessages(*softlist $message) {
	# parse messages
	foreach my hash $m in ($message) {
	    my WSMessage $msg($m, $.element_map, $.nsc);
	    foreach my string $arg in ($msg.args.keyIterator()) {
		#printf("DEBUG: WebService::parseMessages(): %y: %y\n", $arg, $msg);
		#printf("DEBUG: WebService::parseMessages(): %y: %y\n", $arg, $msg.args.$arg.type);
		if (exists $msg.args.$arg.type && !($msg.args.$arg.type instanceof XSDData))
		    $msg.args.$arg.type = $.resolveType($msg.args.$arg.type); 
	    }
	    $.messages.($msg.name) = $msg;
	}
    }

    private parseService(any $svc) {
	WSDL::XSDBase::removeNS(\$svc);
	$.services.name = $svc."^attributes^".name;
	foreach my any $port in ($svc.port) {
	    WSDL::XSDBase::removeNS(\$port);
	    my string $name = $port."^attributes^".name;
	    $.services.port.$name = $port."^attributes^";
            $.services.port.$name += (
                "address": $port.address."^attributes^".location,
                "binding": $.nsc.doType($.services.port.$name.binding),
                );
	}
    }

    private parsePortType(any $data) {
	# setup list of services defined in this WSDL
        foreach my any $port in ($data) {
	    WSDL::XSDBase::removeNS(\$port);
	    #printf("DEBUG: portType=%N\n", $port);
	    my string $name = $port."^attributes^".name;
	    $.wsdl_services += $name;
	    foreach my any $p in ($port.operation) {
		my WSOperation $op($p, $.types, $.nsc, $.messages, $.usedocns);
		$.portType.$name.operations.($op.name) = $op;
		#printf("DEBUG: %n registered operation %n\n", $name, $op.name);
		$.opmap.($op.name) = $op;
	    }
	}
    }

    private parseBinding(any $bindings) {
	foreach my hash $data in ($bindings) {
	    my WSDL::Binding $b($data, $.nsc, $.opmap, \$.idocmap, $.messages);

	    $.binding.($b.getName()) = $b;
	}
    }

    #! returns True if the WSDL describes a SOAP 1.2 service
    /** @return True if the WSDL describes a SOAP 1.2 service
    */
    bool isSoap12() {
	return $.nsc.isSoap12();
    }

    #! returns the XML string for the WSDL
    /** @return the XML string for the WSDL
    */
    string getWSDL() {
	return $.wsdl;
    }
}
