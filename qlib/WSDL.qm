# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file WSDL.qm WSDL: Web Services Description Language: http://www.w3.org/TR/wsdl

/*  WSDL.qm Copyright (C) 2012 - 2016 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# make sure we have the required qore version
%requires qore >= 0.8.12

# requires XML functionality
%requires xml

# need mime definitions
%requires Mime >= 1.1

# do not use $ for vars
%new-style

%disable-warning unreferenced-variable

module WSDL {
    version = "0.3.5.1";
    desc = "WSDL module providing functionality for SOAP";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/*
    WSDL classes
    provides some minimal WSDL and XSD support for SOAP messaging used by the SoapClient class and the SoapHandler

    not complete, needs namespace verification, improved XSD support, element groups, etc
*/

/** @mainpage WSDL Module

    @tableofcontents

    @section wsdlintro Introduction to the WSDL Module

    The %WSDL module provides functionality for <a href="http://en.wikipedia.org/wiki/SOAP">SOAP</a> 1.1 and 1.2.

    The main purpose of this module is to provide the infrastructure for developing SOAP client and server services.

    The main components of this module are as follows:
    - @ref WSDL::WebService "WebService": represents a WSDL file; an easy way to get an object of this type from a URL is by calling WSDL::WSDLLib::getWSDL()
    - @ref WSDL::WSDLLib "WSDLLib": a class of static functions providing helper functions for the module
    - @ref WSDL::WSOperation "WSOperation": a class representing a single operation from a web service

    See the following for modules using the %WSDL module:
    - <a href="../../SoapClient/html/index.html">SoapClient user module</a>
    - <a href="../../SoapHandler/html/index.html">SoapHandler user module</a>

    @section wsdlrelnotes WSDL Module Release Notes

    @subsection wsdl_0_3_5_1 WSDL v0.3.5.1
    - supress emitting a SOAPAction header in requests if the binding gives an empty string (<a href="https://github.com/qorelanguage/qore/issues/1226">issue 1226</a>)
    - updated @ref WSDL::WSOperation::serializeRequest() to allow the SOAPAction header to be overridden in each request (<a href="https://github.com/qorelanguage/qore/issues/1226">issue 1226</a>)
    - respect XML generation flags in request generation
    - fixed parsing empty base64Binary and hexBinary elements (<a href="https://github.com/qorelanguage/qore/issues/1227">issue 1227</a>)

    @subsection wsdl_0_3_5 WSDL v0.3.5
    - fixed many message serialization and deserialization issues
    - added @ref WSDL::WebService::getOperation()
    - allow for environment variable substitution in WSDLLib::getWSDL() when retrieving files
    - fixed charset=... header value

    @subsection wsdl_0_3_4 WSDL v0.3.4
    - updated to a user module

    @subsection wsdl_0_3_3 WSDL v0.3.3
    - added initial support for the anyAttribute element of complexType
    - added initial support for SOAP header processing
    - added initial support for multiple portType and bindings in a WSDL

    @subsection wsdl_0_3_2 WSDL v0.3.2
    - fixed bugs de/serializing negative values for "int" and "short"

    @subsection wsdl_0_3_1 WSDL v0.3.1
    - improved XSD imports and namespace handling

    @subsection wsdl_0_3_0 WSDL v0.3.0
    - implemented WSDLLib class of helper functions
    - implemented support for xsd import statements in WSDLs

    @subsection wsdl_0_2_0 WSDL v0.2.0
    - use parseXMLAsData() instead of parseXML()
    - implemented initial simpleType support
    - fixed xsd:date serialization and deserialization
*/

#! main WSDL namespace
public namespace WSDL {
    #! this WSDL implementation version
    public const version     = "0.3.5.1";

    #! SOAP 1.1 envelope URI
    public const SOAP_11_ENV  = "http://schemas.xmlsoap.org/soap/envelope/";
    #! SOAP 1.2 envelope URI
    public const SOAP_12_ENV  = "http://www.w3.org/2003/05/soap-envelope";

    #! SOAP 1.1 namespace URI
    public const SOAP_11_NS   = "http://schemas.xmlsoap.org/wsdl/soap/";

    #! SOAP 1.2 namespace URI
    public const SOAP_12_NS   = "http://schemas.xmlsoap.org/wsdl/soap12/";

    #! XSD namespace URI
    public const XSD_NS       = "http://www.w3.org/2001/XMLSchema";
    #! XSI namespace URI
    public const XSI_NS       = "http://www.w3.org/2001/XMLSchema-instance";

    #! HTTP namespace URI
    public const HTTP_NS      = "http://schemas.xmlsoap.org/wsdl/http/";
    #! MIME namespace URI
    public const MIME_NS      = "http://schemas.xmlsoap.org/wsdl/mime/";

    #! soap 1.1 envelope namespaces
    public const ENVELOPE_11_NS = (
        "soapenv:Envelope": (
            "^attributes^": (
                "xmlns:soapenv": SOAP_11_ENV,
                "xmlns:xsd": XSD_NS,
                "xmlns:xsi": XSI_NS,
            ),
        ),
        );

    #! soap 1.2 envelope namespaces
    public const ENVELOPE_12_NS = (
        "soapenv:Envelope": (
            "^attributes^": (
                "xmlns:soapenv": SOAP_12_ENV,
              "xmlns:xsd": XSD_NS,
              "xmlns:xsi": XSI_NS,
            ),
        ),
        );

    #! soap encoding URI
    public const SOAP_ENCODING = "http://schemas.xmlsoap.org/soap/encoding/";

    #! mapping from Qore types to xsd types for xsd type "anyType"
    public const any_type_map = (
        Type::String      : "string",
        Type::Int         : "long",
        Type::Boolean     : "boolean",
        Type::Date        : "dateTime",
        Type::Float       : "decimal",
        Type::NothingType : "string",
        Type::NullType    : "string",
        Type::Binary      : "base64Binary",
        );

    # error codes
    const SOAP_SERIALIZATION_ERROR = "SOAP-SERIALIZATION-ERROR";
    const SOAP_DESERIALIZATION_ERROR = "SOAP-DESERIALIZATION-ERROR";
    const WSDL_ERROR = "WSDL-ERROR";

    #! SOAP HTTP transport URI
    const SOAP_TRANSPORT_HTTP = "http://schemas.xmlsoap.org/soap/http";

    #! known/supported transports
    public const SOAP_TRANSPORT = (
        SOAP_TRANSPORT_HTTP: True,
        );

    #! range of "short" values (16 bits)
    public const RANGE_SHORT = (-32768, 32767);

    #! range of "int" values (32 bits)
    public const RANGE_INT = (-2147483648, 2147483647);
}

#! contains helper methods for retrieving WSDLs from a URL
public class WSDL::WSDLLib {
    #! Mime types recognized as SOAP messages
    const SoapMimeTypes = (MimeTypeSoapXml, MimeTypeXml, MimeTypeXmlApp);

    #! retrieves a local file and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "file"
    */
    static data getFile(string fn, bool as_string = True) {
        *data rv = as_string ? ReadOnlyFile::readTextFile(fn) : ReadOnlyFile::readBinaryFile(fn);
        if (!exists rv)
            throw "WSDL-LIB-ERROR", sprintf("file %y is empty or could not be read as a normal file", fn);
        return rv;
    }

    #! retrieves a file from a URL with HTTP and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "http"
    */
    static string getHTTP(string url, *string path, *HTTPClient hc, *hash headers, bool as_string = True) {
        if (hc)
            hc.setURL(url);
        else
            hc = new HTTPClient(("url": url));
        string body = hc.get(path ? path : "/", headers);
        return as_string ? body : binary(body);
    }

    #! retrieves a file from a URL with the FTP protocol and returns the file's contents as binary or string data
    /** called by WSDLLib::getFileFromURL() in case the scheme is "ftp"
    */
    static data getFTP(string url, string path, bool as_string = True) {
        string file = basename(path);
        if (!file)
            throw "WSDL-LIB-ERROR", sprintf("missing file name in URL %y", url);

        FtpClient f(url);
        f.connect();

        string dir = dirname(path);
        if (dir)
            f.cwd(dir);

        return as_string ? f.getAsString(file) : f.getAsBinary(file);
    }

    #! retrieves a file from a URL
    /** in case the URL is actually a file path, environment variable substitution
        is performed on the path string
     */
    static data getFileFromURL(string url, string def_protocol = "file", *HTTPClient http_client, *hash http_headers, bool as_string = True, *string def_path, *reference new_def_path) {
        return WSDLLib::getFileFromURL(url, parse_url(url), def_protocol, http_client, http_headers, as_string, def_path, \new_def_path);
    }

    #! retrieves a file from an already-parsed URL
    /** in case the URL is actually a file path, environment variable substitution
        is performed on the path string
     */
    static data getFileFromURL(string url, hash u, string def_protocol = "file", *HTTPClient http_client, *hash http_headers, bool as_string = False, *string def_path, *reference new_def_path) {
        if (!exists u.protocol)
            u.protocol = def_protocol;

        switch (u.protocol) {
            case "file": {
                string path;
                if (u.host)
                    path = u.host;
                if (u.path) {
                    if (path)
                        path += DirSep;
                    path += u.path;
                }
                # do environment variable substitution
                map path = replace(path, "\$" + $1, ENV.$1), (path =~ x/\$(\w+)/g);

                if (def_path && !absolute_path(path))
                    path = def_path + DirSep + path;
                else
                    new_def_path = dirname(path);
                return WSDLLib::getFile(path, as_string);
            }

            case /^http(s)?$/:
                return WSDLLib::getHTTP(url, u.path, http_client, http_headers, as_string);

            case /^ftp(s)?$/:
                return WSDLLib::getFTP(url, u.path, as_string);

            default:
                throw "WSDL-LIB-ERROR", sprintf("do not know how to retrieve data with scheme %y given in URL %y", u.protocol, url);
        }
    }

    #! returns the argument
    static WebService getWSDL(WebService wsdl) {
        return wsdl;
    }

    #! returns a WSDL string form a file name, optional HTTPClient object and optional header hash
    /** in case the \a wsdl argument is actually a file path, environment variable substitution
        is performed on the path string
     */
    static string getWSDL(string wsdl, *HTTPClient http_client, *hash http_headers, *reference new_def_path) {
        if (wsdl =~ /^<\?xml/)
            return wsdl;
        return WSDLLib::getFileFromURL(wsdl, "file", http_client, http_headers, NOTHING, NOTHING, \new_def_path);
    }

    #! takes a hash representation of a SOAP message and parses it to a Qore data structure; handles multipart messages, checks the content-type, and handles hrefs in the message
    static hash parseSOAPMessage(hash msg) {
        if (exists msg."_qore_multipart") {
            if (msg."_qore_multipart" != "related")
                throw "SOAP-MESSAGE-ERROR", sprintf("don't understand multipart/%s messages, expected multipart/related", msg."_qore_multipart");

            any bdry = msg."_qore_multipart_boundary";
            if (!strlen(bdry))
                throw "SOAP-MESSAGE-ERROR", sprintf("multipart message received without multipart boundary; headers: %y", msg - "body");

            hash mpmsg;
            list l = split("\r\n--" + bdry, msg.body);

            for (int i = 1; i < (elements l - 1); ++i) {
                string m = l[i];

                int ie = index(m, "\r\n\r\n");
                if (ie == -1) {
                    throw "SOAP-MESSAGE-ERROR", sprintf("part %d has no headers: %y", i, m);
                }
                hash hh;
                foreach string hl in (split("\r\n", substr(m, 2, ie))) {
                    trim hl;
                    (string hi, any ignore, string ha) = hl =~ x/^(.*):([ \t])*(.*)$/;
                    hi = tolower(hi);
                    #printf("hl: %y hi: %y ha: %y\n", hl, hi, ha);exit();
                    hh{hi} = ha;
                }
                if (!exists hh."content-id")
                    throw "SOAP-MESSAGE-ERROR", sprintf("expecting part header Content-ID in part %d; headers: %y", i, hh);

                any b;
                if (hh."content-transfer-encoding" == "binary") {
                    # unfortunately we have to do some tricks to get the binary data out here
                    # FIXME: tricks probably not necessary with qore 0.8.1+
                    m = force_encoding(m, "ascii");
                    # recalculate byte offset
                    ie = index(m, "\r\n\r\n");
                    #printf("ie: %d m: %d\n", ie, strlen(m));exit();
                    b = binary(substr(m, ie + 4));

                    #File f(); f.open2("t.bin", O_CREAT|O_WRONLY|O_TRUNC); f.write(b); exit();
                }
                else {
                    b = substr(m, ie + 4);

                    if (hh."content-type" =~ /charset=/) {
                        string c = (hh."content-type" =~ x/charset=([^;]+)/)[0];
                        b = force_encoding(b, c);
                    }
                }

                if (hh."content-id" !~ /^\<.*\>$/)
                    throw "SOAP-MESSAGE-ERROR", sprintf("expected part ID to have the following format: <id>, instead got %s", hh."content-id");

                hash p = (
                    "hdr": hh,
                    "body": b,
                    );

                if ((!exists msg."_qore_multipart_start" && i == 1)
                    || (exists msg."_qore_multipart_start" && msg."_qore_multipart_start" == hh."content-id")) {
                    mpmsg.body = p;
                }
                else {
                    string id = substr(hh."content-id", 1, -1);
                    mpmsg.part{id} = p;
                }
            }
            # check content-type
            WSDLLib::checkSOAPContentType(mpmsg.body.hdr."content-type");

            #printf("part %d hh: %y\nbody: %s (%d)\n", i, hh, type(b), elements(b)); #exit();
            hash xmldata = parse_xml(mpmsg.body.body);

            # parse entire data structure to find "href"s or href attributes
            WSDLLib::substHref(\xmldata, mpmsg.part);
            return xmldata;
        }

        WSDLLib::checkSOAPContentType(msg."_qore_orig_content_type");

        return parse_xml(msg.body);
    }

    private static checkSOAPContentType(string ct) {
        foreach string sct in (SoapMimeTypes) {
            if (bindex(ct, sct) != -1)
                return;
        }

        throw "SOAP-MESSAGE-ERROR", sprintf("don't know how to handle content-type %y (expecting one of: %y)", ct, SoapMimeTypes);
    }

    private static processHref(reference xmldata, string hr, hash parts) {
        if (hr !~ /^cid:/)
            throw "SOAP-MESSAGE-ERROR", sprintf("messages references non-local part %y; cannot handle non-local parts", hr);
        hr = substr(hr, 4);
        if (!exists parts{hr})
            throw "SOAP-MESSAGE-ERROR", sprintf("message references non-existent part %y", hr);
        xmldata = parts{hr}.body;
    }

    private static substHref(reference xmldata, hash parts) {
        foreach string k in (keys xmldata) {
            if (exists xmldata{k}."^attributes^".href)
                WSDLLib::processHref(\xmldata{k}, xmldata{k}."^attributes^".href, parts);
            else if (exists xmldata{k}.href)
                WSDLLib::processHref(\xmldata{k}, xmldata{k}.href, parts);
            else if (xmldata{k}.typeCode() == NT_LIST) {
                foreach any e in (\xmldata{k})
                    WSDLLib::substHref(\e, parts);
            }
            else if (xmldata{k}.typeCode() == NT_HASH)
                WSDLLib::substHref(\xmldata{k}, parts);
        }
    }
}

#! base class with helper methods for XSD data processing
public class WSDL::XsdBase {
    /*
    static private hash doType(string t) {
        #printf("DEBUG: XsdBase::doType(%y)\n", t);
        (*string ns, *string type) = t =~ x/(\w+):(\w+)/;
        return !exists type ? ("val": t) : ("ns": ns, "val": type);
    }
    */

    static removeNS(reference v) {
        foreach hash h in (\v) {
            foreach string k in (h.keyIterator()) {
                (*string ns, *string name) = k =~ x/(\w+):(\w+)/;
                if (ns) {
                    if (h{k}.typeCode() == NT_HASH)
                        h{k}.ns = ns;
                    if (h{name}) {
                        softlist l = h{name};
                        l += remove h{k};
                        h{name} = l;
                    }
                    else
                        h{name} = remove h{k};
                }
            }
        }
    }

    static removeNS2(reference v) {
        foreach hash h in (\v) {
            foreach string k in (h.keyIterator()) {
                (*string ns, *string name) = k =~ x/(\w+):(\w+)/;
                if (ns) {
                    if (h{k}.typeCode() == NT_HASH)
                        h{k}.".ns" = ns;
                    if (h{name}) {
                        softlist l = h{name};
                        l += remove h{k};
                        h{name} = l;
                    }
                    else
                        h{name} = remove h{k};
                }
            }
        }
    }
}

#! base class for XSD data classes
public class WSDL::XsdData inherits WSDL::XsdBase {
    any getValue(*hash mrh, any val) {
        if (exists val."^attributes^".href) {
            string href = substr(val."^attributes^".href, 1);

            if (!exists mrh.mrh{href})
                throw "INVALID-REFERENCE", sprintf("multiRef id: %y does not exist", href);

            return mrh.mrh{href};
        }
        return val;
    }
}

#! base class for XSD classes with a "name" attribute
public class WSDL::XsdNamedData inherits WSDL::XsdData {
    public {
        # name of object
        string name;
        #! input namespace prefix (if any given)
        *string ns;
        #! descriptive name flag
        descriptive_name;
    }

    constructor(string n_name, string n_ns) {
        name = n_name;
        ns = n_ns;
        # if the name has a space in it, then it's a descriptive name
        descriptive_name = (name =~ / /);
    }

    constructor(reference e, *string desc_name) {
        WSDL::XsdBase::removeNS(\e);
        *hash a = e."^attributes^";
        if (a.name)
            name = a.name;
        else if (a.ref) {
            # remove namespace
            (*string ns, *string n_name) = a.ref =~ x/(\w+):(\w+)/;
            name = n_name ?? a.ref;
        }
        else
            name = desc_name ?? "<unnamed type>";
        # if the name has a space in it, then it's a descriptive name
        descriptive_name = (name =~ / /);
    }

    string getName() {
        return name;
    }

    *string getInputNamespacePrefix() {
        return ns;
    }

    bool hasRealName() {
        return !descriptive_name;
    }
}

public class WSDL::XsdAbstractType inherits WSDL::XsdNamedData {
    public {
        #! reference to namespaces
        Namespaces nsc;

        #! my namespace output prefix
        string ons;
    }

    constructor(reference e, Namespaces n_nsc, *string desc_name) : XsdNamedData(\e, desc_name) {
        nsc = n_nsc;
        resolveNamespace();
    }

    constructor(string name, string ns, Namespaces n_nsc) : XsdNamedData(name, ns) {
        nsc = n_nsc;
        resolveNamespace();
    }

    private resolveNamespace() {
        if (!ns) {
            *string tns = nsc.getTargetNamespaceUri();
            if (!tns)
                throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace for %s %y was not given and there is no current target namespace", self.className(), name);
            ons = nsc.getOutputNamespacePrefix(tns);
        }
        else
            ons = nsc.translateOutputNamespacePrefix(ns);
        #printf("DEBUG: type %y ns: %y ons: %y\n", name, ns, ons);
    }

    checkExtends(XsdAbstractType t, string ename) {
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible", name, ename, t.name);
    }

    string getNameWithNS() {
        return ons + ":" + name;
    }

    bool isNillable() {
        return False;
    }

    bool isRequired() {
        return True;
    }

    bool requiresValue() {
        return !isNillable() && isRequired();
    }

    string getOutputNamespacePrefix() {
        return ons;
    }

    abstract any serialize(any val, *softbool omit_type);
    abstract any deserialize(string en, *TypeMap tmap, *hash mrh, any val);
}

#! class for XSD base types
public class WSDL::XsdBaseType inherits WSDL::XsdAbstractType {
    public {
    }

    constructor(string t, Namespaces nsc, string ns = "xsd") : XsdAbstractType(t, ns, nsc) {
    }

    any serialize(any val, *softbool omit_type) {
        *string type;
        # set type according to Qore type if xsd type is anyType
        if (name == "anyType") {
            # we have to specify the type in this case
            omit_type = False;
            type = any_type_map{val.type()};
            if (!type)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize xsd type anyType from Qore type %y", val.type());
        }
        else {
            type = name;
        }

        switch (type) {
            case "byte": {
                int v = int(val);
                if ((v & 0xff) != v)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "short": {
                int v = int(val);
                if (v < RANGE_SHORT[0] || v > RANGE_SHORT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "int": {
                int v = int(val);
                if (v < RANGE_INT[0] || v > RANGE_INT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedByte": {
                int v = int(val);
                if ((v & 0xff) != v)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", type, v);
                break;
            }

            case "unsignedShort": {
                int v = int(val);
                if (v < 0 || v > RANGE_SHORT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedInt": {
                int v = int(val);
                if (v < 0 || v > RANGE_INT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedLong": {
                int v = int(val);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", type, v);
                break;
            }

            case "negativeInteger": {
                int v = int(val);
                if (v >= 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts negative values (value supplied: %d)", name, v);
                break;
            }

            case "nonNegativeInteger": {
                int v = int(val);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts non-negative values (value supplied: %d)", name, v);
                break;
            }

            case "nonPositiveInteger": {
                int v = int(val);
                if (v > 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts non-positive values (value supplied: %d)", name, v);
                break;
            }

            case "positiveInteger": {
                int v = int(val);
                if (v <= 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts positive values (value supplied: %d)", type, v);
                break;
            }

            case "date":
                val = format_date("YYYY-MM-DD", date(val));
                break;

            case "dateTime":
                val = format_date("YYYY-MM-DDTHH:mm:SS", date(val));
                break;

            case "boolean":
                val = val ? "true" : "false";
                break;

            case "time":
                val = format_date("hh:mm:ss.ms", date(val));
                break;

            case "base64Binary":
                val = make_base64_string(val);
                break;

            case "hexBinary":
                val = make_hex_string(val);
                break;
        }

        #printf("DEBUG: FORCE: type: %y, nstype: %y, val: %y\n", type, nstype, val);
        if (omit_type)
            return val;
        else
            return (
                "^attributes^": (
                    "xsi:type": sprintf("%s:%s", ons, type),
                ),
                "^value^": val,
            );
    }

    any deserialize(string en, *TypeMap tmap, *hash mrh, any val) {
        string type;
        if (val.typeCode() == NT_HASH && val.hasKey("^value^")) {
            if (val."^attributes^"."xsi:type") {
                type = val."^attributes^"."xsi:type";
                string t = (type =~ x/\w+:(\w+)/)[0];
                if (exists t)
                    type = t;

                if (name != "anyType" && type != name)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting base type %y, got %y", name, val."^attributes^"."xsi:type");
            }
            else
                type = name;
            val = val."^value^";
        }
        else
            type = name;

        switch (type) {
            case "string":
            case "anyURI":
                return string(val);

            case "integer": {
                # note that we do not convert xsd:integer to a qore integer if we would lose precision
                int v = int(val);
                return v == val ? v : val;
            }

            case "byte":
                val = int(val);
                if ((val & 0xff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "short":
                val = int(val);
                if (val < RANGE_SHORT[0] || val > RANGE_SHORT[1])
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "int":
                val = int(val);
                if (val < RANGE_INT[0] || val > RANGE_INT[1])
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "long":
                return int(val);

            case "unsignedByte":
                val = int(val);
                if ((val & 0xff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedShort":
                val = int(val);
                if ((val & 0xffff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedInt":
                val = int(val);
                if ((val & 0xffffffff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedLong":
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return int(val);

            case "negativeInteger":
                if (val >= 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts negative values (value supplied: %d)", name, val);
                return int(val);

            case "nonNegativeInteger":
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts non-negative values (value supplied: %d)", name, val);
                return int(val);

            case "nonPositiveInteger":
                if (val > 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts non-positive values (value supplied: %d)", name, val);
                return int(val);

            case "positiveInteger":
                if (val <= 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts positive values (value supplied: %d)", name, val);
                return int(val);

            case "date":
                # remove dashes from date
                val =~ s/-//g;
                return date(val);

            case "dateTime":
                return date(substr(val, 0, 4) + substr(val, 5, 2) + substr(val, 8, 2) +
                            substr(val, 11, 2) + substr(val, 14, 2) + substr(val, 17, 2));

            case "time":
                return date("19700101" + substr(val, 0, 2) + substr(val, 3, 2) + substr(val, 6, 2)) +
                       milliseconds(substr(val, 9, 3));

            case "boolean":
                if (val =~ /true/i)
                    return True;
                if (val =~ /false/i)
                    return False;
                return boolean(val);

            case "decimal":
                return float(val);

            case "base64Binary":
                return val.empty() ? binary() : parse_base64_string(val);

            case "hexBinary":
                return val.empty() ? binary() : parse_hex_string(val);

            default: {
                if (name == "anyType")  {
                    *XsdAbstractType t = tmap.tryGet(type);
                    if (t)
                        return t.deserialize(en, tmap, mrh, val);
                }
                throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }
}

#! class for XSD array types; currently only supports "binary"; used, for example with HTTP MultiPart messages
public class WSDL::XsdArrayType inherits WSDL::XsdAbstractType {
    constructor(string t, Namespaces nsc) : XsdAbstractType(t, "ns1", nsc) {
        if (t != "binary")
            throw "XSD-ARRAYTYPE-ERROR", sprintf("don't know how to handle arrays of type %y", t);
    }

    any serialize(any val, *softbool omit_type) {
        switch (name) {
            case "binary": {
                int t = val.typeCode();
                if (t === NT_STRING)
                    val = binary(val);
                else if (t !== NT_BINARY)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize type %y from type %y; requires string or binary", name, t);
                return val;
            }

            default: {
                throw SOAP_SERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }

    any deserialize(string en, *TypeMap tmap, *hash mrh, any val) {
        switch (name) {
            case "binary": {
                if (val.typeCode() != NT_BINARY)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize type %y from type %y; requires binary", name, val.typeName());
                return val;
            }

            default: {
                throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }
}

#! XSD typed data class
public class WSDL::XsdTypedData inherits WSDL::XsdNamedData {
    public {
        any type;
    }

    constructor(reference e) : XsdNamedData(\e) {
    }
}

#! XSD attribute class
public class WSDL::XsdAttribute inherits WSDL::XsdTypedData {
    public {
        string use = "optional";

        const AllowedUseValues = (
            "optional": True,
            "required": True,
            "prohibited": True,
            );
    }

    constructor(hash attr, Namespaces nsc, *XsdAbstractType n_type, XsdLateResolverHelper unresolved) : XsdTypedData(\attr) {
        *hash aa = attr."^attributes^";
        if (aa.type) {
            type = nsc.doType(aa.type);

            if (aa.use) {
                if (!AllowedUseValues.(aa.use))
                    throw "XSD-ATTRIBUTE-ERROR", sprintf("attribute %y: use %y is unrecognized; recognized use values: %y", name, aa.use, AllowedUseValues.keys());
                use = aa.use;
            }

            # add self to unresolved list if element type cannot be resolved
            if (!(type instanceof XsdAbstractType))
                unresolved.add(self);
        }
    }

    any getValue(string val) {
        return type.deserialize(name, NOTHING, NOTHING, val);
    }
}

#! XSD element class
public class WSDL::XsdElement inherits WSDL::XsdTypedData {
    public {
        int minOccurs = 1;
        int maxOccurs = 1;
        bool nillable = False;
        *string ref;
        bool usedocns;
    }

    constructor(hash e, Namespaces nsc, *XsdAbstractType n_type, XsdLateResolverHelper unresolved, bool n_usedocns) : XsdTypedData(\e) {
        usedocns = n_usedocns;

        if (!ns)
            ns = nsc.getTargetNamespaceUri();

        if (n_type) {
            type = n_type;
            return;
        }

        *hash a = e."^attributes^";

        if (exists a.minOccurs)
            minOccurs = int(a.minOccurs);

        if (exists a.maxOccurs)
            if (a.maxOccurs == "unbounded")
                maxOccurs = -1;
            else
                maxOccurs = int(a.maxOccurs);

        if (maxOccurs != -1 && minOccurs > maxOccurs)
            throw "XSD-ELEMENT-ERROR", sprintf("minOccurs (%d) > maxOccurs (%d) for element %s", minOccurs, maxOccurs, name);

        if (a.nillable == "true")
            nillable = True;

        if (a.type) {
            type = nsc.doType(a.type);

            # add self to unresolved list if element type cannot be resolved
            if (!(type instanceof XsdAbstractType)) {
                #printf("DEBUG: self: %y\n", self);
                unresolved.add(self);
            }
        }
        else if (e.simpleType)
            type = new XsdSimpleType(e.simpleType, nsc, unresolved, usedocns, sprintf("simpleType for element %y", name));
        else if (e.hasKey("complexType")) {
            type = new XsdComplexType(e.complexType, nsc, unresolved, usedocns, sprintf("complexType for element %y", name));
            if (!type.isRequired() && !exists a.minOccurs)
                minOccurs = 0;
            if (type.isNillable() && !exists a.nillable)
                nillable = True;
        }
        else if (e."^attributes^".ref) {
            ref = e."^attributes^".ref;
            unresolved.add(self);
        }
    }

    assimilate(WSDL::XsdElement other) {
        map self.$1 = other.$1, other.keyIterator(), !exists self.$1;
        # we have to use the namespace of the referenced element
        ns = other.ns;
    }

    bool isRequired() {
        return minOccurs > 0;
    }

    bool isNillable() {
        return nillable;
    }

    /*
    bool isRequired() {
        #printf("DBG %y: required nillable: %y minOccurs: %y type: %y\n", name, nillable, minOccurs, ((type instanceof XsdAbstractType && type.isRequired()) | True));
        return !nillable && minOccurs && ((type instanceof XsdAbstractType && type.isRequired()) | True);
    }
    */

    any serialize(any h, *softbool omit_type, string key, string typename) {
        if (type.typeCode() == NT_HASH)
            printf("ERROR: %y\n", self);

        if (h."^type^" && h."^type^" instanceof XsdAbstractType && h.hasKey("^val^")) {
            XsdAbstractType ntype = cast<XsdAbstractType>(h."^type^");
            ntype.checkExtends(type, name);
            return serializeAsIntern(ntype, h."^val^", omit_type, key, name);
        }

        return serializeAsIntern(type, h, omit_type, key, typename);
    }

    private any serializeAsIntern(XsdAbstractType type, any h, *softbool omit_type, string key, string typename) {
        #printf("DEBUG: XsdElement::serializeAsIntern() name: %y (with type: %y) h: %y key: %y typename: %y (%y) minOccurs: %y nillable: %y (%y %y)\n", name, ((!omit_type || type != self.type) && type.hasRealName()), h, key, typename, type.getName(), minOccurs, nillable, !exists h, !minOccurs);

        int tc = h.typeCode();
        if (tc == NT_LIST && h.size() == 1)
            h = h[0];

        if (!exists h || (tc == NT_LIST && h.empty())) {
            if (!minOccurs)
                return;

            if (nillable || type.isNillable()) {
                hash rh = ("xsi:nil": "true");
                if ((!omit_type || type != self.type) && type.hasRealName())
                    rh += ("xsi:type": type.getNameWithNS());
                return ("^attributes^": rh);
            }

            if (!type.isRequired())
                return;

            if (!type.requiresValue())
                return ("^value^": NOTHING);

            throw SOAP_SERIALIZATION_ERROR, sprintf("missing element %y value for %s::%s (minOccurs: %d, type %y)", name, typename, key, minOccurs, type.getName());
        }

        *hash pf;
        if ((!omit_type || type != self.type) && type.hasRealName())
            pf = ("^attributes^": ("xsi:type": !usedocns ? type.getName() : type.getNameWithNS()));

        if (tc == NT_LIST) {
            int len = h.size();
            if (maxOccurs == 1 && len > 1)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y of type %y from a list with %d elements because maxOccurs = 1", name, type.getName(), len);
            if (len > maxOccurs && maxOccurs > 0)
                throw SOAP_SERIALIZATION_ERROR, sprintf("list for element %y of type %y has %d element%s, but maxOccurs = %d", name, type.getName(), elements h, elements h == 1 ? "" : "s", maxOccurs);
            if (len < minOccurs)
                throw SOAP_SERIALIZATION_ERROR, sprintf("list for element %y of type %y has %d element%s, but minOccurs = %d", name, type.getName(), elements h, elements h == 1 ? "" : "s", minOccurs);

            list l = ();
            foreach any e in (h) {
                l += (pf + type.serialize(e, omit_type));
            }
            return l;
        }
        if (minOccurs > 1)
            throw SOAP_SERIALIZATION_ERROR, sprintf("only one element passed to element %y of type %y, but minOccurs = %d", name, type.getName(), minOccurs);

        #printf("DEBUG: element %y type %s: %y omit_type: %y h: %y\n", name, type.className(), type.name, omit_type, h);
        return (pf + type.serialize(h, omit_type));
    }

    any deserialize(*TypeMap tmap, *hash mrh, any val, bool present) {
        #printf("XsdElement::deserialize() name: %y type: %y (nillable: %y) val: %y present: %y\n", name, type.getName(), type.isNillable(), val, present);
        *hash a = val."^attributes^";
        if (a)
            WSDL::XsdBase::removeNS(\a);

        if ((!exists val && !present) || a.nil == "true") {
            if (nillable || type.isNillable() || !minOccurs)
                return;
            throw SOAP_DESERIALIZATION_ERROR, sprintf("NOTHING passed for element %y type %y, but nillable=False and minOccurs: %d", name, type.getName(), minOccurs);
        }

        if (val.typeCode() == NT_LIST) {
            int el = elements val;
            if (maxOccurs != -1 && el > maxOccurs)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, maxOccurs: %d but list is %d elements long", name, maxOccurs, el);
            if (el < minOccurs)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, minOccurs: %d but list is %d elements long", name, minOccurs, el);

            list l;
            foreach any e in (val)
                l[elements l] = type.deserialize(name, tmap, mrh, getValue(mrh, e));
            return l;
        }

        if (minOccurs > 1)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("single value passed for element %y, but minOccurs: %d", name, minOccurs);

        return type.deserialize(name, tmap, mrh, getValue(mrh, val));
    }
}

#! XSD simple type class
public class WSDL::XsdSimpleType inherits WSDL::XsdAbstractType {
    public {
        hash enum;
        any type;
        bool usedocns;
    }

    constructor(hash st, Namespaces nsc, XsdLateResolverHelper unresolved, bool n_usedocns, *string desc_name) : XsdAbstractType(\st, nsc, desc_name) {
        usedocns = n_usedocns;
        #any a = st."^attributes^";
        delete st."^attributes^";

        WSDL::XsdBase::removeNS(\st);

        if (st.restriction) {
            *hash r = st.restriction;

            any base = r."^attributes^".base;
            if (!base)
                throw "XSD-SIMPLETYPE-ERROR", sprintf("missing 'base' attribute in simpleType %y restriction", name);

            type = nsc.doType(base);

            # add base type to unresolved list if type cannot be resolved
            if (!(type instanceof XsdData))
                unresolved.add(self);

            WSDL::XsdBase::removeNS(\r);

            if (r.enumeration)
                enum = map {$1."^attributes^".value: True}, r.enumeration;
        }
        else
            throw "XSD-SIMPLETYPE-ERROR", sprintf("missing restriction element in simpleType %y", name);

        #printf("DEBUG: st: %y\n", self); exit();
    }

    any serialize(any val, *softbool omit_type) {
        if (enum && !enum{val})
            throw "SOAP-SERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y is not in the enumeration list (%y)", val, name, enum.keys());

        return type.serialize(val, omit_type);
    }

    any deserialize(string en, *TypeMap tmap, *hash mrh, any val) {
        any v = type.deserialize(en, tmap, mrh, val);

        if (enum && !enum{v})
            throw "SOAP-DESERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y while deserializing element %y is not in the enumeration list (%y)", v, name, en, enum.keys());

        return v;
    }
}

#! XSD complex type class
public class WSDL::XsdComplexType inherits WSDL::XsdAbstractType {
    public {
        any array;
        any restriction;
        *string extension;

        bool usedocns;

        *hash elementmap;
        bool anyAttribute = False;

        bool nillable = False;
        bool required = False;
        bool requires_value = False;

        # attributes
        hash attrs;

        # any annotated documentation
        *string documentation;

        # simpleContent type
        any simpleType;

        # finalization flag
        bool finalized = False;

        # multiple choice blocks
        list choices = ();
    }

    private {
        #! type of complexType object
        string cx_type;

        const XET_ALL      = "ALL";
        const XET_CHOICE   = "CHOICE";
        const XET_SEQUENCE = "SEQUENCE";
        const XET_SIMPLE   = "SIMPLE";
        const XET_NONE     = "NONE";
    }

    # ct can be NOTHING in case of an empty complex type
    constructor(*hash ct, Namespaces nsc, XsdLateResolverHelper unresolved, bool n_usedocns, *string desc_name) : XsdAbstractType(\ct, nsc, desc_name) {
        usedocns = n_usedocns;
        #any a = ct."^attributes^";
        delete ct."^attributes^";

        *hash d = ct.complexContent;
        if (d) {
            WSDL::XsdBase::removeNS(\d);
            if (d.restriction) {
                WSDL::XsdBase::removeNS(\d.restriction);

                any base = d.restriction."^attributes^".base;

                # FIXME: handle namespace
                (*string ns, *string tn) = base =~ x/(\w+):(\w+)/;
                if (exists tn) {
                    if (tn == "Array") {
                        # FIXME check that namespace is SOAP encoding
                        any aa = d.restriction.attribute."^attributes^";
                        WSDL::XsdBase::removeNS(\aa);
                        if (!exists aa.arrayType)
                            throw WSDL_ERROR, sprintf("cannot parse complexType restriction: %y", d.restriction);

                        # FIXME: handle multiple dimensions?
                        (*string ans, *string atn) = aa.arrayType =~ x/(\w+):(\w+)\[\]$/;
                        if (exists atn) {
                            array.val = atn;
                            array.ns  = ans;
                        }
                        else
                            array.val = aa.arrayType;

                        delete d.restriction.attribute;
                        #printf("DEBUG: ans: %y atn: %y aa: %y\n", ans, atn, aa);
                        return;
                    }
                    else {
                        restriction = tn;
                    }
                }

                delete d.restriction."^attributes^";

                parseData(d.restriction, unresolved);
            }
            else if (d.extension) {
                #any etype = nsc.doType(d.extension."^attributes^".base);
                #if (!(etype instanceof XsdAbstractType))
                #    unresolved.add(self);
                extension = d.extension."^attributes^".base;

                # FIXME: check for soap encoding namespace
                extension =~ s/(.*:)(.*)/$2/;
                delete d.extension."^attributes^";
                WSDL::XsdBase::removeNS(\d.extension);

                parseData(d.extension, unresolved);
            }
            else
                throw "XSD-COMPLEXCONTENT-ERROR", sprintf("can't parse complexContent %y %y information", getName(), d.firstKey());
        }
        else if (ct.simpleContent) {
            d = ct.simpleContent;
            WSDL::XsdBase::removeNS(\d);
            cx_type = XET_SIMPLE;
            simpleType = nsc.doType(d.extension."^attributes^".base);
            remove d.extension."^attributes^";
            if (!(simpleType instanceof XsdAbstractType))
                unresolved.add(self);
            WSDL::XsdBase::removeNS(\d.extension);
            parseAttributes(\d.extension, unresolved);
        }
        else if (ct)
            parseData(ct, unresolved);
        else {
            # empty complex type
            cx_type = XET_NONE;
            required = True;
            requires_value = False;
        }
    }

    finalize(TypeMap tmap, Namespaces nsc) {
        if (finalized)
            return;
        finalized = True;

        # process restriction info
        if (restriction) {
            # combine base type and new type
            XsdAbstractType t = tmap.get(restriction);
            if (!(t instanceof XsdComplexType))
                throw WSDL_ERROR, sprintf("cannot restrict complexType %y with type %y", name, t.name);
            cast<XsdComplexType>(t).finalize(tmap, nsc);
            elementmap = cast<XsdComplexType>(t).elementmap + elementmap;
            #printf("DEBUG: extended %s with %s (%y)\n", name, restriction, cast<XsdComplexType>(t).elementmap.keys());
        }
        # process extension info
        else if (extension) {
            XsdAbstractType t = tmap.get(extension);
            if (!(t instanceof XsdComplexType))
                throw WSDL_ERROR, sprintf("cannot extend complexType %y with type %y", name, t.name);
            cast<XsdComplexType>(t).finalize(tmap, nsc);
            # combine base type and new type
            elementmap = cast<XsdComplexType>(t).elementmap + elementmap;
            #printf("DEBUG: extended %s (%s) with %s (%y) elements: %y\n", name, self.uniqueHash(), extension, cast<XsdComplexType>(t).elementmap.keys(), elementmap.keys());
        }

        # process array info
        if (array) {
            any et = array.val;
            *XsdAbstractType t = tmap.tryGet(et);
            array = new XsdArrayType(t ? t : et, nsc);
        }
    }

    #! throws an exception if the types are not compatible
    checkExtends(XsdAbstractType t, string ename) {
        if (extension == t.name || t == self)
            return;
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible%s", name, ename, t.name, extension ? sprintf("; %y extends %y", name, extension) : "");
    }

    private parseData(hash d, XsdLateResolverHelper unresolved) {
        delete d.ns;
        if (d.annotation) {
            *hash ah = remove d.annotation;
            if (ah.size() == 1 && ah.firstKey() =~ /documentation$/)
                documentation = trim(ah.firstValue());
        }
        if (!d)
            return;

        parseAttributes(\d, unresolved);

        if (!d) {
            cx_type = XET_NONE;
            required = True;
            requires_value = False;
            return;
        }

        if (d.size() > 1)
            throw WSDL_ERROR, sprintf("%s: expecting a single element in the complexType hash, got: %y", name, d.keys());

        string k = d.firstKey();
        if (k == "all") {
            cx_type = XET_ALL;
            WSDL::XsdBase::removeNS(\d.all);
            elementmap = parseElements(d.all.element, unresolved);
        }
        else if (k == "choice") {
            cx_type = XET_CHOICE;
            WSDL::XsdBase::removeNS(\d.choice);
            elementmap = parseElements(d.choice.element, unresolved);
        }
        else if (k == "sequence") {
            cx_type = XET_SEQUENCE;
            WSDL::XsdBase::removeNS(\d.sequence);
            if (d.sequence.element)
                elementmap = parseElements(d.sequence.element, unresolved);
            WSDL::XsdBase::removeNS(\d.sequence.choice);
            foreach hash ch in (d.sequence.choice) {
                #printf("ch: %y\n", ch);
                *hash h = parseElements(ch.element, unresolved, False);
                if (h) {
                    hash ech.elementmap = h;
                    if (ch."^attributes^".minOccurs > 0)
                        ech.required = True;
                    choices += ech;
                }
            }
        }
        else
            throw "XSD-COMPLEXTYPE-ERROR", sprintf("unknown keys in %y", d);
    }

    private parseAttributes(reference d, XsdLateResolverHelper unresolved) {
        # process attributes if any
        foreach hash ah in (remove d.attribute) {
            if (ah."^attributes^") {
                XsdAttribute attr(ah, nsc, NOTHING, unresolved);
                attrs.(attr.name) = attr;
            }
        }

        if (d.hasKey("anyAttribute")) {
            anyAttribute = True;
            delete d.anyAttribute;
        }
    }

    bool isNillable() {
        return nillable;
    }

    bool isRequired() {
        return required;
    }

    bool requiresValue() {
        return requires_value;
    }

    private *hash parseElements(softlist el, XsdLateResolverHelper unresolved, bool for_object = True) {
        #printf("DEBUG: XsdComplexType::parseElements(%y)\n", el);
        hash h;
        foreach hash e in (el) {
            #printf("DEBUG: XsdComplexType::parseElements() ns: %y e: %y\n", nsc.getTargetNamespaceUri(), e);
            XsdElement elem(e, nsc, NOTHING, unresolved, usedocns);
            h.(elem.name) = elem;

            if (for_object && !required && elem.isRequired())
                required = True;
        }

        if (for_object) {
            if (h.size() == 1 && h.firstValue().isNillable())
                nillable = True;
        }

        if (for_object && required && !nillable)
            requires_value = True;

        return h;
    }

    private *hash serializeElement(string key, XsdElement element, any h, *softbool omit_type) {
        any v = h{key};
        string e_ons;
        #printf("DEBUG: XsdComplexType::serializeElement() key: %y v: %y h: %y ns: %y\n", key, v, h, nsc.getTargetNamespaceUri());
        any e = element.serialize(v, omit_type, key, name);

        if (!exists e && !element.isRequired())
            return;

        /*
        if (e_ons != ons && e_ons != "xsd") {
            if (e.typeCode() != NT_HASH)
                e = ("^value^": e);
            e."^attributes^" = ("xmlns": nsc.getOutputNamespaceUri(ons));
        }
        */

        hash rv.(!usedocns ? key : (nsc.getOutputNamespacePrefix(element.ns) + ":" + key)) = e;
        return rv;
    }

    *hash serialize(any h, *softbool omit_type) {
        if (exists array)
            return array.serialize(h, omit_type);

        # process attributes first
        *hash ah;
        if (h.typeCode() == NT_HASH) {
            if (h."^attributes^") {
                hash mah = remove h."^attributes^";
                foreach string k in (mah.keyIterator()) {
                    if (!attrs{k})
                        throw SOAP_SERIALIZATION_ERROR, sprintf("cannot set unknown attribute %y of element %y; known attributes: %y", k, getName(), attrs.keys());
                    if (attrs{k}.use == "prohibited")
                        throw SOAP_SERIALIZATION_ERROR, sprintf("cannot set attribute %y of element %y; the WSDL marks this attribute as prohibited", k, getName());
                    ah{k} = mah{k};
                }
            }
            # check for required attributes
            foreach XsdAttribute attr in (attrs.iterator()) {
                if (attr.use == "required" && !exists ah.(attr.name))
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y without attribute %y; the WSDL marks this attribute as required", getName(), attr.name);
            }
        }

        hash rh;

        if (cx_type == XET_SIMPLE) {
            if (exists h."^value^")
                h = h."^value^";
            rh."^value^" = simpleType.serialize(h, omit_type);
        }
        else if (cx_type != XET_NONE) {
            if (exists h && h.typeCode() != NT_HASH)
                throw SOAP_SERIALIZATION_ERROR, sprintf("expecting hash argument to serialize from complexType %y (got %y, type %y)", getName(), h, type(h));

            if (cx_type == XET_SEQUENCE || cx_type == XET_ALL) {
                foreach string p in (elementmap.keyIterator()) {
                    #printf("DEBUG element: %y (%y)\nvalue: %y\n", p, elementmap{p}, h{p});
                    rh += serializeElement(p, elementmap{p}, h, omit_type);
                    delete h{p};
                }

                # also serialize each choice block, if any
                foreach hash ch in (choices) {
                    *hash vh = h.(ch.elementmap.keys());
                    if (!vh) {
                        if (ch.required)
                            throw SOAP_SERIALIZATION_ERROR, sprintf("expecting one of %y to serialize choice / union in complexType %y but no such keys were supplied", ch.elementmap.keys(), getName());
                    }
                    else {
                        hash rch = serializeChoice(ch.elementmap, vh, omit_type);
                        # remove the serialized key from the input hash for the check below
                        remove h{vh.firstKey()};
                        rh += rch;
                    }
                }

                if (h) {
                    any kl = h.size() == 1 ? h.firstKey() : h.keys();
                    throw SOAP_SERIALIZATION_ERROR, sprintf("%y %s of type %y (valid elements: %y)", kl, kl.lsize() == 1 ? "is an invalid member" : "are invalid members", getName(), elementmap.keys());
                }
            }
            else { # "choice" - union
                rh = serializeChoice(elementmap, h, omit_type);
            }
        }
        else { # "none"
            rh."^value^" = NOTHING;
        }

        #printf("DEBUG name: %y desc: %y\n", name, descriptive_name);
        if (name && !omit_type && !descriptive_name)
            rh."^attributes^" += ("xsi:type": "ns1:" + name) + ah;
        else if (ah)
            rh."^attributes^" += ah;
        #printf("DEBUG complex type %s returning %y from %y\n", name, rh, h);
        return rh;
    }

    private hash serializeChoice(hash emap, hash h, *softbool omit_type) {
        if (elements h > 1)
            throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize choice / union in complexType %y with more than 1 member (%y)", getName(), h.keys());
        *string key = h.firstKey();
        if (!emap{key})
            throw SOAP_SERIALIZATION_ERROR, sprintf("%y is an invalid member of choice / union in complexType %y; expecting one of: %y", key, getName(), emap.keys());

        # add namespace if necessary
        return serializeElement(key, emap{key}, h, omit_type);
    }

    *hash deserialize(string en, *TypeMap tmap, *hash mrh, any oval) {
        if (exists array)
            return array.deserialize(en, tmap, mrh, oval);

        if (!exists oval) {
            if (!required)
                return;
        }

        hash rh;

        *hash val = oval;
        *hash attr = val."^attributes^";

        # attribute hash
        *hash ah;
        if (attr) {
            # parse incoming valid attributes
            foreach XsdAttribute xa in (attrs.iterator()) {
                *string attr_val = val."^attributes^".(xa.name);
                if (xa.use == "required" && !exists attr_val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y without attribute %y; the WSDL marks this attribute as required", getName(), xa.name);
                if (exists attr_val) {
                    if (attr.use == "prohibited")
                        throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y with attribute %y; the WSDL marks this attribute as prohibited", getName(), xa.name);
                    ah.(xa.name) = xa.getValue(attr_val);
                }
            }

            delete val."^attributes^";

            # ensure types match
            *string tn = attr."xsi:type";
            if (exists tn) {
                (*string ns, *string tname) = tn =~ x/(.*):(.*)/;
                if (exists tname)
                    tn = tname;
                if (tn != name) {
                    # check for compatible extension
                    *XsdAbstractType t = tmap.tryGet(tn);
                    #printf("DEBUG: type provided %y: %y\n", tn, t.name);
                    if (t) {
                        t.checkExtends(self, en);
                        return t.deserialize(en, tmap, mrh, oval);
                    }

                    throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting ComplexType type %y for element %y, got %y", getName(), en, tn);
                }
            }
        }

        if (val.typeCode() == NT_HASH) {
            WSDL::XsdBase::removeNS2(\val);

            #any ns = val.".ns";
            val -= ".ns";
        }

        if (cx_type == XET_SIMPLE) {
            if (!exists val && !required)
                return;
            any sv = simpleType.deserialize(name, tmap, mrh, val);
            if (sv.typeCode() == NT_HASH)
                rh = sv;
            else
                rh."^value^" = sv;
        }
        else if (cx_type != XET_NONE) {
            if (exists val && val.typeCode() != NT_HASH)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y type %y from qore type %y (expecting hash)", en, getName(), val.type());

            if (cx_type == XET_SEQUENCE || cx_type == XET_ALL) {
                #printf("XsdComplexType::deserialize() name: %y val: %y required: %y\n", getName(), val, required);
                # if we have one element
                if (elementmap.size() == 1 && val.size() == 1
                    && val.firstKey() == elementmap.firstKey()
                    && !exists val{elementmap.firstKey()} && !required && !choices)
                    return;

                foreach string p in (elementmap.keyIterator()) {
                    #printf("element %y\n", p);
                    rh{p} = elementmap{p}.deserialize(tmap, mrh, getValue(mrh, val{p}), val.hasKey(p));
                    delete val{p};
                }
                # also parse each choice block, if any
                foreach hash ch in (choices) {
                    *hash vh = val.(ch.elementmap.keys());
                    *hash h = parseChoice(vh, ch.elementmap, en, tmap, mrh, ch.required);
                    if (h)
                        rh += h;
                    delete val.(h.keys());
                    #printf("choice em: %y h: %y\n", ch.elementmap.keys(), h);
                }
                delete val."^attributes^";
                if (val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("invalid element %y passed in type %y for element %y (expecting %y)", (keys val)[0], getName(), en, keys elementmap);
            }
            else { # "choice" - union
                rh += parseChoice(val, elementmap, en, tmap, mrh, True);
            }
        }

        if (ah)
            rh."^attributes^" = ah;
        return rh;
    }

    private *hash parseChoice(hash val, hash emap, string en, *TypeMap tmap, *hash mrh, *bool required) {
        list kl = val.keys();
        if (elements kl > 1)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("too many elements supplied for choice / union in type %y for element %y (%y)", getName(), en, kl);
        *string key = kl[0];
        if (!exists key) {
            if (required)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("missing element for choice / union in type %y for element %y (expecting one of: %y)", getName(), en, emap.keys());
            return;
        }
        if (!exists emap{key})
            throw SOAP_DESERIALIZATION_ERROR, sprintf("element %y is not a valid element for choice / union in type %y for element %y (valid elements: %y)", key, getName(), en, emap.keys());

        return (key: emap{key}.deserialize(tmap, mrh, getValue(mrh, val{key}), val.hasKey(key)));
    }
}

#! web service operation class
public class WSDL::WSOperation inherits WSDL::XsdNamedData {
    public {
        #! request message
        WSMessage input;
        #! response message
        WSMessage output;
        #! request message name
        *string input_name;
        #! response message name
        *string output_name;
        #! internal type map
        TypeMap tmap;

        #! namespace container
        Namespaces nsc;

        #! the SOAPAction header value to send with this operation
        *string soapAction;

        #! the top-level request name
        *string request_name;

        #! request multipart hash
        /** this has has the following keys:
            - \c "multipart": the multipart type name (ex: \c "related")
            - \c "body": a hash of the XML attributes of the body declaration in the part
            - \c "parts": a hash keyed by part name with values of types for the part
         */
        *hash inp;

        #! response multipart hash
        /** this has has the following keys:
            - \c "multipart": the multipart type name (ex: \c "related")
            - \c "body": a hash of the XML attributes of the body declaration in the part
            - \c "parts": a hash keyed by part name with values of types for the part
         */
        *hash outp;

        #! if the operation requires document style encoding
        bool docstyle = False;

        #! a hash with info about soap header requirements for request messages
        /** the hash has the following keys:
            - \c "part": the part name to use for the header
            - \c "msg": a WSMessage object to use for serialization
            - \c "encoded": currently ignored
         */
        hash iheader;

        #! currently unused; reserved to be used to serialize header information for response messages
        hash oheader;
    }

    #! creates the WSOperation object from the arguments supplied
    /** @param p the raw hash from deserialized XML data for the operation
        @param n_tmap a reference to an object of a private class that stores XSD type information from types defined in the WSDL
        @param n_nsc the namespace container
        @param messages a hash of messages defined in the WSDL; keys are message names; values are WSMessage objects
     */
    constructor(hash p, TypeMap n_tmap, Namespaces n_nsc, *hash messages) : XsdNamedData(\p) {
        tmap = n_tmap;
        nsc = n_nsc;

        if (p.input) {
            hash msghash = processNSValue(p.input."^attributes^");

            *WSMessage msg = messages.(msghash.message.val);
            if (!msg)
                throw WSDL_ERROR, sprintf("missing definition for input message %y required by operation %y", msghash.name.val, name);
            input = msg;

            #printf("DBG: WSOperation::constructor() name: %y msghash: %y\n", name, msghash);
            if (msghash.name)
                input_name = msghash.name.val ? msghash.name.val : msghash.name;
        }

        if (p.output) {
            hash msghash = processNSValue(p.output."^attributes^");

            *WSMessage msg = messages.(msghash.message.val);
            if (!msg)
                throw WSDL_ERROR, sprintf("missing definition for output message %y required by operation %y", msghash.name.val, name);

            output = msg;
            if (msghash.name)
                output_name = msghash.name.val ? msghash.name.val : msghash.name;
        }

        *string op_ns = nsc.getTargetNamespaceUri();
        if (op_ns && op_ns !~ /\/$/)
            op_ns += "/";
        soapAction = op_ns ? op_ns + name : name;
    }

    #! this method is called if this operation requires document style
    setDocStyle(reference idocmap) {
        docstyle = True;

        foreach string key in (input.args.keyIterator()) {
            # FIXME: could be a type here instead of an element
            if (!input.args{key}.element.name) {
                return;
            }

            string element = input.args{key}.element.name;
            idocmap{element} = input.args{key}.element;
            if (!request_name)
                request_name = element;
        }
    }

    #! sets the top-level request name
    setTopLevelRequestElement(string name) {
        request_name = name;
    }

    #! returns the top-level request name
    string getTopLevelRequestName() {
        return request_name ? request_name : name;
    }

    #! serializes a request to an XML string for the operation
    /** @param h the request to serialize
        @param header optional soap header info to serialize if required (ex: authorization info)
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @param nsh an optional namespace hash for the output message
        @param xml_opts optional XML generation options
        @param req_soapaction if present will override any SOAPAction value for the request

        @return a hash with keys:
        - \c body: XML string in the SOAP request format
        - \c hdr: hash of HTTP headers
        */
    hash serializeRequest(any h, *hash header, *string enc, *hash nsh, *int xml_opts, *string req_soapaction) {
        # setup namespaces for SOAP envelope
        hash rh = nsc.hasSoap12() ? WSDL::ENVELOPE_12_NS : WSDL::ENVELOPE_11_NS;

        if (!exists req_soapaction)
            req_soapaction = soapAction;

        rh."soapenv:Envelope"."^attributes^" += nsc.getOutputNamespaceHash(nsh);

        #printf("DEBUG header: %y\n", header);

        if (header) {
            if (iheader) {
                hash hh.(iheader.part) = header;
                rh."soapenv:Envelope"."soapenv:Header" = iheader.msg.serializeDocument(iheader.part, NOTHING, NOTHING, hh);
            }
            else {
                rh."soapenv:Envelope"."soapenv:Header" = header;
            }
        }

        MultiPartRelatedMessage mpm;
        # do we have mime/multipart input format?
        if (exists inp.multipart)
            mpm = new MultiPartRelatedMessage();

        #printf("DEBUG: docstyle: %y\n", docstyle);
        if (input) {
            if (docstyle)
                rh."soapenv:Envelope"."soapenv:Body" = input.serializeDocument(NOTHING, inp, mpm, h);
            else {
                string mname = input_name ? input_name : name;
                if (input)
                    rh."soapenv:Envelope"."soapenv:Body" = input.serialize(inp, mpm, mname, h);
            }
        }
        else if (exists h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("request value provided for operation %y with no input message (%y)", name, h);

        string body = make_xml(rh, xml_opts, enc);

        if (mpm) {
            mpm.splicePart(body, sprintf("<%s>", inp.body.parts), nsc.hasSoap12() ? MimeTypeSoapXml : MimeTypeXml);

            hash rv = mpm.getMsgAndHeaders();
            if (req_soapaction) {
                if (nsc.hasSoap12())
                    rv.hdr."Content-Type" += sprintf(";action: %s", req_soapaction);
                rv.hdr += ("SOAPAction": req_soapaction);
            }

            rv.hdr."Content-Type" += sprintf(";charset=%s", exists enc ? enc : get_default_encoding());
            return rv;
        }

        string ct;
        if (nsc.hasSoap12()) {
            ct = MimeTypeSoapXml;
            if (req_soapaction)
                ct += sprintf(";action: %s", req_soapaction);
        }
        else
            ct = MimeTypeXml;

        ct += sprintf(";charset=%s", exists enc ? enc : get_default_encoding());

        hash rv = (
            "hdr": ("Content-Type": ct),
            "body": body,
            );

        if (req_soapaction)
            rv.hdr += ("SOAPAction": req_soapaction);

        return rv;
    }

    #! serializes a SOAP response to an XML string for the operation
    /** @param h the response to serialize
        @param header SOAP header hash
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @param nsh namespace hash
        @param soap12 set to True if the response should use SOAP 1.2 encoding
        @param xml_opts optional XML generation options

        @return a hash with keys:
        - \c body: XML string in the SOAP request format
        - \c hdr: hash of HTTP headers
    */
    hash serializeResponse(any h, *hash header, *string enc, *hash nsh, *bool soap12, *int xml_opts) {
        if (exists soap12) {
            if (soap12) {
                if (!nsc.hasSoap12())
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize response for operation %y with SOAP 1.2 encoding; this operation does not support SOAP 1.2", name);
            }
            else {
                if (!nsc.hasSoap11())
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize response for operation %y with SOAP 1.1 encoding; this operation does not support SOAP 1.1", name);
            }
        }
        else
            soap12 = nsc.hasSoap12();

        # setup namespaces for SOAP envelope
        hash rh = soap12 ? WSDL::ENVELOPE_12_NS : WSDL::ENVELOPE_11_NS;

        rh."soapenv:Envelope"."^attributes^" += nsc.getOutputNamespaceHash(nsh);

        if (header) {
            if (oheader) {
                hash hh.(oheader.part) = header;
                rh."soapenv:Envelope"."soapenv:Header" = oheader.msg.serializeDocument(oheader.part, NOTHING, NOTHING, hh);
            }
            else {
                rh."soapenv:Envelope"."soapenv:Header" = header;
            }
        }

        MultiPartRelatedMessage mpm;
        # do we have mime/multipart output format?
        if (exists outp.multipart)
            mpm = new MultiPartRelatedMessage();

        #printf("DEBUG: docstyle: %y\n", docstyle);
        if (output) {
            if (docstyle)
                rh."soapenv:Envelope"."soapenv:Body" = output.serializeDocument(NOTHING, outp, mpm, h);
            else {
                string mname = input_name ? input_name : name + "Response";
                rh."soapenv:Envelope"."soapenv:Body" = output.serialize(outp, mpm, mname, h);
            }
        }
        else if (exists h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("response value provided for operation %y with no outut message (%y)", name, h);

        string body = make_xml(rh, xml_opts, enc);

        string ct = soap12 ? MimeTypeSoapXml : MimeTypeXml;
        if (exists mpm) {
            mpm.splicePart(body, sprintf("<%s>", outp.body.parts), ct);
            return mpm.getMsgAndHeaders();
        }

        ct += sprintf(";charset=%s", exists enc ? enc : get_default_encoding());

        return (
            "hdr": ("Content-Type": ct),
            "body": body,
            );
    }

    #! processes multi-part references and returns a hash of multi-part reference info and the updated message body hash
    private list processMultiRef(hash body) {
        # setup message info hash and multiRef lookup hash key, if any are present
        hash mrh = (
            # save original msg body hash
            "body": body,
            );
        # remove namespacr prefixes from body element keys
        WSDL::XsdBase::removeNS2(\mrh.body);

        if (body.multiRef) {
            foreach any mr in (body.multiRef)
                mrh.mrh.(mr."^attributes^".id) = mr;

            # resolve interior references to multiRefs
            foreach string id in (mrh.mrh.keyIterator()) {
                foreach string key in (mrh.mrh{id}.keyIterator()) {
                    if (key == "^attributes^")
                        continue;

                    #printf("multiRef id: %y key: %y val: %y\n", id, key, mrh.mrh{id}{key});

                    if (mrh.mrh{id}{key}.typeCode() == NT_LIST) {
                        foreach any e in (\mrh.mrh{id}{key}) {
                            any href = substr(e."^attributes^".href, 1);
                            if (exists href) {
                                if (!exists mrh.mrh{href})
                                    throw "INVALID-MULTIREF", sprintf("multiRef id: %y does not exist", href);
                                e = mrh.mrh{href};
                            }
                        }
                    }
                    else if (mrh.mrh{id}{key}.typeCode() == NT_HASH) {
                        any href = substr(mrh.mrh{id}{key}."^attributes^".href, 1);
                        if (exists href) {
                            if (!exists mrh.mrh{href})
                                throw "INVALID-MULTIREF", sprintf("multiRef id: %y does not exist", href);
                            mrh.mrh{id}{key} = mrh.mrh{href};
                        }
                    }
                }
            }

            delete body.multiRef;
        }
        #printf("mrh: %y\n", mrh.mrh);
        #printf("operation: %y\n", self);

        # remove namespace tags from element names
        WSDL::XsdBase::removeNS2(\body);
        remove body.".ns";

        return (mrh, body);
    }

    #! parses a hash representing a parsed XML request (parsed with parseXMLAsData()) for the operation and returns the corresponding Qore data structure
    /** @param o the parsed XML request (parsed with parseXMLAsData()) for the operation
        @return the Qore data structure corresponding to the request data
    */
    any deserializeRequest(hash o) {
        WSDL::XsdBase::removeNS(\o);
        WSDL::XsdBase::removeNS(\o.Envelope);

        *hash body = o.Envelope.Body;

        if (!input) {
            if (exists body)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("request body value given for operation %y with no input message: %y", name, body);
            return;
        }
        else if (!exists body)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("no request body value given for operation %y", name);

        (*hash mrh, hash msg) = processMultiRef(body);

        #any ns = msg.".ns";
        msg -= ("ns", ".ns");

        if (docstyle)
            return input.deserializeDocument(mrh, msg);

        string mname = input_name ? input_name : name;
        if (!msg{mname})
            throw SOAP_DESERIALIZATION_ERROR, sprintf("missing input message name %y as top-level element; got elements: %y", mname, keys msg);
        msg = remove msg{mname};
        XsdBase::removeNS2(\msg);
        remove msg.".ns";

        return input.deserialize(mrh, msg);
    }

    #! parses a hash representing a parsed XML response (parsed with parse_xml()) for the operation and returns the corresponding Qore data structure
    /** @param o the parsed XML response (parsed with parse_xml()) for the operation
        @return the Qore data structure corresponding to the response data
    */
    any deserializeResponse(hash o) {
        WSDL::XsdBase::removeNS2(\o);
        WSDL::XsdBase::removeNS2(\o.Envelope);

        *hash body = o.Envelope.Body;

        if (!output) {
            if (exists body)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("response value given for operation %y with no output message: %y", name, body);
            return;
        }
        else if (!exists body)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("no response body value given for operation %y", name);

        (*hash mrh, hash msg) = processMultiRef(body);

        # check for Soap Fault, if so raise an exception immediately with the fault info
        WSDL::XsdBase::removeNS2(\body);

        if (body.Fault) {
            WSDL::XsdBase::removeNS(\body.Fault);
            delete body.Fault.".ns";
            if (nsc.hasSoap12()) {
                WSDL::XsdBase::removeNS(\body.Fault.Code);
                WSDL::XsdBase::removeNS(\body.Fault.Reason);
                string desc = sprintf("The following fault response was received from the server: code: %y", body.Fault.Code.Value);
                any sc = body.Fault.Code.Subcode;
                while (exists sc) {
                    WSDL::XsdBase::removeNS(\sc);
                    desc += sprintf(", subcode: %y", sc.Value);
                    sc = sc.Subcode;
                }
                foreach any rn in (body.Fault.Reason.Text) {
                    desc += sprintf(", text: %y", rn);
                }

                throw "SOAP-SERVER-FAULT-RESPONSE", desc, body.Fault;
            }
            else {
                string desc = sprintf("The following fault response was received from the server: code: %y", body.Fault.faultcode);
                if (exists body.Fault.faultstring)
                    desc += sprintf(", faultstring: %y", body.Fault.faultstring);
                if (exists body.Fault.desc)
                    desc += sprintf(", desc: %y", body.Fault.desc);

                throw "SOAP-SERVER-FAULT-RESPONSE", desc, body.Fault;
            }
        }

        if (docstyle)
            return output.deserializeDocument(mrh, msg);

        string mname = input_name ? input_name : name + "Response";
        if (!msg{mname})
            throw SOAP_DESERIALIZATION_ERROR, sprintf("missing output message name %y as top-level element; got elements: %y", mname, keys msg);
        msg = remove msg{mname};
        XsdBase::removeNS2(\msg);
        msg -= (".ns", "ns");

        return output.deserialize(mrh, msg);
    }

    #! processes a hash of raw deserialized XML data and removes any namespace prefix from keys (saved to a \c "ns" key in the hash value assigned to the key) and returns the processed version of the hash
    static private hash processNSValue(hash h) {
        foreach string k in (keys h) {
            (*string ns, *string name) = h{k} =~ x/(\w+):(\w+)/;
            if (!name)
                h{k}.val = h{k};
            else {
                h{k}.ns = ns;
                h{k}.val = name;
            }
        }
        return h;
    }

    #! returns True if the operation is a SOAP 1.2 operation
    /** @return True if the operation is a SOAP 1.2 operation
    */
    bool isSoap12() {
        return nsc.hasSoap12();
    }

    #! returns the target namespace for the operation
    /** @return the target namespace for the operation
    */
    string getTargetNS() {
        return nsc.getTargetNamespaceUri();
    }

    #! designates the operation as requiring multi-part output (responses) and sets the multipart output type
    setOutputMultipart(string v) {
        outp.multipart = v;
        outp.parts = {};
    }

    #! parses a message part from the raw deserialized hash representing the source XML for the part
    private parsePart(reference msg, hash part) {
        WSDL::XsdBase::removeNS(\part);
        #any a = part."^attributes^";
        part -= "^attributes^";

        if (exists part.body) {
            any pa = part.body."^attributes^";
            if (pa.use != "literal")
                throw WSDL_ERROR, sprintf("unsupported body part without use=\"literal\": %y", part.body);
            msg.body = pa;
        }
        else if (exists part.content) {
            foreach any c in (part.content) {
                any pa = c."^attributes^";
                any name = pa.part;
                if (!exists name)
                    throw WSDL_ERROR, sprintf("unsupported content part without part attribute: %y", c);
                any type = pa.type;
                if (!exists type)
                    throw WSDL_ERROR, sprintf("unsupported content part without type attribute: %y", c);

                if (!exists msg.parts{name})
                    msg.parts{name} = type;
                else {
                    if (msg.parts{name}.typeCode() != NT_LIST)
                        msg.parts{name} = list(msg.parts{name});
                    msg.parts{name} += type;
                }
            }
        }
        else
            throw WSDL_ERROR, sprintf("cannot parse part: %y", part);

        #printf("DEBUG: part: %y\nmsg: %y\n", part, msg);#exit();
    }

    #! adds an output (response) part; the operation must be already flagged as requiring multi-part output
    /** @param part the raw deserialized hash from the XML describing the part
     */
    addOutputPart(hash part) {
        if (!exists outp.multipart)
            throw WSDL_ERROR, sprintf("WSOperation::addOutputPart(): internal error: cannot add a part to a non-multipart message; part: %y", part);

        parsePart(\outp, part);
    }

    #! designates the operation as requiring multi-part input (requests) and sets the multipart input type
    setInputMultipart(string v) {
        inp.multipart = v;
        inp.parts = {};
    }

    #! adds a request message part; the operation must be already flagged as requiring multi-part input (requests)
    /** @param part the raw deserialized hash from the XML describing the part
     */
    addInputPart(hash part) {
        if (!exists inp.multipart)
            throw WSDL_ERROR, sprintf("WSOperation::addInputPart(): internal error: cannot add a part to a non-multipart message; part: %y", part);

        parsePart(\inp, part);
    }

    #! sets SOAP header information for the SOAP envelope for requests with this operation
    setInputHeader(string part, WSMessage msg, bool encoded) {
        # FIXME: additional header parts are ignored!!!
        if (!iheader)
            iheader = ("part": part, "msg": msg, "encoded": encoded);
    }
}

#! web service message class
public class WSDL::WSMessage inherits WSDL::XsdNamedData {
    public {
        hash args;
        # part map; maps element names to part names
        hash pmap;
        bool encoded = False;

        # keep a reference to Namespaces
        Namespaces nsc;

        # keep a reference to the type map
        TypeMap tmap;
    }

    constructor(hash m, ElementMap emap, TypeMap n_tmap, Namespaces n_nsc) : XsdNamedData(\m) {
        nsc = n_nsc;
        tmap = n_tmap;

        #printf("DEBUG: WSMessage::constructor() m: %y emap: %y\n", m, emap);

        name = m."^attributes^".name;
        foreach any p in (m.part) {
            any arg = p."^attributes^";
            if (arg.element) {
                (*string ns, *string ename) = arg.element =~ x/(\w+):(\w+)/;
                if (!ename)
                    ename = arg.element;

                if (arg.name && arg.name != ename)
                    pmap{ename} = arg.name;

                args{ename}.element = emap.get(nsc.getNamespaceUri(ns), ename);
            }
            else {
                args{arg.name} = arg;
                args{arg.name}.type = nsc.doType(p."^attributes^".type);
            }
        }
    }

    hash serialize(any msginfo, any mpm, string n_name, any h) {
        hash rh;
        #printf("DEBUG: message %s: h: %y\n", name ,h);

        foreach string k in (args.keyIterator()) {
            any v;
            if (h.hasKey(k))
                v = remove h{k};
            else if (pmap{k} && !exists h{k})
                v = remove h.(pmap{k});

            /*
            if (!exists h{k}) {
                if (pmap{k} && !exists h{k})
                    h{k} = remove h.(pmap{k});
                else
                    throw SOAP_SERIALIZATION_ERROR, sprintf("missing message argument %y (got %y instead)", k, h.keys());
            }
            */

            any hv;
            #printf("DEBUG: arg %y with %y\n", k, args{k});
            #printf("DEBUG: arg %y with %y\n", k, v."^val^" ?? v);
            string ons;
            if (args{k}.element) {
                hv = args{k}.element.serialize(v, !encoded, k, name);
                ons = nsc.getOutputNamespacePrefix(args{k}.element.ns);
            }
            else {
                hv = args{k}.type.serialize(v, !encoded);
                ons = args{k}.type.getOutputNamespacePrefix();
            }
            #printf("DEBUG: arg %s got %y from %y (%y)\n", k, hv, v, exists args{k}.element ? args{k}.element : args{k}.type);

            #printf("DEBUG: WSMessage::serialize() k: %y args: %y, parts: %y\n", k, keys args, msginfo.parts);
            if (msginfo.parts{k}) {
                any ct = msginfo.parts{k};
                if (ct.typeCode() == NT_LIST)
                    ct = shift ct;
                mpm.addPart(hv, sprintf("<%s>", k), ct);
                hv."^attributes^".href = "cid:" + k;
            }

            string en = args{k}.element ? (ons + ":" +  k) : k;
            rh{en} = hv;
        }

        if (h.typeCode() == NT_HASH && h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", h.keys(), name);

        if (encoded)
            rh."^attributes^" += (
                "soapenv:encodingStyle": SOAP_ENCODING,
                "xmlns:soapenc": SOAP_ENCODING,
            );

        hash rvh.("ns1:" + n_name) = rh;

        return rvh;
    }

    hash serializeDocument(*string k, any msginfo, any mpm, any h) {
        hash rh;

        if (encoded)
            rh."^attributes^" += (
                "soapenv:encodingStyle": SOAP_ENCODING,
                "xmlns:soapenc": SOAP_ENCODING,
            );

        if (!k && args.size() == 1) {
            string key = args.firstKey();
            any v = (h.typeCode() == NT_HASH && h.hasKey(key)) ? remove h{key} : remove h;
            XsdBase::removeNS2(\v);
            string ons;
            any th = args{key}.element.serialize(v, !encoded, key, name);
            ons = nsc.getOutputNamespacePrefix(args{key}.element.ns);
            rh.(ons + ":" + args{key}.element.name) = th;
        }
        else {
            foreach string key in (k ? k : args.keyIterator()) {
                any val = remove h{key};
                if (val.typeCode() == NT_HASH)
                    XsdBase::removeNS2(\val);

                string ons;
                any th = args{key}.element.serialize(val, !encoded, key, name);
                ons = nsc.getOutputNamespacePrefix(args{key}.element.ns);
                rh.(ons + ":" + args{key}.element.name) = th;
            }
        }

        if (h.typeCode() == NT_HASH && h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", h.keys(), name);

        #printf("DEBUG: message %s: force_ns: %y args: %y h: %y\n", name, force_ns, keys args, h);

        return rh;
    }

    any deserialize(*hash mrh, hash val) {
        #printf("DBG WSMessage::deserialize() args: %y pmap: %y val: %y\n", args.keys(), pmap, val);
        hash ro;

        foreach string key in (args.keyIterator()) {
            bool present = val.hasKey(key);
            any v = remove val{key};
            if (v.typeCode() == NT_HASH)
                XsdBase::removeNS2(\v);

            string rk = key;
            if (pmap{key} && !args.(pmap{key}))
                rk = pmap{key};

            ro{rk} = args{key}.element
                ? args{key}.element.deserialize(tmap, mrh, getValue(mrh, v), present)
                : args{key}.type.deserialize(name, tmap, mrh, getValue(mrh, v));
        }

        if (val)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", val.keys(), name);

        # if there is only one argument, return it directly
        return ro.size() == 1 ? ro.firstValue() : ro;
    }

    any deserializeDocument(*hash mrh, any val) {
        any rh;

        *hash attr = remove val."^attributes^";

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\n", args.keys(), val);
        if (args.size() == 1) {
            string key = args.firstKey();
            bool present;
            any v;
            if (val.typeCode() == NT_HASH && val.hasKey(key)) {
                present = True;
                v = remove val{key};
            }
            else {
                present = exists val;
                v = remove val;
            }
            XsdBase::removeNS2(\v);
            rh = args.firstValue().element.deserialize(tmap, mrh, v, present);
        }
        else {
            foreach string key in (args.keyIterator()) {
                bool present = val.hasKey(key);
                any v = remove val{key};
                XsdBase::removeNS2(\v);
                rh{key} = args{key}.element.deserialize(tmap, mrh, v, present);
            }
        }

        if (val)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", val.keys(), name);

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\nRH: %y\n", args.keys(), val, rh);
        return rh;
    }
}

# private helper class for lazy name resolution
class WSDL::XsdLateResolverHelper {
    private { list l = (); }

    constructor() {
    }

    add(any v) {
        l += v;
    }

    list getList() {
        return l;
    }

    clearResolved() {
        l = map $1, l, !isResolved($1);
    }

    bool isResolved(XsdSimpleType t) {
        return t.type instanceof XsdData;
    }

    bool isResolved(XsdTypedData t) {
        return t.type instanceof XsdData;
    }

    bool isResolved(XsdComplexType t) {
        return t.simpleType instanceof XsdData;
    }

    bool isResolved(any t) {
        return False;
    }
}

#! class for WSDL bindings
public class WSDL::Binding inherits WSDL::XsdNamedData {
    public {
        bool docStyle = False;
    }

    private {
        string port;
    }

    constructor(hash data, Namespaces nsc, hash opmap, reference idocmap, *hash messages) : XsdNamedData(\data) {
        # get binding attributes
        {
            *hash ba = data."^attributes^";

            (*string ns, *string prt) = ba.type =~ x/(?:(\w+):)?(\w+)/;
            if (!prt)
                throw WSDL_ERROR, sprintf("missing port type for binding %y", name);
            port = prt;
        }

        if (data.binding) {
            *hash bba = data.binding."^attributes^";
            if (bba.verb)
                throw WSDL_ERROR, sprintf("binding %y declares unsupported HTTP %y binding; support for HTTP bindings has not yet been implemented", name, bba.verb);

            if (bba.transport) {
                if (!SOAP_TRANSPORT.(bba.transport))
                    throw WSDL_ERROR, sprintf("unsupported transport %y in binding %y (known transports: %y)", bba.transport, name, SOAP_TRANSPORT.keys());
            }
            else
                throw WSDL_ERROR, sprintf("missing SOAP transport in binding %y (known SOAP transports: %y)", bba.transport, name, SOAP_TRANSPORT.keys());

            if (bba.style == "document")
                docStyle = True;
        }

        foreach hash ophash in (data.operation) {
            string opname = ophash."^attributes^".name;

            *WSOperation op = opmap{opname};
            if (!exists op)
                throw WSDL_ERROR, sprintf("binding %y for %y references unknown operation %y", name, data.name, opname);

            WSDL::XsdBase::removeNS(\ophash);

            *string sa = ophash.operation."^attributes^".soapAction;
            if (exists sa) {
                #printf("GOT: %s sa: %y\n", opname, sa);
                op.soapAction = sa;
            }

            if (docStyle || ophash.operation."^attributes^".style == "document") {
                op.setDocStyle(\idocmap);
            }

            if (op.input) {
                WSDL::WSMessage input = op.input;

                WSDL::XsdBase::removeNS(\ophash.input);
                if (exists ophash.input.body) {
                    if (ophash.input.body."^attributes^".use == "encoded") {
                        input.encoded = True;
                        #printf("DEBUG: setting encoding = True for %y.%y input\n", data.name, opname);
                    }
                }
                else if (exists ophash.input.multipartRelated) {
                    op.setInputMultipart(Mime::MPT_RELATED);
                    WSDL::XsdBase::removeNS(\ophash.input.multipartRelated);

                    if (!exists ophash.input.multipartRelated.part)
                        throw WSDL_ERROR, sprintf("binding %y is missing part definition(s) in input message definition for operation %y: %y", name, opname, ophash);

                    foreach hash part in (ophash.input.multipartRelated.part) {
                        WSDL::XsdBase::removeNS(\part);
                        op.addInputPart(part);
                    }
                }
                else
                    throw WSDL_ERROR, sprintf("cannot parse input message definition in binding %y for operation %y: %y", name, opname, ophash);
            }
            else if (ophash.input.body || ophash.input.multipartRelated)
                throw WSDL_ERROR, sprintf("cannot parse input message definition in binding %y for operation %y with no input: %y", name, opname, ophash);

            # check for header
            foreach hash hh in (ophash.input.header) {
                *hash ma = hh."^attributes^";

                if (!ma.message)
                    throw WSDL_ERROR, sprintf("input binding %y for operation %y specifies a soap header element without a 'message' attribute (attr: %y)", name, opname, ma);

                if (!ma.part)
                    throw WSDL_ERROR, sprintf("input binding %y for operation %y specifies a soap header element without a 'part' attribute (attr: %y)", name, opname, ma);

                hash h = nsc.doType(ma.message);
                *WSMessage msg = messages.(h.val);
                if (!exists msg)
                    throw WSDL_ERROR, sprintf("input binding %y for operation %y references unknown message %y in the soap header element", name, opname, msg);

                #printf("header msg: %y part: %y use: %y\n", ma.message, ma.part, ma.use);
                #printf("op.input: %y\n", input);

                op.setInputHeader(ma.part, msg, ma.use == "encoded");
            }

            WSDL::XsdBase::removeNS(\ophash.output);
            if (op.output) {
                if (exists ophash.output.body) {
                    if (ophash.output.body."^attributes^".use == "encoded") {
                        op.output.encoded = True;
                        #printf("DEBUG: setting encoding = True for %y.%y output\n", data.name, opname);
                    }
                }
                else if (exists ophash.output.multipartRelated) {
                    op.setOutputMultipart(Mime::MPT_RELATED);
                    WSDL::XsdBase::removeNS(\ophash.output.multipartRelated);

                    if (!exists ophash.output.multipartRelated.part)
                        throw WSDL_ERROR, sprintf("missing part definition(s) in output message definition for operation %y: %y", opname, ophash);

                    foreach hash part in (ophash.output.multipartRelated.part) {
                        WSDL::XsdBase::removeNS(\part);
                        op.addOutputPart(part);
                    }
                }
                else
                    throw WSDL_ERROR, sprintf("cannot parse output message definition for operation %y: %y", opname, ophash);
            }
            else if (exists ophash.output.body || exists ophash.output.multipartRelated)
                throw WSDL_ERROR, sprintf("cannot parse input message definition for operation %y with no input: %y", opname, ophash);
        }

        #binding = data;
    }

    string getPort() {
        return port;
    }
}

# private namespace prefix redefinition class
class WSDL::NamespacePrefixHelper {
    public {
    }

    private {
        Namespaces nsc;

        # overriden prefixes
        hash h;

        # overridden target namespace
        bool targ_ns;

        # overridden default namespace
        bool def_ns;
    }

    constructor(Namespaces n_nsc, *hash nsattr) {
        nsc = n_nsc;

        if (nsattr) {
            nsc.addNamespaces(nsattr, self);
            if (nsattr.targetNamespace) {
                nsc.pushTargetNamespace(nsattr.targetNamespace);
                targ_ns = True;
            }
            if (nsattr.xmlns) {
                nsc.pushDefaultNamespace(nsattr.xmlns);
                def_ns = True;
            }
        }
    }

    destructor() {
        if (def_ns)
            nsc.popDefaultNamespace();
        if (targ_ns)
            nsc.popTargetNamespace();
        if (h)
            nsc.restorePrefixes(h);
    }

    save(string k, string v) {
        h{k} = v;
    }
}

#! namespace container class
public class WSDL::Namespaces {
    public {
    }

    private {
        #! maps output namespace prefixes to namespace URIs
        hash ns = (
            "xsd": XSD_NS,
            );

        #! maps namespace URIs to output namespace prefixes
        hash nsr = (
            XSD_NS: "xsd",
            );

        #! hash for valid XSD namespaces, maps input namespace prefixes -> True if it refers to an XSD schema
        hash xsd_schema = (
            "xsd": True,
            );

        #! hash mapping input namespace prefixes to namespaces URIs
        hash imap = (
            "xsd": XSD_NS,
            );

        #! hash mapping input namespace URIs to input namespace prefixes
        hash imapr = (
            XSD_NS: "xsd",
            );

        #! integer providing a sequence for output namespace prefixes
        int nsn;

        #! if True then has SOAP 1.1
        bool hassoap11 = False;

        #! if True then has SOAP 1.2
        bool hassoap12 = False;

        #! current target namespace
        *string target_ns;

        #! target namespace stack;
        list nss = ();

        #! default namespace for unprefixed definitions
        *string default_ns;

        #! default namespace stack;
        list dss = ();
    }

    #! creates the object with the WSDL definitions attribute hash
    constructor(hash nsh, *Namespaces nsc) {
        nsn = nsc ? nsc.nsn : 1;

        if (nsh.targetNamespace)
            target_ns = nsh.targetNamespace;

        # set default namespace for unprefixed definitions
        if (nsh.xmlns)
            default_ns = nsh.xmlns;

        #printf("*** DEBUG: Namespaces::constructor() nsh: %y imap: %y\n", nsh, imap);
        addNamespaces(nsh);
        #printf("*** DEBUG: Namespaces::constructor() imap: %y\n", imap);
    }

    *string getDefaultNs() {
        return default_ns;
    }

    addNamespaces(hash nsh, *NamespacePrefixHelper nph) {
        foreach string k in (nsh.keyIterator()) {
            *string ns = (k =~ x/xmlns:(\w+)/)[0];

            if (!ns)
                continue;

            if (imap{ns}) {
                # ignore if the definition is the same
                if (imap{ns} == nsh{k})
                    continue;

                if (nph) {
                    string ov = imap{ns};
                    if (imapr{ov} == target_ns)
                        remove imapr{ov};
                    if (nsh{ns} == XSD_NS)
                        remove xsd_schema{ns};
                    nph.save(ns, ov);
                }
                else
                    throw "WSDL-NAMESPACE-ERROR", sprintf("namespace prefix %y defined twice", ns);
            }
            addNamespaceIntern(ns, nsh{k});
        }
    }

    restorePrefixes(hash h) {
        map addNamespaceIntern($1.key, $1.value, True), h.pairIterator();
    }

    private addNamespaceIntern(string ns, string val, *bool override) {
        imap{ns} = val;

        if (override || !imapr{val})
            imapr{val} = ns;

        if (val == XSD_NS)
            xsd_schema{ns} = True;

        if (!hassoap11 && val == SOAP_11_NS)
            hassoap11 = True;

        if (!hassoap12 && val == SOAP_12_NS)
            hassoap12 = True;
    }

    #! merges namespaces when parsing imported schemas
    merge(Namespaces nsc) {
        nsn = nsc.nsn;
        foreach string k in (nsc.ns.keyIterator()) {
            string v = nsc.ns{k};

            if (ns{k}) {
                if (ns{k} == v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", k, v, ns{k});
            }
            if (!nsr{v}) {
                ns{k} = v;
                nsr{v} = k;
            }
        }
        # merge input namespace mappings
        foreach string k in (nsc.imap.keyIterator()) {
            string v = nsc.imap{k};
            if (imap{k}) {
                if (imap{k} == v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", k, v, imap{k});
            }
            imap{k} = v;
        }
    }

    #! returns the namespace URI for the given output namespace prefix
    string getOutputNamespaceUri(string nsp) {
        *string n_ns = ns{nsp};
        if (!n_ns)
            throw "WSDL-NAMESPACE-ERROR", sprintf("output namespace prefix %y is unknown (known output namespace prefixes: %y)", nsp, ns.keys());
        return n_ns;
    }

    #! returns a hash of namespace attributes for outgoing SOAP messages
    *hash getOutputNamespaceHash(*hash nsh) {
        hash h;
        map h.("xmlns:" + $1.key) = $1.value, ns.pairIterator();

        foreach string k in (nsh.keyIterator()) {
            string xs = "xmlns:" + k;
            if (h{xs}) {
                if (h{xs} != nsh{k})
                    throw "WSDL-NAMESPACE-ERROR", sprintf("namespace %y has already been added automatically as %y and therefore cannot be overridden as %y", k, h{xs}, nsh{k});
            }
            else
                h{xs} = nsh{k};
        }

        return h;
    }

    #! returns the primary target namespace Uri
    *string getTargetNamespaceUri() {
        return target_ns;
    }

    #! returns the namespace URI for the given prefix or the target namespace Uri
    *string getNamespaceUri(*string nsp) {
        if (exists nsp)
            return getInputNamespaceUri(nsp);
        return getTargetNamespaceUri();
    }

    #! pushes the current target namespace URI on the stack when parsing schemas and sets the current target namespace URI to the current value
    pushTargetNamespace(string ns) {
        nss += target_ns;
        target_ns = ns;
    }

    #! restores any previous target namespace URI from the stack to the current target namespace URI
    popTargetNamespace() {
        target_ns = pop nss;
    }

    #! pushes the current default namespace URI on the stack when parsing schemas and sets the current default namespace URI to the current value
    pushDefaultNamespace(string ns) {
        dss += default_ns;
        default_ns = ns;
    }

    #! restores any previous default namespace URI from the stack to the current default namespace URI
    popDefaultNamespace() {
        default_ns = pop dss;
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getOutputNamespacePrefix(string ns) {
        *string nsa = nsr{ns};
        if (nsa)
            return nsa;
        return registerNamespaceIntern(ns);
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getTargetNamespaceInputPrefix() {
        if (!target_ns)
            throw "NAMESPACE-ERROR", sprintf("no target namespace");
        return imapr{target_ns};
    }

    #! registers a namespace internally
    private string registerNamespaceIntern(string n_ns) {
        # create namespace prefix
        string nsa = sprintf("ns%d", nsn++);
        # register namespace in forward and reverse maps
        ns{nsa} = n_ns;
        nsr{n_ns} = nsa;

        return nsa;
    }

    #! returns a hash of namespace prefixes to namespaces URIs actually used
    *hash getReferencedNamespaceMap() {
        return ns;
    }

    #! returns True if using SOAP 1.1, False if not
    bool hasSoap11() {
        return hassoap11;
    }

    #! returns True if using SOAP 1.2, False if not
    bool hasSoap12() {
        return hassoap12;
    }

    #! returns True if if the input namespace prefix refers to the XSD namespace URI
    *bool isSchema(string ns) {
        return xsd_schema{ns};
    }

    #! returns the input namespace URI from the input namespace prefix
    string getInputNamespaceUri(string nsa) {
        *string rv = imap{nsa};
        if (!rv)
            throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace %y is unknown (known input namespaces: %y)", nsa, imap.keys());
        return rv;
    }

    any doType(string t) {
        #printf("DEBUG: XsdBase::doType(%y)\n", t);
        (*string ns, *string type) = t =~ x/(\w+):(\w+)/;
        if (!type) {
            #printf("DEBUG: XsdBase::doType(%y) xsd: %y\n", t, default_ns);
            if (default_ns == XSD_NS)
                return new XsdBaseType(t, self);

            return ("val": t);
        }

        # if this is in the XML Schema namespace, then it's a base type
        if (xsd_schema{ns})
            return new XsdBaseType(type, self);

        return ("ns": getOutputNamespacePrefix(getInputNamespaceUri(ns)), "val": type);
    }

    #! returns the output namespace prefix for the given input namespace prefix
    string translateOutputNamespacePrefix(*string nsa) {
        return getOutputNamespacePrefix(getInputNamespaceUri(nsa));
    }
}

# private class
class WSDL::MapBase {
    public {}

    private {
        hash dh;
    }

    list keys() {
        return dh.keys();
    }

    AbstractIterator iterator() {
        return dh.iterator();
    }
}

# private class
class WSDL::TypeMap inherits WSDL::MapBase {
    add(XsdAbstractType t) {
        if (dh{t.name})
            throw WSDL_ERROR, sprintf("type %y declared twice", t.name);
        dh{t.name} = t;
    }

    XsdAbstractType get(string name) {
        if (!dh{name})
            throw WSDL_ERROR, sprintf("no such type %y; known types: %y", name, dh.keys());
        return dh{name};
    }

    *XsdAbstractType tryGet(string name) {
        return dh{name};
    }
}

# private class
class WSDL::ElementMap inherits WSDL::MapBase {
    add(XsdElement e) {
        string ns = e.ns;
        if (dh{ns}{e.name})
            throw WSDL_ERROR, sprintf("element %y declared twice in namespace %y", e.name, ns);
        dh{ns}{e.name} = e;
    }

    XsdElement get(string ns, string name) {
        if (!dh{ns})
            throw WSDL_ERROR, sprintf("no such namespace %y; known namespaces: %y", ns, dh.keys());
        if (!dh{ns}{name})
            throw WSDL_ERROR, sprintf("no such element %y in namespace %y; known elements: %y", name, ns, dh{ns}.keys());
        return dh{ns}{name};
    }

    *XsdElement tryGet(string ns, string name) {
        return dh{ns}{name};
    }
}

#! main class representing a parsed WSDL file
/** This is the main class for handling SOAP communication and is based on a WSDL file
*/
public class WSDL::WebService inherits WSDL::XsdBase {
    public {
        #! the WSDL string
        string wsdl;

        #! namespace container
        Namespaces nsc;

        hash base_type;
        list wsdl_services = ();
        hash idocmap;
        hash opmap;
        ElementMap emap();
        hash messages;
        TypeMap tmap();
        bool usedocns = False;
        hash portType;
        *code try_import;
        #! default path for retrieving XSD references
        *string def_path;
    }

    private {
        # service definitions; name -> service hash
        hash services;

        # service bindings; name -> hash
        hash binding;
    }

    #! creates the WebService object
    /** @param str the XML string representing the WSDL
        @param opts an optional hash of options with the following possible keys:
        - \c "def_path": the default path to use when retrieving referenced XSDs
        - \c "try_import": a call reference or closure to be passed a string name for XSD imports without any scheme to retrieve the data, must take a string argument (the resource name) and return a string (the resource data)
        - \c "http_client": a HTTPClient object for retrieving data from import commands
        - \c "http_headers": a hash of optional HTTP header info to use when retrieving data from import commands
    */
    constructor(string str, *hash opts) {
        hash h = parse_xml(str);

        # save WSDL text
        wsdl = str;

        try_import = opts.try_import;
        def_path = opts.def_path;

        # remove namespace (normally "wsdl:") prefix from keys if present
        WSDL::XsdBase::removeNS(\h);
        WSDL::XsdBase::removeNS(\h.definitions);
        nsc = new Namespaces(h.definitions."^attributes^");
        #getNSPrefixes(h.definitions."^attributes^");
        #printf("%y\n", h.definitions.types);

        if (exists h.definitions.types)
            parseTypes(h.definitions.types, opts.http_client instanceof HTTPClient ? opts.http_client : NOTHING, opts.http_headers);

        if (exists h.definitions.message)
            parseMessages(h.definitions.message);

        if (exists h.definitions.portType)
            parsePortType(h.definitions.portType);

        if (exists h.definitions.binding)
            parseBinding(h.definitions.binding);

        if (exists h.definitions.service)
            parseService(h.definitions.service);
    }

    #! returns the given operation or throws an exception if it cannot be found; operations are searched in portTypes in the order they are declared
    WSOperation getOperation(string opname) {
        foreach hash pt in (portType.iterator()) {
            if (pt.operations{opname})
                return pt.operations{opname};
        }
        list l = ();
        map l += $1.operations.keys(), portType.iterator();
        throw "WSDL-OPERATION-ERROR", sprintf("cannot retrieve operation %y; known operations: %y", opname, l);
    }

    #! returns the given operation or throws an exception if it cannot be found
    WSOperation getOperation(string port, string opname) {
        *WSOperation op = portType{port}.operations{opname};
        if (op)
            return op;
        if (!portType{port})
            throw "WSDL-OPERATION-ERROR", sprintf("port %y is not a defined port; known ports: %y", port, portType.keys());
        throw "WSDL-OPERATION-ERROR", sprintf("operation %y is not known in port %y; known operations: %y", opname, port, portType{port}.operations.keys());
    }

    #! returns a list of hashes giving supported operation names for each port in the WSDL
    /** @return a list of hashes giving supported operation names for each port in the WSDL; each hash has the following keys:
        - \c "port": the name of the port defining the operation
        - \c "operation": the @ref WSDL::WSOperation object for the operation
     */
    list listOperations() {
        list l = ();
        foreach hash ph in (portType.pairIterator()) {
            foreach WSOperation op in (ph.value.operations.iterator()) {
                l += (
                    "port": ph.name,
                    "operation": op,
                    );
            }
        }
        return l;
    }

    #! return a @ref WSDL::Binding object describing the requested binding
    /** @param name the name of the binding

        @return a @ref WSDL::Binding object

        @throw WSDL-BINDING-ERROR unknown binding
     */
    WSDL::Binding getBinding(string name) {
        *Binding b = binding{name};
        if (!b)
            throw "WSDL-BINDING-ERROR", sprintf("binding %y is not a known binding; known bindings: %y", name, binding.keys());
        return b;
    }

    #! returns a list of services defined in the WSDL
    /** @return a list of hashes of services defined in the WSDL; each hash has the following keys:
        - \c "name": the name of the service
        - \c "port": a hash of port information; the keys are port names and the values have the following keys:
          - \c "address": the location of the port
          - \c "binding": the binding of the port
     */
    list listServices() {
        return services.values();
    }

    #! returns a hash describing the requested service
    /** @param name the name of the service
        @return a hash describing the service with the following keys:
        - \c "name": the name of the service
        - \c "port": a hash of port information; where each hash is keyed by port name and the values have the following keys:
          - \c "address": the location of the port
          - \c "binding": the binding of the port

        @throw WSDL-SERVICE-ERROR the service is not known
     */
    hash getService(string name) {
        *hash h = services{name};
        if (!h)
            throw "WSDL-SERVICE-ERROR", sprintf("service %y is not a known service; known services: %y", name, services.keys());
        return h;
    }

    hash getType(string name, any v) {
        #printf("DBG getType() %y: %y\n", name, tmap);
        return ("^type^": tmap.get(name), "^val^": v);
    }

    private XsdBaseType getBaseType(string t) {
        if (exists base_type{t})
            return base_type{t};

        return base_type{t} = new XsdBaseType(t, nsc);
    }

    private resolveType(XsdSimpleType t) {
        throw "WSDL-TYPE-ERROR", sprintf("cannot resolve simpleType: %y type %y", t.name, t.type);
    }

    private resolveType(XsdElement xe) {
        if (xe.ref) {
            # find element
            (*string ns, string name) = (xe.ref =~ x/^(?:(\w+):)(\w+)$/);
            XsdElement e = emap.get(nsc.getNamespaceUri(ns), name);
            if (e.type.typeCode() == NT_HASH)
                resolveType(e);
            #printf("resolved to e: %y type: %y\n", e.name, e.type.name);
            xe.assimilate(e);
            #throw "OOPS", sprintf("e: %y", xe);
        }
        else if (xe.type.typeCode() == NT_HASH)
            xe.type = resolveType(xe.type);
    }

    private resolveType(XsdTypedData xd) {
        xd.type = resolveType(xd.type);
    }

    private resolveType(XsdComplexType ct) {
        ct.simpleType = resolveType(ct.simpleType);
    }

    private XsdAbstractType resolveType(hash v) {
        if (exists v.ns && nsc.isSchema(v.ns))
            return getBaseType(v.val);

        # find type
        return tmap.get(v.val);
    }

    # parse XSD schema types
    private parseTypes(*hash data, any http_client, any http_headers) {
        WSDL::XsdBase::removeNS(\data);

        XsdLateResolverHelper unresolved();

        foreach *hash schema in (data.schema) {
            *hash sa = schema."^attributes^";
            #if (!sa)
            #    throw "OOPS";
            NamespacePrefixHelper nph(nsc, sa);

            bool usedocns = sa.elementFormDefault == "qualified";

            #printf("DEBUG: schema tn: %y\n", schema."^attributes^"."targetNamespace");
            WSDL::XsdBase::removeNS(\schema);
            #printf("DEBUG: WebService::parseTypes() schema: %y\n", schema);

            # process XSD import if present
            foreach hash import in (schema.import) {
                *hash a = import."^attributes^";
                # import file
                if (a.schemaLocation) {
                    hash h = parse_url(a.schemaLocation);
                    string xsd;
                    if (!h.protocol && try_import)
                        xsd = call_function(try_import, a.schemaLocation);
                    else
                        xsd = WSDLLib::getFileFromURL(a.schemaLocation, "file", http_client, http_headers, NOTHING, def_path);

                    # parse XML to Qore data structure ignoring XML element order
                    hash xh = parse_xml(xsd);

                    # parse namespace definitions in schema attributes
                    if (xh.size() != 1)
                        throw WSDL_ERROR, sprintf("expecing a single element indicating an XSD schema in the imported file; got instead: %y", xh.keys());

                    # get schema member name
                    any sk = xh.firstKey();

                    #printf("*** DEBUG %y: sk: %y a: %y\n", a.schemaLocation, sk, xh{sk}."^attributes^");

                    # use temporary Namespaces object for import
                    Namespaces n_nsc = nsc;
                    nsc = new Namespaces(xh{sk}."^attributes^", nsc);
                    on_exit
                        nsc = n_nsc;
                    on_success
                        n_nsc.merge(nsc);

                    # verify that the top-level key indicates an XSD schema definition
                    (*string ns, *string mem) = (sk =~ x/^(\w+):(\w+)$/);
                    if (ns && !nsc.isSchema(ns))
                        throw WSDL_ERROR, sprintf("expecing imported schema definition to be in XSD namespace %y, got %y: %y instead", XSD_NS, ns, nsc.getInputNamespaceUri(ns));

                    parseTypes(xh);
                }
            }

            foreach hash st in (schema.simpleType) {
                XsdSimpleType t(st, nsc, unresolved, usedocns);
                tmap.add(t);
                #printf("DEBUG: st: %y\n", t.name);
            }

            foreach hash ct in (schema.complexType) {
                XsdComplexType t(ct, nsc, unresolved, usedocns);
                tmap.add(t);
                #printf("DEBUG: ct: %y\n", t.name);
            }

            # make element map
            foreach any el in (schema.element) {
                any attr = el."^attributes^";
                XsdElement element;
                if (exists attr.type) {
                    any t = nsc.doType(attr.type);
                    if (!(t instanceof XsdData)) {
                        t = t.val;
                        hash eattr.name = attr.name;
                        *XsdAbstractType et = tmap.tryGet(t);
                        if (!et)
                            eattr.type = t;

                        #printf("DEBUG: adding element %y type %y\n", attr.name, t);
                        element = new WSDL::XsdElement(("^attributes^": eattr), nsc, et, unresolved, usedocns);
                    }
                    else {
                        #printf("DEBUG: adding element %y type %y\n", attr.name, t);
                        element = new WSDL::XsdElement(("^attributes^":("name":attr.name)), nsc, t, unresolved, usedocns);
                    }
                }
                else {
                    #printf("DEBUG: adding element %y\n", attr.name);
                    element = new WSDL::XsdElement(el, nsc, NOTHING, unresolved, usedocns);
                }

                emap.add(element);
            }
        }

        # resolve types
        map resolveType($1), unresolved.getList();
        unresolved.clearResolved();

        # finalize complex types
        foreach XsdAbstractType t in (tmap.iterator()) {
            if (!(t instanceof XsdComplexType))
                continue;

            cast<XsdComplexType>(t).finalize(tmap, nsc);
        }

        # finalize complex types in elements
        foreach hash eh in (emap.iterator()) {
            foreach XsdElement el in (eh.iterator()) {
                if (!(el.type instanceof XsdComplexType))
                    continue;

                XsdComplexType ct = el.type;
                ct.finalize(tmap, nsc);
            }
        }

        # resolve types
        map resolveType($1), unresolved.getList();
    }

    private parseMessages(*softlist message) {
        # parse messages
        foreach hash m in (message) {
            WSMessage msg(m, emap, tmap, nsc);
            foreach string arg in (msg.args.keyIterator()) {
                #printf("DEBUG: WebService::parseMessages(): %y: %y\n", arg, msg);
                #printf("DEBUG: WebService::parseMessages(): %y: %y\n", arg, msg.args{arg}.type);
                if (exists msg.args{arg}.type && !(msg.args{arg}.type instanceof XsdData))
                    msg.args{arg}.type = resolveType(msg.args{arg}.type);
            }
            messages.(msg.name) = msg;
        }
    }

    private parseService(*softlist svcs) {
        foreach hash svc in (svcs) {
            WSDL::XsdBase::removeNS(\svc);
            string svcname = svc."^attributes^".name;
            foreach hash port in (svc.port) {
                WSDL::XsdBase::removeNS(\port);
                hash pa = port."^attributes^";
                string name = pa.name;
                services{svcname}.name = svcname;
                services{svcname}.port{name} = pa;
                services{svcname}.port{name}.address = port.address."^attributes^".location;

                if (!pa.binding)
                    throw WSDL_ERROR, sprintf("service %y port %y has no binding", svcname, name);

                (*string ns, *string bind) = pa.binding =~ x/(?:(\w+):)?(\w+)/;
                if (!bind)
                    throw WSDL_ERROR, sprintf("cannot parse service %y port %y binding: %y", svcname, name, pa.binding);

                if (!binding{bind})
                    throw WSDL_ERROR, sprintf("service %y port %y refers to non-existant binding %y; known bindings: %y", svcname, name, bind, binding.keys());

                services{svcname}.port{name}.binding = binding{bind};
            }
        }
    }

    private parsePortType(*softlist data) {
        # setup list of services defined in this WSDL
        foreach hash port in (data) {
            WSDL::XsdBase::removeNS(\port);
            #printf("DEBUG: portType: %y\n", port);
            string name = port."^attributes^".name;
            wsdl_services += name;
            foreach hash p in (port.operation) {
                WSOperation op(p, tmap, nsc, messages);
                portType{name}.operations.(op.name) = op;
                #printf("DEBUG: %y registered operation %y\n", name, op.name);
                opmap.(op.name) = op;
            }
        }
    }

    private parseBinding(*softlist bindings) {
        foreach hash data in (bindings) {
            WSDL::Binding b(data, nsc, opmap, \idocmap, messages);

            binding.(b.getName()) = b;
        }
    }

    #! returns True if the WSDL describes a SOAP 1.2 service
    /** @return True if the WSDL describes a SOAP 1.2 service
    */
    bool isSoap12() {
        return nsc.hasSoap12();
    }

    #! returns the XML string for the WSDL
    /** @return the XML string for the WSDL
    */
    string getWSDL() {
        return wsdl;
    }

    #! returns the XML string for the WSDL, adjusting the URLs for binding locations depending on the caller
    /** @param base_url the url to be prepended before the service name;
                        it must include all the handler prefixes (like \c /SOAP)
                        to produce valid URL
        @return the XML string for the WSDL
     */
    string getWSDL(string base_url) {
        string wstr = wsdl;

        foreach hash sh in (services.iterator()) {
            foreach hash ph in (sh.port.iterator()) {
                wstr = replace(wstr, ph.address, base_url + "/" + sh.name);
            }
        }

        return wstr;
    }
}
