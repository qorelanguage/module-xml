# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file WSDL.qm WSDL: Web Services Description Language: http://www.w3.org/TR/wsdl, SOAP 1.1: https://www.w3.org/TR/2000/NOTE-SOAP-20000508/, SOAP 1.2: https://www.w3.org/TR/soap12-part1/

/*  WSDL.qm Copyright (C) 2012 - 2018 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# make sure we have the required qore version
%requires qore >= 0.9

# requires XML functionality
%requires xml

# need mime definitions
%requires Mime >= 1.3.4.1

# do not use $ for vars
%new-style

# allow the use of the := weak reference assignment operator
%allow-weak-references

%disable-warning unreferenced-variable

module WSDL {
    version = "0.4";
    desc = "WSDL module providing functionality for SOAP";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/*
    WSDL classes
    provides some minimal WSDL and XSD support for SOAP messaging used by the SoapClient class and the SoapHandler

    not complete, needs namespace verification, improved XSD support, element groups, etc
*/

/** @mainpage WSDL Module

    @tableofcontents

    @section wsdlintro Introduction to the WSDL Module

    The %WSDL module provides functionality for <a href="http://en.wikipedia.org/wiki/SOAP">SOAP</a> 1.1 and 1.2.

    The main purpose of this module is to provide the infrastructure for developing SOAP client and server services.

    The main components of this module are as follows:
    - @ref WSDL::WebService "WebService": represents a WSDL file; an easy way to get an object of this type from a URL is by calling WSDL::WSDLLib::getWSDL()
    - @ref WSDL::WSDLLib "WSDLLib": a class of static functions providing helper functions for the module
    - @ref WSDL::WSOperation "WSOperation": a class representing a single operation from a SOAP web service
    - @ref WSDL::WSMessageHelper "WSMessageHelper": a class to create sample messages used by SOAP operations

    See the following for modules using the %WSDL module:
    - <a href="../../SoapClient/html/index.html">SoapClient user module</a>
    - <a href="../../SoapHandler/html/index.html">SoapHandler user module</a>

    @section wsdlrelnotes WSDL Module Release Notes

    @subsection wsdl_0_4 WSDL v0.4
    - added support for serializing and deserilizing WebService objects
      (<a href="https://github.com/qorelanguage/qore/issues/2793">issue 2793</a>)

    @subsection wsdl_0_3_8 WSDL v0.3.8
    - added support for \c token and \c normalizedString types
      (<a href="https://github.com/qorelanguage/qore/issues/2859">issue 2859</a>)
    - fixed @ref WSDLLib::getWSDL() when passed a WSDL string with no XML preamble
      (<a href="https://github.com/qorelanguage/qore/issues/2857">issue 2857</a>)
    - fixed handling of XSD attribute names with non-word characters
      (<a href="https://github.com/qorelanguage/qore/issues/2856">issue 2856</a>)
    - fixed handling of \c simpleType definitions with \c union members
      (<a href="https://github.com/qorelanguage/qore/issues/2855">issue 2855</a>)

    @subsection wsdl_0_3_7 WSDL v0.3.7
    - implemented supoprt for handling SOAP faults in response messages with SOAP bindings
      (<a href="https://github.com/qorelanguage/qore/issues/2804">issue 2804</a>)
    - fixed an error in namespace resolution with nested namespaces
      (<a href="https://github.com/qorelanguage/qore/issues/2786">issue 2786</a>)
    - fixed a type error in example message generation that resulted in failed example message generation
      (<a href="https://github.com/qorelanguage/qore/issues/2782">issue 2782</a>)
    - fixed a bug in example message generation that resulted in invalid messages
      (<a href="https://github.com/qorelanguage/qore/issues/2752">issue 2752</a>)
    - implemented the @ref WSDL::wsdl_set_global_compat_empty_string_is_nothing()
    "wsdl_set_global_compat_empty_string_is_nothing"
      function and the \c "compat_empty_string_is_nothing" option for the
      @ref WSDL::WebService "WebService" class for backwards compatibility with older versions of the WSDL
      module (<a href="https://github.com/qorelanguage/qore/issues/2754">issue 2754</a>)
    - implemented the @ref WSDL::wsdl_set_global_compat_empty_string_is_nothing()
    "wsdl_set_global_compat_allow_any_header"
      function and the \c "compat_allow_any_header" option for the @ref WSDL::WebService "WebService" class
      for backwards compatibility with older versions of the WSDL module
      (<a href="https://github.com/qorelanguage/qore/issues/2765">issue 2765</a>)

    @subsection wsdl_0_3_6 WSDL v0.3.6
    - reimplmented operation to support multi binding, operation can be assigned to more bindings
    - support for HTTP binding and content-types, "^content-type^" attribute can identify content type to be used
    - extended SOAP binding serialization and deserialization with support to both body and header

    @subsection wsdl_0_3_5_1 WSDL v0.3.5.1
    - supress emitting a SOAPAction header in requests if the binding gives an empty string (<a href="https://github.com/qorelanguage/qore/issues/1226">issue 1226</a>)
    - updated @ref WSDL::WSOperation::serializeRequest() to allow the SOAPAction header to be overridden in each request (<a href="https://github.com/qorelanguage/qore/issues/1226">issue 1226</a>)
    - respect XML generation flags in request generation
    - fixed parsing empty base64Binary and hexBinary elements (<a href="https://github.com/qorelanguage/qore/issues/1227">issue 1227</a>)

    @subsection wsdl_0_3_5 WSDL v0.3.5
    - fixed many message serialization and deserialization issues
    - added @ref WSDL::WebService::getOperation()
    - allow for environment variable substitution in WSDLLib::getWSDL() when retrieving files
    - fixed charset=... header value
    - added @ref WSDL::WSMessageHelper
    - added @ref WSDL::WebService::getReport()

    @subsection wsdl_0_3_4 WSDL v0.3.4
    - updated to a user module

    @subsection wsdl_0_3_3 WSDL v0.3.3
    - added initial support for the anyAttribute element of complexType
    - added initial support for SOAP header processing
    - added initial support for multiple portType and bindings in a WSDL

    @subsection wsdl_0_3_2 WSDL v0.3.2
    - fixed bugs de/serializing negative values for "int" and "short"

    @subsection wsdl_0_3_1 WSDL v0.3.1
    - improved XSD imports and namespace handling

    @subsection wsdl_0_3_0 WSDL v0.3.0
    - implemented WSDLLib class of helper functions
    - implemented support for xsd import statements in WSDLs

    @subsection wsdl_0_2_0 WSDL v0.2.0
    - use parseXMLAsData() instead of parseXML()
    - implemented initial simpleType support
    - fixed xsd:date serialization and deserialization
*/

#! main WSDL namespace
public namespace WSDL {
    #! this WSDL implementation version
    public const version     = "0.3.6";

    #! SOAP 1.1 envelope URI
    public const SOAP_11_ENV  = "http://schemas.xmlsoap.org/soap/envelope/";
    #! SOAP 1.2 envelope URI
    public const SOAP_12_ENV  = "http://www.w3.org/2003/05/soap-envelope";

    #! SOAP 1.1 namespace URI
    public const SOAP_11_NS   = "http://schemas.xmlsoap.org/wsdl/soap/";

    #! SOAP 1.2 namespace URI
    public const SOAP_12_NS   = "http://schemas.xmlsoap.org/wsdl/soap12/";

    #! XSD namespace URI
    public const XSD_NS       = "http://www.w3.org/2001/XMLSchema";
    #! XSI namespace URI
    public const XSI_NS       = "http://www.w3.org/2001/XMLSchema-instance";

    #! HTTP namespace URI
    public const HTTP_NS      = "http://schemas.xmlsoap.org/wsdl/http/";
    #! MIME namespace URI
    public const MIME_NS      = "http://schemas.xmlsoap.org/wsdl/mime/";

    #! soap 1.1 envelope namespaces
    public const ENVELOPE_11_NS = (
        "soapenv:Envelope": (
            "^attributes^": (
                "xmlns:soapenv": SOAP_11_ENV,
                "xmlns:xsd": XSD_NS,
                "xmlns:xsi": XSI_NS,
            ),
        ),
    );

    #! soap 1.2 envelope namespaces
    public const ENVELOPE_12_NS = (
        "soapenv:Envelope": (
            "^attributes^": (
                "xmlns:soapenv": SOAP_12_ENV,
              "xmlns:xsd": XSD_NS,
              "xmlns:xsi": XSI_NS,
            ),
        ),
    );

    #! SOAP "use" to "encoded" mappings
    public const SoapUseMap = (
        "encoded": True,
        "literal": False,
        );

    #! SOAP "style" to "document" mappings
    public const SoapStyleMap = (
        "document": True,
        "rpc": False,
        );

    #! soap encoding URI
    public const SOAP_ENCODING = "http://schemas.xmlsoap.org/soap/encoding/";

    #! mapping from Qore types to xsd types for xsd type "anyType"
    public const any_type_map = (
        Type::String      : "string",
        Type::Int         : "long",
        Type::Boolean     : "boolean",
        Type::Date        : "dateTime",
        Type::Float       : "decimal",
        Type::NothingType : "string",
        Type::NullType    : "string",
        Type::Binary      : "base64Binary",
    );

    # error codes
    const SOAP_SERIALIZATION_ERROR = "SOAP-SERIALIZATION-ERROR";
    const SOAP_DESERIALIZATION_ERROR = "SOAP-DESERIALIZATION-ERROR";
    const WSDL_ERROR = "WSDL-ERROR";

    #! SOAP HTTP transport URI
    const SOAP_TRANSPORT_HTTP = "http://schemas.xmlsoap.org/soap/http";

    #! known/supported transports
    public const SOAP_TRANSPORT = (
        SOAP_TRANSPORT_HTTP: True,
        );

    #! range of "short" values (16 bits)
    public const RANGE_SHORT = (-32768, 32767);

    #! range of "int" values (32 bits)
    public const RANGE_INT = (-2147483648, 2147483647);

    # private global variables
    our bool global_compat_empty_string_is_nothing;
    our bool global_compat_allow_any_header;

    #! sets the \c global_compat_empty_string_is_nothing variable to the given value to force the WSDL module to return a blank value for a required string field when the associated XML element is present as no value instead of an empty string for backwards compatibility with xml module 1.3
    public sub wsdl_set_global_compat_empty_string_is_nothing(softbool val) {
        global_compat_empty_string_is_nothing = val;
    }

    #! sets the \c global_compat_allow_any_header variable to the given value to force the WSDL module to allow any SOAP header to be sent in SOAP messages for backwards compatibility with xml module 1.3
    public sub wsdl_set_global_compat_allow_any_header(softbool val) {
        global_compat_allow_any_header = val;
    }
}

#! contains helper methods for retrieving WSDLs from a URL
public class WSDL::WSDLLib {
    #! Mime types recognized as SOAP messages
    const SoapMimeTypes = (MimeTypeSoapXml, MimeTypeXml, MimeTypeXmlApp);

    static string getSoapMimeType12(bool soap12) {
        return soap12 ? MimeTypeSoapXml : MimeTypeXml;
    }

    #! retrieves a local file and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "file"
    */
    static data getFile(string fn, bool as_string = True) {
        *data rv = as_string ? ReadOnlyFile::readTextFile(fn) : ReadOnlyFile::readBinaryFile(fn);
        if (!exists rv)
            throw "WSDL-LIB-ERROR", sprintf("file %y is empty or could not be read as a normal file", fn);
        return rv;
    }

    #! retrieves a file from a URL with HTTP and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "http"
    */
    static string getHTTP(string url, *string path, *HTTPClient hc, *hash<auto> headers, bool as_string = True) {
        if (hc)
            hc.setURL(url);
        else
            hc = new HTTPClient(("url": url));
        string body = hc.get(path ? path : "/", headers);
        return as_string ? body : binary(body);
    }

    #! retrieves a file from a URL with the FTP protocol and returns the file's contents as binary or string data
    /** called by WSDLLib::getFileFromURL() in case the scheme is "ftp"
    */
    static data getFTP(string url, string path, bool as_string = True) {
        string file = basename(path);
        if (!file)
            throw "WSDL-LIB-ERROR", sprintf("missing file name in URL %y", url);

        FtpClient f(url);
        f.connect();

        string dir = dirname(path);
        if (dir)
            f.cwd(dir);

        return as_string ? f.getAsString(file) : f.getAsBinary(file);
    }

    #! retrieves a file from a URL
    /** in case the URL is actually a file path, environment variable substitution
        is performed on the path string
     */
    static data getFileFromURL(string url, string def_protocol = "file", *HTTPClient http_client, *hash<auto> http_headers, bool as_string = True, *string def_path, *reference new_def_path) {
        return WSDLLib::getFileFromURL(url, parse_url(url), def_protocol, http_client, http_headers, as_string, def_path, \new_def_path);
    }

    #! retrieves a file from an already-parsed URL
    /** in case the URL is actually a file path, environment variable substitution
        is performed on the path string
     */
    static data getFileFromURL(string url, hash<auto> u, string def_protocol = "file", *HTTPClient http_client, *hash<auto> http_headers, bool as_string = False, *string def_path, *reference new_def_path) {
        if (!exists u.protocol)
            u.protocol = def_protocol;

        switch (u.protocol) {
            case "file": {
                string path;
                if (u.host)
                    path = u.host;
                if (u.path) {
                    if (path)
                        path += DirSep;
                    path += u.path;
                }
                # do environment variable substitution
                map path = replace(path, "\$" + $1, ENV.$1), (path =~ x/\$(\w+)/g);

                if (def_path && !absolute_path(path))
                    path = def_path + DirSep + path;
                else
                    new_def_path = dirname(path);
                return WSDLLib::getFile(path, as_string);
            }

            case /^http(s)?$/:
                return WSDLLib::getHTTP(url, u.path, http_client, http_headers, as_string);

            case /^ftp(s)?$/:
                return WSDLLib::getFTP(url, u.path, as_string);

            default:
                throw "WSDL-LIB-ERROR", sprintf("do not know how to retrieve data with scheme %y given in URL %y", u.protocol, url);
        }
    }

    #! returns the argument
    static WebService getWSDL(WebService wsdl) {
        return wsdl;
    }

    #! returns a WSDL string from a file name, optional HTTPClient object and optional header hash
    /** in case the \a wsdl argument is actually a file path, environment variable substitution
        is performed on the path string
     */
    static string getWSDL(string wsdl, *HTTPClient http_client, *hash<auto> http_headers, *reference new_def_path) {
        if (wsdl =~ /^</)
            return wsdl;
        return WSDLLib::getFileFromURL(wsdl, "file", http_client, http_headers, NOTHING, NOTHING, \new_def_path);
    }

    #! returns a WebService object from a URL and other optional arguments
    /** @param the URL to use to retrieve the file, the \c "file://", \c "http://", \c "https://", and \c "ftp://" schemes are supported, if no scheme is present, then \c "file://" is assumed
        @param http_client an optional HTTPClient object to use to retrieve external schemas, if no HTTPClient object is passed and one is needed, an HTTPClient object will be created implicitly
        @param http_headers any HTTP headers to send with requests when retrieving external XSD schemas
    */
    static WebService getWebServiceFromUrl(string url, *HTTPClient http_client, *hash<auto> http_headers) {
        string def_path;
        string wsdl = WSDLLib::getWSDL(url, http_client, http_headers, \def_path);
        return new WebService(wsdl, {"def_path": def_path, "http_client": http_client, "http_headers": http_headers});
    }

    #! takes a hash representation of a SOAP message and handles multipart messages, checks the content-type, and handles hrefs in the message
    static hash<auto> parseMultiPartSOAPMessage(hash<auto> msg) {
        if (exists msg."_qore_multipart") {
            if (msg."_qore_multipart" != "related")
                throw "SOAP-MESSAGE-ERROR", sprintf("don't understand multipart/%s messages; expected multipart/related", msg."_qore_multipart");

            auto bdry = msg."_qore_multipart_boundary";
            if (!bdry.val())
                throw "SOAP-MESSAGE-ERROR", sprintf("multipart message received without multipart boundary; headers: %y", msg - "body");

            hash<auto> mpmsg;
            list<string> l = split("\r\n--" + bdry, msg.body);

            for (int i = 1; i < (elements l - 1); ++i) {
                string m = l[i];

                int ie = index(m, "\r\n\r\n");
                if (ie == -1) {
                    throw "SOAP-MESSAGE-ERROR", sprintf("part %d has no headers: %y", i, m);
                }
                hash<auto> hh;
                foreach string hl in (split("\r\n", substr(m, 2, ie))) {
                    trim hl;
                    (string hi, auto ignore, string ha) = hl =~ x/^(.*):([ \t])*(.*)$/;
                    hi = tolower(hi);
                    #printf("hl: %y hi: %y ha: %y\n", hl, hi, ha);exit();
                    hh{hi} = ha;
                }
                if (!exists hh."content-id")
                    throw "SOAP-MESSAGE-ERROR", sprintf("expecting part header Content-ID in part %d; headers: %y", i, hh);

                auto b;
                if (hh."content-transfer-encoding" == "binary") {
                    # unfortunately we have to do some tricks to get the binary data out here
                    # FIXME: tricks probably not necessary with qore 0.8.1+
                    m = force_encoding(m, "ascii");
                    # recalculate byte offset
                    ie = index(m, "\r\n\r\n");
                    #printf("ie: %d m: %d\n", ie, strlen(m));exit();
                    b = binary(substr(m, ie + 4));

                    #File f(); f.open2("t.bin", O_CREAT|O_WRONLY|O_TRUNC); f.write(b); exit();
                }
                else {
                    b = substr(m, ie + 4);

                    if (hh."content-type" =~ /charset=/) {
                        string c = (hh."content-type" =~ x/charset=([^;]+)/)[0];
                        b = force_encoding(b, c);
                    }
                }

                if (hh."content-id" !~ /^\<.*\>$/)
                    throw "SOAP-MESSAGE-ERROR", sprintf("expected part ID to have the following format: <id>, instead got %s", hh."content-id");

                hash<auto> p = (
                    "hdr": hh,
                    "body": b,
                    );

                if ((!exists msg."_qore_multipart_start" && i == 1)
                    || (exists msg."_qore_multipart_start" && msg."_qore_multipart_start" == hh."content-id")) {
                    mpmsg.body = p;
                }
                else {
                    string id = substr(hh."content-id", 1, -1);
                    mpmsg.part{id} = p;
                }
            }
            return {
                'content-type': mpmsg.body.hdr."content-type",
                'header': msg.header + mpmsg.body.hdr,
                'body': mpmsg.body.body,
                'parts': mpmsg.part,
            };
        } else {
            return {
                'content-type': msg."_qore_orig_content_type",
                'header': msg.header,
                'body': msg.body,
            };
        }
    }

    #! returns True is the message has a SOAP mime type
    static bool isSOAPMessage(hash<auto> msg) {
        return WsdlLibPriv::isContentType(msg."content-type", SoapMimeTypes);
    }

    /**!
    takes a hash representation returned by parseMultiPartSOAPMessage and parses it to a Qore data structure, checks the content-type, and handles hrefs in the message.
    Operation is not yet known if SoapAction header is not presented
    */
    static *hash<auto> parseSOAPMessage(hash<auto> msg) {
        if (!msg.body) {
            hash<auto> h."content-type" = msg."content-type" ?? "text/plain";
            h.body = NOTHING;
            return h;
        } else if (WSDLLib::isSOAPMessage(msg)) {
            hash<auto> xmldata;
            if (msg.body) {
                xmldata = parse_xml(msg.body);
            }
            if (msg.parts) {
                # parse entire data structure to find "href"s or href attributes
                WSDLLib::substHref(\xmldata, msg.parts);
            }
            return xmldata;
        } else {
            string ct = msg."content-type";
            hash<auto> h."content-type" = (ct =~ x/^([^;]+)/)[0];
            if (ct =~ /charset=/) {
                string c = (ct =~ x/charset=([^;]+)/)[0];
                h.body = force_encoding(msg.body, c);
            } else {
                h.body = binary(msg.body);  # needed or is it already ?
            }
            return h;
        }
    }

    private static processHref(reference xmldata, string hr, hash<auto> parts) {
        if (hr !~ /^cid:/)
            throw "SOAP-MESSAGE-ERROR", sprintf("messages references non-local part %y; cannot handle non-local parts", hr);
        hr = substr(hr, 4);
        if (!exists parts{hr})
            throw "SOAP-MESSAGE-ERROR", sprintf("message references non-existent part %y", hr);
        xmldata = parts{hr}.body;
    }

    private static substHref(reference xmldata, hash<auto> parts) {
        foreach string k in (keys xmldata) {
            if (exists xmldata{k}."^attributes^".href)
                WSDLLib::processHref(\xmldata{k}, xmldata{k}."^attributes^".href, parts);
            else if (exists xmldata{k}.href)
                WSDLLib::processHref(\xmldata{k}, xmldata{k}.href, parts);
            else if (xmldata{k}.typeCode() == NT_LIST) {
                foreach auto e in (\xmldata{k})
                    WSDLLib::substHref(\e, parts);
            }
            else if (xmldata{k}.typeCode() == NT_HASH)
                WSDLLib::substHref(\xmldata{k}, parts);
        }
    }
}

# private, nmon-exported class
class WsdlLibPriv {
    static bool isContentType(string ct, list<auto> MimeTypes) {
        ct = ltrim(ct);
        foreach string sct in (MimeTypes) {
            # Content-Type := type "/" subtype *[";" parameter] ... so we can test if string is starting at index 0
            if (bindex(ct, sct) == 0)
                return True;
        }
        return False;
    }

    static checkContentType(string ct, list<auto> MimeTypes) {
        if (!WsdlLibPriv::isContentType(ct, MimeTypes)) {
            throw "SOAP-MESSAGE-ERROR", sprintf("don't know how to handle content-type %y (expecting one of: %y)", ct, MimeTypes);
        }
    }
}

#! base class with helper methods for XSD data processing
public class WSDL::XsdBase {
    static removeNS(reference v) {
        foreach hash<auto> h in (\v) {
            foreach string k in (keys h) {
                (*string ns, *string name) = k =~ x/([^:]+):([^:]+)/;
                if (ns) {
                    switch (h{k}.typeCode()) {
                        case NT_HASH: h{k}.ns = ns; break;
                        case NT_LIST: h{k} = map $1 + ("ns": ns), h{k}; break;
                    }
                    if (h{name}) {
                        softlist<auto> l = h{name};
                        l += remove h{k};
                        h{name} = l;
                    }
                    else
                        h{name} = remove h{k};
                }
            }
        }
    }

    static removeNS2(reference v) {
        foreach hash<auto> h in (\v) {
            foreach string k in (keys h) {
                (*string ns, *string name) = k =~ x/([^:]+):([^:]+)/;
                if (ns) {
                    switch (h{k}.typeCode()) {
                        case NT_HASH: h{k}.".ns" = ns; break;
                        case NT_LIST: h{k} = map $1 + (".ns": ns), h{k}; break;
                    }
                    if (h{name}) {
                        softlist<auto> l = h{name};
                        l += remove h{k};
                        h{name} = l;
                    }
                    else
                        h{name} = remove h{k};
                }
            }
        }
    }
}

#! base class for XSD data classes
public class WSDL::XsdData inherits WSDL::XsdBase {
    auto getValue(*hash<auto> mrh, auto val) {
        if (exists val."^attributes^".href) {
            string href = substr(val."^attributes^".href, 1);

            if (!exists mrh.mrh{href})
                throw "INVALID-REFERENCE", sprintf("multiRef id: %y does not exist", href);

            return mrh.mrh{href};
        }
        return val;
    }
}

#! base class for XSD classes with a "name" attribute
public class WSDL::XsdNamedData inherits WSDL::XsdData {
    public {
        # name of object
        string name;
        #! input namespace prefix (if any given)
        *string ns;
        #! descriptive name flag
        descriptive_name;
    }

    constructor(string n_name, string n_ns) {
        name = n_name;
        ns = n_ns;
        # if the name has a space in it, then it's a descriptive name
        descriptive_name = (name =~ / /);
    }

    constructor(reference e, *string desc_name) {
        WSDL::XsdBase::removeNS(\e);
        *hash<auto> a = e."^attributes^";
        if (a.name)
            name = a.name;
        else if (a.ref) {
            # remove namespace
            (*string ns, *string n_name) = a.ref =~ x/([^:]+):([^:]+)/;
            name = n_name ?? a.ref;
        }
        else
            name = desc_name ?? "<unnamed type>";
        # if the name has a space in it, then it's a descriptive name
        descriptive_name = (name =~ / /);
    }

    string getName() {
        return name;
    }

    *string getInputNamespacePrefix() {
        return ns;
    }

    bool hasRealName() {
        return !descriptive_name;
    }
}

public class WSDL::XsdAbstractType inherits WSDL::XsdNamedData {
    public {
        #! reference to namespaces
        Namespaces nsc;

        #! my namespace output prefix
        string ons;
    }

    constructor(reference e, Namespaces nsc, *string desc_name) : XsdNamedData(\e, desc_name) {
        self.nsc := nsc;
        resolveNamespace();
    }

    constructor(string name, string ns, Namespaces nsc) : XsdNamedData(name, ns) {
        self.nsc := nsc;
        resolveNamespace();
    }

    private resolveNamespace() {
        if (!ns) {
            *string tns = nsc.getTargetNamespaceUri();
            if (!tns)
                throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace for %s %y was not given and there is no current target namespace", self.className(), name);
            ons = nsc.getOutputNamespacePrefix(tns);
        }
        else
            ons = nsc.translateOutputNamespacePrefix(ns);
        #printf("DEBUG: type %y ns: %y ons: %y\n", name, ns, ons);
    }

    checkExtends(XsdAbstractType t, string ename) {
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible", name, ename, t.name);
    }

    string getNameWithNS() {
        return ons + ":" + name;
    }

    bool isNillable() {
        return False;
    }

    bool isRequired() {
        return True;
    }

    bool requiresValue() {
        return !isNillable() && isRequired();
    }

    string getOutputNamespacePrefix() {
        return ons;
    }

    abstract auto serialize(Namespaces nsc, auto val, *softbool omitType);
    abstract auto deserialize(string en, hash<string, XsdAbstractType> tmap, *hash<auto> mrh, auto val);
}

#! class for XSD base types
public class WSDL::XsdBaseType inherits WSDL::XsdAbstractType {
    public {
    }

    constructor(string t, Namespaces nsc, string ns = "xsd") : XsdAbstractType(t, ns, nsc) {
    }

    auto serialize(Namespaces nsc, auto val, *softbool omitType) {
        *hash<auto> comments;
        if (val.typeCode() == NT_HASH) {
            foreach string k in (keys val) {
                if (k =~ /^\^comment/) {
                    comments{k} = val{k};
                }
            }
            val = val."^value^";
        }
        *string type;
        # set type according to Qore type if xsd type is anyType
        if (name == "anyType") {
            # we have to specify the type in this case
            omitType = False;
            type = any_type_map{val.type()};
            if (!type)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize xsd type anyType from Qore type %y", val.type());
        }
        else {
            type = name;
        }
        switch (type) {
            case "byte": {
                int v = int(val);
                if ((v & 0xff) != v)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "short": {
                int v = int(val);
                if (v < RANGE_SHORT[0] || v > RANGE_SHORT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "int": {
                int v = int(val);
                if (v < RANGE_INT[0] || v > RANGE_INT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedByte": {
                int v = int(val);
                if ((v & 0xff) != v)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", type, v);
                break;
            }

            case "unsignedShort": {
                int v = int(val);
                if (v < 0 || v > RANGE_SHORT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedInt": {
                int v = int(val);
                if (v < 0 || v > RANGE_INT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedLong": {
                int v = int(val);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", type, v);
                break;
            }

            case "negativeInteger": {
                int v = int(val);
                if (v >= 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts negative values (value supplied: %d)", name, v);
                break;
            }

            case "nonNegativeInteger": {
                int v = int(val);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts non-negative values (value supplied: %d)", name, v);
                break;
            }

            case "nonPositiveInteger": {
                int v = int(val);
                if (v > 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts non-positive values (value supplied: %d)", name, v);
                break;
            }

            case "positiveInteger": {
                int v = int(val);
                if (v <= 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts positive values (value supplied: %d)", type, v);
                break;
            }

            case "date":
                val = format_date("YYYY-MM-DD", date(val));
                break;

            case "dateTime":
                val = format_date("YYYY-MM-DDTHH:mm:SS", date(val));
                break;

            case "boolean":
                val = val ? "true" : "false";
                break;

            case "time":
                val = format_date("hh:mm:ss.ms", date(val));
                break;

            case "base64Binary":
                val = make_base64_string(val);
                break;

            case "hexBinary":
                val = make_hex_string(val);
                break;

            case "binary":
                # used for HTTP binding only
                val = binary(val);
                break;

            case "token":
                if (!val.strp()) {
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts values that are convertible to strings; type %y supplied", type, val.type());
                }
                # XML processor should remove line feeds, carriage returns, tabs, leading and trailing spaces, and multiple spaces
                val = trim(val.toString());
                val =~ s/  +/ /g;
                break;

            case "normalizedString":
                if (!val.strp()) {
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts values that are convertible to strings; type %y supplied", type, val.type());
                }
                # XML processor should remove line feeds, carriage returns, and tab characters
                val = val.toString();
                val =~ s/[\n\r\t]//g;
                break;
        }

        #printf("DEBUG: FORCE: type: %y, nstype: %y, val: %y\n", type, nstype, val);
        if (omitType)
            if (comments) {
                return comments + (
                    "^value^": val
                );
            } else
                return val;
        else
            return (
                comments +
                "^attributes^": (
                    "xsi:type": sprintf("%s:%s", ons, type),
                ),
                "^value^": val,
            );
    }

    auto deserialize(string en, hash<string, XsdAbstractType> tmap, *hash<auto> mrh, auto val) {
        string type;
        if (val.typeCode() == NT_HASH && val.hasKey("^value^")) {
            if (val."^attributes^"."xsi:type") {
                type = val."^attributes^"."xsi:type";
                string t = (type =~ x/[^:]+:([^:]+)/)[0];
                if (exists t)
                    type = t;

                if (name != "anyType" && type != name)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting base type %y, got %y", name, val."^attributes^"."xsi:type");
            }
            else
                type = name;
            val = val."^value^";
        }
        else
            type = name;

        switch (type) {
            case "string":
            case "token":
            case "normalizedString":
            case "anyURI":
                return nsc.opt_empty_string_is_nothing ? val : string(val);

            case "integer": {
                # note that we do not convert xsd:integer to a qore integer if we would lose precision
                int v = int(val);
                return v == val ? v : val;
            }

            case "byte":
                val = int(val);
                if ((val & 0xff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "short":
                val = int(val);
                if (val < RANGE_SHORT[0] || val > RANGE_SHORT[1])
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "int":
                val = int(val);
                if (val < RANGE_INT[0] || val > RANGE_INT[1])
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "long":
                return int(val);

            case "unsignedByte":
                val = int(val);
                if ((val & 0xff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedShort":
                val = int(val);
                if ((val & 0xffff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedInt":
                val = int(val);
                if ((val & 0xffffffff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedLong":
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return int(val);

            case "negativeInteger":
                if (val >= 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts negative values (value supplied: %d)", name, val);
                return int(val);

            case "nonNegativeInteger":
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts non-negative values (value supplied: %d)", name, val);
                return int(val);

            case "nonPositiveInteger":
                if (val > 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts non-positive values (value supplied: %d)", name, val);
                return int(val);

            case "positiveInteger":
                if (val <= 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts positive values (value supplied: %d)", name, val);
                return int(val);

            case "date":
                # remove dashes from date
                val =~ s/-//g;
                return date(val);

            case "dateTime":
                return date(substr(val, 0, 4) + substr(val, 5, 2) + substr(val, 8, 2) +
                            substr(val, 11, 2) + substr(val, 14, 2) + substr(val, 17, 2));

            case "time":
                return date("19700101" + substr(val, 0, 2) + substr(val, 3, 2) + substr(val, 6, 2)) +
                       milliseconds(substr(val, 9, 3));

            case "boolean":
                if (val =~ /true/i)
                    return True;
                if (val =~ /false/i)
                    return False;
                return boolean(val);

            case "decimal":
                return float(val);

            case "base64Binary":
                if (val.typeCode() == NT_BINARY) {
                    return val;
                } else {
                    return val.empty() ? binary() : parse_base64_string(val);
                }

            case "hexBinary":
                if (val.typeCode() == NT_BINARY) {
                    return val;
                } else {
                    return val.empty() ? binary() : parse_hex_string(val);
                }

            case "binary":
                # used for HTTP binding only
                if (val.typeCode() == NT_BINARY) {
                    return val;
                } else {
                    return val.empty() ? binary() : binary(val);
                }

            default: {
                if (name == "anyType")  {
                    *XsdAbstractType t = tmap_try_get(tmap, type);
                    if (t)
                        return t.deserialize(en, tmap, mrh, val);
                }
                throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }
}

#! class for XSD array types; currently only supports "binary"; used, for example with HTTP MultiPart messages
public class WSDL::XsdArrayType inherits WSDL::XsdAbstractType {
    constructor(string t, Namespaces nsc) : XsdAbstractType(t, "ns1", nsc) {
        if (t != "binary")
            throw "XSD-ARRAYTYPE-ERROR", sprintf("don't know how to handle arrays of type %y", t);
    }

    auto serialize(Namespaces nsc, auto val, *softbool omitType) {
        switch (name) {
            case "binary": {
                int t = val.typeCode();
                if (t === NT_STRING)
                    val = binary(val);
                else if (t !== NT_BINARY)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize type %y from type %y; requires string or binary", name, t);
                return val;
            }

            default: {
                throw SOAP_SERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }

    auto deserialize(string en, hash<string, XsdAbstractType> tmap, *hash<auto> mrh, auto val) {
        switch (name) {
            case "binary": {
                if (val.typeCode() != NT_BINARY)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize type %y from type %y; requires binary", name, val.typeName());
                return val;
            }

            default: {
                throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }
}

#! XSD typed data class
public class WSDL::XsdTypedData inherits WSDL::XsdNamedData {
    public {
        *hash<auto> typeinfo;
        XsdAbstractType type;
    }

    constructor(reference e) : XsdNamedData(\e) {
    }
}

#! XSD attribute class
public class WSDL::XsdAttribute inherits WSDL::XsdTypedData {
    public {
        string use = "optional";

        const AllowedUseValues = (
            "optional": True,
            "required": True,
            "prohibited": True,
            );
    }

    constructor(hash<auto> attr, Namespaces nsc, *XsdAbstractType n_type, XsdLateResolverHelper unresolved) : XsdTypedData(\attr) {
        *hash<auto> aa = attr."^attributes^";
        if (aa.type) {
            if (!nsc.doType(aa.type, \typeinfo, \type))
                unresolved.add(self);

            if (aa.use) {
                if (!AllowedUseValues.(aa.use))
                    throw "XSD-ATTRIBUTE-ERROR", sprintf("attribute %y: use %y is unrecognized; recognized use values: %y", name, aa.use, AllowedUseValues.keys());
                use = aa.use;
            }
        }
    }

    auto getValue(string val) {
        return type.deserialize(name, new hash<string, XsdAbstractType>(), NOTHING, val);
    }
}

#! XSD element class
public class WSDL::XsdElement inherits WSDL::XsdTypedData {
    public {
        int minOccurs = 1;
        int maxOccurs = 1;
        bool nillable = False;
        # the resolved namespace URI for any reference
        *string ref_ns;
        # the source name for any reference
        *string ref;
        bool usedocns;
    }

    constructor(hash<auto> e, Namespaces nsc, *XsdAbstractType n_type, XsdLateResolverHelper unresolved, bool n_usedocns) : XsdTypedData(\e) {
        usedocns = n_usedocns;

        if (!ns)
            ns = nsc.getTargetNamespaceUri();

        if (n_type) {
            type = n_type;
            return;
        }

        *hash<auto> a = e."^attributes^";

        if (exists a.minOccurs)
            minOccurs = int(a.minOccurs);

        if (exists a.maxOccurs)
            if (a.maxOccurs == "unbounded")
                maxOccurs = -1;
            else
                maxOccurs = int(a.maxOccurs);

        if (maxOccurs != -1 && minOccurs > maxOccurs)
            throw "XSD-ELEMENT-ERROR", sprintf("minOccurs (%d) > maxOccurs (%d) for element %s", minOccurs, maxOccurs, name);

        if (a.nillable == "true")
            nillable = True;

        if (a.type) {
            if (!nsc.doType(a.type, \typeinfo, \type))
                unresolved.add(self);
        }
        else if (e.simpleType)
            type = new XsdSimpleType(e.simpleType, nsc, unresolved, usedocns, sprintf("simpleType for element %y", name));
        else if (e.hasKey("complexType")) {
            type = new XsdComplexType(e.complexType, nsc, unresolved, usedocns, sprintf("complexType for element %y", name));
            if (!type.isRequired() && !exists a.minOccurs)
                minOccurs = 0;
            if (type.isNillable() && !exists a.nillable)
                nillable = True;
        }
        else if (e."^attributes^".ref) {
            # issue #2786: must resolve ns prefixes immediately as with late resolution the context may be different
            (ref_ns, ref) = (e."^attributes^".ref =~ x/^([^:]*):(.*)$/);
            ref_ns = nsc.getNamespaceUri(ref_ns);
            unresolved.add(self);
        }
    }

    assimilate(WSDL::XsdElement other) {
        map self{$1.key} = $1.value, other.pairIterator(), !exists self{$1.key};
        # we have to use the namespace of the referenced element
        ns = other.ns;
    }

    bool isRequired() {
        return minOccurs > 0;
    }

    bool isNillable() {
        return nillable;
    }

    auto serialize(Namespaces nsc, auto h, *softbool omitType, string key, string typename) {
        if (h."^type^" && h."^type^" instanceof XsdAbstractType && h.hasKey("^val^")) {
            XsdAbstractType ntype = cast<XsdAbstractType>(h."^type^");
            ntype.checkExtends(type, name);
            return serializeAsIntern(nsc, ntype, h."^val^", omitType, key, name);
        }

        return serializeAsIntern(nsc, type, h, omitType, key, typename);
    }

    private auto serializeAsIntern(Namespaces nsc, XsdAbstractType type, auto h, *softbool omitType, string key, string typename) {
        #printf("DEBUG: XsdElement::serializeAsIntern() name: %y (with type: %y) h: %y key: %y typename: %y (%y) minOccurs: %y nillable: %y (%y %y)\n", name, ((!omitType || type != self.type) && type.hasRealName()), h, key, typename, type.getName(), minOccurs, nillable, !exists h, !minOccurs);

        int tc = h.typeCode();
        if (tc == NT_LIST && h.size() == 1)
            h = h[0];

        if (!exists h || (tc == NT_LIST && h.empty())) {
            if (!minOccurs)
                return;

            if (nillable || type.isNillable()) {
                hash<auto> rh = ("xsi:nil": "true");
                if ((!omitType || type != self.type) && type.hasRealName())
                    rh += ("xsi:type": type.getNameWithNS());
                return ("^attributes^": rh);
            }

            if (!type.isRequired())
                return;

            if (!type.requiresValue())
                return ("^value^": NOTHING);

            throw SOAP_SERIALIZATION_ERROR, sprintf("missing element %y value for %s::%s (minOccurs: %d, type %y)", name, typename, key, minOccurs, type.getName());
        }

        *hash<auto> pf;
        if ((!omitType || type != self.type) && type.hasRealName())
            pf = ("^attributes^": ("xsi:type": !usedocns ? type.getName() : type.getNameWithNS()));

        if (tc == NT_LIST) {
            int len = h.size();
            if (maxOccurs == 1 && len > 1)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y of type %y from a list<auto> with %d elements because maxOccurs = 1", name, type.getName(), len);
            if (len > maxOccurs && maxOccurs > 0)
                throw SOAP_SERIALIZATION_ERROR, sprintf("list<auto> for element %y of type %y has %d element%s, but maxOccurs = %d", name, type.getName(), elements h, elements h == 1 ? "" : "s", maxOccurs);
            if (len < minOccurs)
                throw SOAP_SERIALIZATION_ERROR, sprintf("list<auto> for element %y of type %y has %d element%s, but minOccurs = %d", name, type.getName(), elements h, elements h == 1 ? "" : "s", minOccurs);

            list<auto> l = ();
            foreach auto e in (h) {
                l += (pf + type.serialize(nsc, e, omitType));
            }
            return l;
        }
        if (minOccurs > 1)
            throw SOAP_SERIALIZATION_ERROR, sprintf("only one element passed to element %y of type %y, but minOccurs = %d", name, type.getName(), minOccurs);

        #printf("DEBUG: element %y type %s: %y omitType: %y h: %y\n", name, type.className(), type.name, omitType, h);
        return (pf + type.serialize(nsc, h, omitType));
    }

    auto deserialize(hash<string, XsdAbstractType> tmap, *hash<auto> mrh, auto val, bool present) {
        #printf("XsdElement::deserialize() name: %y type: %y (nillable: %y) val: %y present: %y\n", name, type.getName(), type.isNillable(), val, present);
        *hash<auto> a = val."^attributes^";
        if (a)
            WSDL::XsdBase::removeNS(\a);

        if ((!exists val && !present) || a.nil == "true") {
            if (nillable || type.isNillable() || !minOccurs)
                return;
            throw SOAP_DESERIALIZATION_ERROR, sprintf("NOTHING passed for element %y type %y, but nillable=False and minOccurs: %d", name, type.getName(), minOccurs);
        }

        if (val.typeCode() == NT_LIST) {
            int el = elements val;
            if (maxOccurs != -1 && el > maxOccurs)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, maxOccurs: %d but list<auto> is %d elements long", name, maxOccurs, el);
            if (el < minOccurs)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, minOccurs: %d but list<auto> is %d elements long", name, minOccurs, el);

            return map type.deserialize(name, tmap, mrh, getValue(mrh, $1)), val;
        }

        if (minOccurs > 1)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("single value passed for element %y, but minOccurs: %d", name, minOccurs);

        return type.deserialize(name, tmap, mrh, getValue(mrh, val));
    }
}

#! XSD simple type class
public class WSDL::XsdSimpleType inherits WSDL::XsdAbstractType {
    public {
        hash<auto> enum;
        hash<auto> typeinfo;
        list<hash<auto>> union;
        list<XsdAbstractType> unionTypes;
        XsdSimpleType unionSimpleType;
        XsdAbstractType type;
        #any type;
        bool usedocns;
    }

    constructor(hash<auto> st, Namespaces nsc, XsdLateResolverHelper unresolved, bool n_usedocns, *string desc_name) : XsdAbstractType(\st, nsc, desc_name) {
        usedocns = n_usedocns;
        #any a = st."^attributes^";
        delete st."^attributes^";

        WSDL::XsdBase::removeNS(\st);

        if (st.restriction) {
            hash<auto> r = st.restriction;

            *string base = r."^attributes^".base;
            if (!base)
                throw "XSD-SIMPLETYPE-ERROR", sprintf("missing 'base' attribute in simpleType %y restriction", name);

            if (!nsc.doType(base, \typeinfo, \type))
                unresolved.add(self);

            WSDL::XsdBase::removeNS(\r);

            if (r.enumeration)
                enum = map {$1."^attributes^".value: True}, r.enumeration;
        }
        else if (st.union) {
            hash<auto> u = st.union;
            *string memberTypes = u."^attributes^".memberTypes;
            if (memberTypes) {
                foreach string str in (memberTypes.split(" ")) {
                    XsdAbstractType type;
                    hash<auto> typeinfo;
                    if (nsc.doType(str, \typeinfo, \type)) {
                        unionTypes += type;
                    }
                    else {
                        union += typeinfo;
                    }
                }
            }
            WSDL::XsdBase::removeNS(\u);
            if (u.simpleType) {
                unionSimpleType = new XsdSimpleType(u.simpleType, nsc, unresolved, n_usedocns);
            }

            if (union) {
                unresolved.add(self);
            }
        }
        else if (st.list) {
            throw "XSD-SIMPLETYPE-ERROR", sprintf("unsupported list definition in simpleType %y", name);
        }
        else {
            throw "XSD-SIMPLETYPE-ERROR", sprintf("missing restriction, union, or list element in simpleType %y", name);
        }

        #printf("DEBUG: st: %y\n", self); exit();
    }

    auto serialize(Namespaces nsc, auto val, *softbool omitType) {
        *hash<auto> rh;
        if (val.typeCode() == NT_HASH) {
            foreach string k in (keys val) {
                if (k =~ /^\^comment/) {
                    rh{k} = remove val{k};
                }
            }
            if (val.size() == 1 && val.firstKey() == "^value^")
                val = val."^value^";
        }
        if (enum && !enum{val}) {
            throw "SOAP-SERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y is not in the enumeration list<auto> (%y)", val, name, enum.keys());
        }

        if (unionTypes) {
            # exception list
            list<auto> exl;
            foreach XsdAbstractType t in (unionTypes) {
                try {
                    return rh + t.serialize(nsc, val, omitType);
                }
                catch (hash<ExceptionInfo> ex) {
                    exl += ex;
                }
            }
            throw "SOAP-SERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y could not be serialized with union types: %y", val, name, (map sprintf("type %y: %s: %s", unionTypes[$#].getName(), $1.err, $1.desc), exl));
        }

        return rh + type.serialize(nsc, val, omitType);
    }

    auto deserialize(string en, hash<string, XsdAbstractType> tmap, *hash<auto> mrh, auto val) {
        if (unionTypes) {
            # exception list
            list<auto> exl;
            foreach XsdAbstractType t in (unionTypes) {
                try {
                    return t.deserialize(en, tmap, mrh, val);
                }
                catch (hash<ExceptionInfo> ex) {
                    exl += ex;
                }
            }
            throw "SOAP-DESERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y could not be deserialized with union types: %y", val, name, (map sprintf("type %y: %s: %s", unionTypes[$#].getName(), $1.err, $1.desc), exl));
        }

        auto v = type.deserialize(en, tmap, mrh, val);

        if (enum && !enum{v})
            throw "SOAP-DESERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y while deserializing element %y is not in the enumeration list<auto> (%y)", v, name, en, enum.keys());

        return v;
    }
}

#! complex type choice hash
public hashdecl WSDL::ChoiceInfo {
    hash<string, XsdElement> elementmap;
    bool required;
}

#! XSD complex type class
public class WSDL::XsdComplexType inherits WSDL::XsdAbstractType {
    public {
        *XsdArrayType array;
        *string restriction;
        *string extension;

        bool usedocns;

        hash<string, XsdElement> elementmap();
        bool anyAttribute = False;

        bool nillable = False;
        bool required = False;
        bool requires_value = False;

        # attributes
        hash<string, XsdAttribute> attrs();

        # any annotated documentation
        *string documentation;

        # temporarily used to store type information to resolve simpleType
        *hash<auto> simpleTypeInfo;
        # simpleContent type
        XsdAbstractType simpleType;

        # finalization flag
        bool finalized = False;

        # multiple choice blocks
        list<hash<ChoiceInfo>> choices();
    }

    private {
        #! type of complexType object
        string cx_type;

        const XET_ALL      = "ALL";
        const XET_CHOICE   = "CHOICE";
        const XET_SEQUENCE = "SEQUENCE";
        const XET_SIMPLE   = "SIMPLE";
        const XET_NONE     = "NONE";
    }

    # ct can be NOTHING in case of an empty complex type
    constructor(*hash<auto> ct, Namespaces nsc, XsdLateResolverHelper unresolved, bool n_usedocns, *string desc_name) : XsdAbstractType(\ct, nsc, desc_name) {
        usedocns = n_usedocns;
        #any a = ct."^attributes^";
        delete ct."^attributes^";

        *hash<auto> d = ct.complexContent;
        if (d) {
            WSDL::XsdBase::removeNS(\d);
            if (d.restriction) {
                WSDL::XsdBase::removeNS(\d.restriction);

                *string base = d.restriction."^attributes^".base;

                # FIXME: handle namespace
                (*string ns, *string tn) = (base =~ x/([^:]+):([^:]+)/);
                if (exists tn) {
                    if (tn == "Array") {
                        # FIXME check that namespace is SOAP encoding
                        auto aa = d.restriction.attribute."^attributes^";
                        WSDL::XsdBase::removeNS(\aa);
                        if (!exists aa.arrayType)
                            throw WSDL_ERROR, sprintf("cannot parse complexType restriction: %y", d.restriction);

                        # FIXME: handle multiple dimensions?
                        (*string ans, *string atn) = aa.arrayType =~ x/([^:]+):([^:]+)\[\]$/;
                        if (exists atn) {
                            array.val = atn;
                            array.ns  = ans;
                        }
                        else
                            array.val = aa.arrayType;

                        delete d.restriction.attribute;
                        #printf("DEBUG: ans: %y atn: %y aa: %y\n", ans, atn, aa);
                        return;
                    }
                    else {
                        restriction = tn;
                    }
                }

                delete d.restriction."^attributes^";

                parseData(d.restriction, unresolved, nsc);
            }
            else if (d.extension) {
                extension = d.extension."^attributes^".base;

                # FIXME: check for soap encoding namespace
                extension =~ s/(.*:)(.*)/$2/;
                delete d.extension."^attributes^";
                WSDL::XsdBase::removeNS(\d.extension);

                parseData(d.extension, unresolved, nsc);
            }
            else
                throw "XSD-COMPLEXCONTENT-ERROR", sprintf("can't parse complexContent %y %y information", getName(), d.firstKey());
        }
        else if (ct.simpleContent) {
            d = ct.simpleContent;
            WSDL::XsdBase::removeNS(\d);
            cx_type = XET_SIMPLE;

            simpleTypeInfo = nsc.getTypeHash(d.extension."^attributes^".base);
            unresolved.add(self);

            remove d.extension."^attributes^";
            WSDL::XsdBase::removeNS(\d.extension);
            parseAttributes(\d.extension, unresolved, nsc);
        }
        else if (ct)
            parseData(ct, unresolved, nsc);
        else {
            # empty complex type
            cx_type = XET_NONE;
            required = True;
            requires_value = False;
        }
    }

    finalize(hash<string, XsdAbstractType> tmap, Namespaces nsc) {
        if (finalized)
            return;
        finalized = True;

        # process restriction info
        if (restriction) {
            # combine base type and new type
            XsdAbstractType t = tmap_get(tmap, restriction);
            if (!(t instanceof XsdComplexType))
                throw WSDL_ERROR, sprintf("cannot restrict complexType %y with type %y", name, t.name);
            cast<XsdComplexType>(t).finalize(tmap, nsc);
            elementmap = cast<hash<string, XsdElement>>(cast<XsdComplexType>(t).elementmap + elementmap);
            #printf("DEBUG: extended %s with %s (%y)\n", name, restriction, cast<XsdComplexType>(t).elementmap.keys());
        }
        # process extension info
        else if (extension) {
            XsdAbstractType t = tmap_get(tmap, extension);
            if (!(t instanceof XsdComplexType))
                throw WSDL_ERROR, sprintf("cannot extend complexType %y with type %y", name, t.name);
            cast<XsdComplexType>(t).finalize(tmap, nsc);
            # combine base type and new type
            elementmap = cast<hash<string, XsdElement>>(cast<XsdComplexType>(t).elementmap + elementmap);
            #printf("DEBUG: extended %s (%s) with %s (%y) elements: %y\n", name, self.uniqueHash(), extension, cast<XsdComplexType>(t).elementmap.keys(), elementmap.keys());
        }

        # process array info
        if (array) {
            *string et = array.val;
            if (!et)
                throw WSDL_ERROR, sprintf("can't parse array type %y", array);
            array = new XsdArrayType(et, nsc);
        }
    }

    #! throws an exception if the types are not compatible
    checkExtends(XsdAbstractType t, string ename) {
        if (extension == t.name || t == self)
            return;
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible%s", name, ename, t.name, extension ? sprintf("; %y extends %y", name, extension) : "");
    }

    private parseData(hash<auto> d, XsdLateResolverHelper unresolved, Namespaces nsc) {
        delete d.ns;
        if (d.annotation) {
            *hash<auto> ah = remove d.annotation;
            if (ah.size() == 1 && ah.firstKey() =~ /documentation$/)
                documentation = trim(ah.firstValue());
        }
        if (!d)
            return;

        parseAttributes(\d, unresolved, nsc);

        if (!d) {
            cx_type = XET_NONE;
            required = True;
            requires_value = False;
            return;
        }

        if (d.size() > 1)
            throw WSDL_ERROR, sprintf("%s: expecting a single element in the complexType hash, got: %y", name, d.keys());

        string k = d.firstKey();
        if (k == "all") {
            cx_type = XET_ALL;
            WSDL::XsdBase::removeNS(\d.all);
            elementmap = parseElements(d.all.element, unresolved, nsc);
        }
        else if (k == "choice") {
            cx_type = XET_CHOICE;
            WSDL::XsdBase::removeNS(\d.choice);
            elementmap = parseElements(d.choice.element, unresolved, nsc);
        }
        else if (k == "sequence") {
            cx_type = XET_SEQUENCE;
            WSDL::XsdBase::removeNS(\d.sequence);
            if (d.sequence.element)
                elementmap = parseElements(d.sequence.element, unresolved, nsc);
            WSDL::XsdBase::removeNS(\d.sequence.choice);
            foreach hash<auto> ch in (d.sequence.choice) {
                #printf("ch: %y\n", ch);
                hash<string, XsdElement> h = parseElements(ch.element, unresolved, nsc, False);
                if (h) {
                    hash<ChoiceInfo> ech((
                        "elementmap": cast<hash<string, XsdElement>>(h),
                        "required": ch."^attributes^".minOccurs > 0,
                    ));
                    choices += ech;
                }
            }
        }
        else
            throw "XSD-COMPLEXTYPE-ERROR", sprintf("unknown keys in %y", d);
    }

    private parseAttributes(reference d, XsdLateResolverHelper unresolved, Namespaces nsc) {
        # process attributes if any
        foreach hash<auto> ah in (remove d.attribute) {
            if (ah."^attributes^") {
                XsdAttribute attr(ah, nsc, NOTHING, unresolved);
                attrs.(attr.name) = attr;
            }
        }

        if (d.hasKey("anyAttribute")) {
            anyAttribute = True;
            delete d.anyAttribute;
        }
    }

    bool isNillable() {
        return nillable;
    }

    bool isRequired() {
        return required;
    }

    bool requiresValue() {
        return requires_value;
    }

    bool isEmpty() {
        return !elementmap && !simpleType;
    }

    private hash<string, XsdElement> parseElements(softlist<auto> el, XsdLateResolverHelper unresolved, Namespaces nsc, bool for_object = True) {
        #printf("DEBUG: XsdComplexType::parseElements(%y)\n", el);
        hash<string, XsdElement> h();
        foreach hash<auto> e in (el) {
            #printf("DEBUG: XsdComplexType::parseElements() ns: %y e: %y\n", nsc.getTargetNamespaceUri(), e);
            XsdElement elem(e, nsc, NOTHING, unresolved, usedocns);
            h.(elem.name) = elem;

            if (for_object && !required && elem.isRequired())
                required = True;
        }

        if (for_object) {
            if (h.size() == 1 && h.firstValue().isNillable())
                nillable = True;
        }

        if (for_object && required && !nillable)
            requires_value = True;

        return h;
    }

    private *hash<auto> serializeElement(Namespaces nsc, string key, XsdElement element, auto h, *softbool omitType) {
        auto v = h{key};
        string e_ons;
        #printf("DEBUG: XsdComplexType::serializeElement() key: %y v: %y h: %y ns: %y\n", key, v, h, nsc.getTargetNamespaceUri());
        auto e = element.serialize(nsc, v, omitType, key, name);

        if (!exists e && !element.isRequired())
            return;

        /*
        if (e_ons != ons && e_ons != "xsd") {
            if (e.typeCode() != NT_HASH)
                e = ("^value^": e);
            e."^attributes^" = ("xmlns": nsc.getOutputNamespaceUri(ons));
        }
        */

        hash<auto> rv.(!usedocns ? key : (nsc.getOutputNamespacePrefix(element.ns) + ":" + key)) = e;
        return rv;
    }

    *hash<auto> serialize(Namespaces nsc, auto h, *softbool omitType) {
        if (exists array)
            return array.serialize(nsc, h, omitType);

        # process attributes first
        *hash<auto> ah;
        hash<auto> rh;
        if (h.typeCode() == NT_HASH) {
            if (h."^attributes^") {
                hash<auto> mah = remove h."^attributes^";
                foreach string k in (keys mah) {
                    if (!attrs{k})
                        throw SOAP_SERIALIZATION_ERROR, sprintf("cannot set unknown attribute %y of element %y; known attributes: %y", k, getName(), attrs.keys());
                    if (attrs{k}.use == "prohibited")
                        throw SOAP_SERIALIZATION_ERROR, sprintf("cannot set attribute %y of element %y; the WSDL marks this attribute as prohibited", k, getName());
                    ah{k} = mah{k};
                }
            }
            # check for required attributes
            foreach XsdAttribute attr in (attrs.iterator()) {
                if (attr.use == "required" && !exists ah.(attr.name))
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y without attribute %y; the WSDL marks this attribute as required", getName(), attr.name);
            }
            foreach string k in (keys h) {
                if (k =~ /^\^comment/) {
                    rh{k} = remove h{k};
                }
            }
        }

        if (cx_type == XET_SIMPLE) {
            if (exists h."^value^")
                h = h."^value^";
            rh."^value^" = simpleType.serialize(nsc, h, omitType);
        }
        else if (cx_type != XET_NONE) {
            if (exists h && h.typeCode() != NT_HASH)
                throw SOAP_SERIALIZATION_ERROR, sprintf("expecting hash<auto> argument to serialize from complexType %y (got %y, type %y)", getName(), h, type(h));

            if (cx_type == XET_SEQUENCE || cx_type == XET_ALL) {
                foreach string p in (keys elementmap) {
                    #printf("DEBUG element: %y (%y)\nvalue: %y\n", p, elementmap{p}, h{p});
                    rh += serializeElement(nsc, p, elementmap{p}, h, omitType);
                    delete h{p};
                }

                # when generating example messages we need generate all choices, in this case extra ^choices^ tag is used
                # choice name is unique in element so ne merge all choices together first
                *hash<auto> hch;
                foreach string k in (keys h) {
                    if (k =~ /^\^choices/) {
                        hch += remove h{k};
                    }
                }
                # also serialize each choice block, if any
                foreach hash<ChoiceInfo> ch in (choices) {
                    list<string> kl = ch.elementmap.keys();
                    *hash<auto> vh = h{kl};
                    *hash<auto> vhch = hch{kl};
                    if (!vh && !vhch) {
                        if (ch.required)
                            throw SOAP_SERIALIZATION_ERROR, sprintf("expecting one of %y to serialize choice / union in complexType %y but no such keys were supplied", ch.elementmap.keys(), getName());
                    }
                    else {
                        if (vh) {
                            rh += serializeChoice(nsc, ch.elementmap, vh, omitType, False);
                            # remove the serialized key from the input hash for the check below
                            map remove h{$1}, keys vh;
                        }
                        if (vhch) {
                            rh += serializeChoice(nsc, ch.elementmap, vhch, omitType, True);
                            map remove hch{$1}, keys vhch;
                        }
                    }
                }

                if (h) {
                    auto kl = h.size() == 1 ? h.firstKey() : h.keys();
                    throw SOAP_SERIALIZATION_ERROR, sprintf("%y %s of type %y (valid elements: %y)", kl, kl.lsize() == 1 ? "is an invalid member" : "are invalid members", getName(), elementmap.keys());
                }
                if (hch) {
                    throw SOAP_SERIALIZATION_ERROR, sprintf("unknown choice members %y provided via ^choices^ in %y", keys hch, getName());
                }
            }
            else { # "choice" - union
                rh = serializeChoice(nsc, elementmap, h, omitType, False);
            }
        }
        else { # "none"
            rh."^value^" = NOTHING;
        }

        #printf("DEBUG name: %y desc: %y\n", name, descriptive_name);
        if (name && !omitType && !descriptive_name)
            rh."^attributes^" += ("xsi:type": "ns1:" + name) + ah;
        else if (ah)
            rh."^attributes^" += ah;
        #printf("DEBUG complex type %s returning %y from %y\n", name, rh, h);
        return rh;
    }

    private hash<auto> serializeChoice(Namespaces nsc, hash<string, XsdElement> emap, hash<auto> h, *softbool omitType, bool all_members) {
        # normally there is only one choice but we also need output example message where all options are enumerated
        if (!all_members && elements h > 1)
            throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize choice / union in complexType %y with more than 1 member (%y)", getName(), h.keys());
        *hash<auto> rh;
        foreach string key in (keys h) {
            if (!emap{key})
                throw SOAP_SERIALIZATION_ERROR, sprintf("%y is an invalid member of choice / union in complexType %y; expecting one of: %y", key, getName(), emap.keys());

            # add namespace if necessary
            rh += serializeElement(nsc, key, emap{key}, h, omitType);
        }
        # add namespace if necessary
        return rh;
    }

    *hash<auto> deserialize(string en, hash<string, XsdAbstractType> tmap, *hash<auto> mrh, auto oval) {
        #printf("XsdComplexType::deserialize() name: %y val: %y required: %y\n", getName(), oval, required);
        if (exists array)
            return array.deserialize(en, tmap, mrh, oval);

        if (!exists oval) {
            if (!required)
                return;
        }

        hash<auto> rh;

        # to avoid "RUNTIME-TYPE-ERROR" exceptions in the next line`
        if (exists oval && oval.typeCode() != NT_HASH) {
            throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize complex type %y from Qore type %y (expecting \"hash\")", getName(), oval.type());
        }
        *hash<auto> val = oval;
        *hash<auto> attr = val."^attributes^";

        # attribute hash
        *hash<auto> ah;
        if (attr) {
            # parse incoming valid attributes
            foreach XsdAttribute xa in (attrs.iterator()) {
                *string attr_val = val."^attributes^".(xa.name);
                if (xa.use == "required" && !exists attr_val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y without attribute %y; the WSDL marks this attribute as required", getName(), xa.name);
                if (exists attr_val) {
                    if (attr.use == "prohibited")
                        throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y with attribute %y; the WSDL marks this attribute as prohibited", getName(), xa.name);
                    ah.(xa.name) = xa.getValue(attr_val);
                }
            }

            delete val."^attributes^";

            # ensure types match
            *string tn = attr."xsi:type";
            if (exists tn) {
                (*string ns, *string tname) = tn =~ x/(.*):(.*)/;
                if (exists tname)
                    tn = tname;
                if (tn != name) {
                    # check for compatible extension
                    *XsdAbstractType t = tmap_try_get(tmap, tn);
                    #printf("DEBUG: type provided %y: %y\n", tn, t.name);
                    if (t) {
                        t.checkExtends(self, en);
                        return t.deserialize(en, tmap, mrh, oval);
                    }

                    throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting ComplexType type %y for element %y, got %y", getName(), en, tn);
                }
            }
        }

        if (val.typeCode() == NT_HASH) {
            WSDL::XsdBase::removeNS2(\val);

            #any ns = val.".ns";
            val -= ".ns";
        }

        if (cx_type == XET_SIMPLE) {
            if (!exists val && !required)
                return;
            auto sv = simpleType.deserialize(name, tmap, mrh, val);
            if (sv.typeCode() == NT_HASH)
                rh = sv;
            else
                rh."^value^" = sv;
        }
        else if (cx_type != XET_NONE) {
            if (exists val && val.typeCode() != NT_HASH)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y type %y from qore type %y (expecting hash)", en, getName(), val.type());

            if (cx_type == XET_SEQUENCE || cx_type == XET_ALL) {
                #printf("XsdComplexType::deserialize() name: %y val: %y required: %y\n", getName(), val, required);
                # if we have one element
                if (elementmap.size() == 1 && val.size() == 1
                    && val.firstKey() == elementmap.firstKey()
                    && !exists val{elementmap.firstKey()} && !required && !choices)
                    return;

                foreach string p in (keys elementmap) {
                    #printf("element %y\n", p);
                    rh{p} = elementmap{p}.deserialize(tmap, mrh, getValue(mrh, val{p}), val.hasKey(p));
                    delete val{p};
                }
                # also parse each choice block, if any
                foreach hash<ChoiceInfo> ch in (choices) {
                    *hash<auto> vh = val.(ch.elementmap.keys());
                    *hash<auto> h = parseChoice(vh, ch.elementmap, en, tmap, mrh, ch.required);
                    if (h)
                        rh += h;
                    delete val.(h.keys());
                    #printf("choice em: %y h: %y\n", ch.elementmap.keys(), h);
                }
                delete val."^attributes^";
                if (val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("invalid element %y passed in type %y for element %y (expecting %y)", (keys val)[0], getName(), en, keys elementmap);
            }
            else { # "choice" - union
                rh += parseChoice(val, elementmap, en, tmap, mrh, True);
            }
        }

        if (ah)
            rh."^attributes^" = ah;
        return rh;
    }

    private *hash<auto> parseChoice(hash<auto> val, hash<string, XsdElement> emap, string en, hash<string, XsdAbstractType> tmap, *hash<auto> mrh, *bool required) {
        list<auto> kl = val.keys();
        if (elements kl > 1)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("too many elements supplied for choice / union in type %y for element %y (%y)", getName(), en, kl);
        *string key = kl[0];
        if (!exists key) {
            if (required)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("missing element for choice / union in type %y for element %y (expecting one of: %y)", getName(), en, emap.keys());
            return;
        }
        if (!exists emap{key})
            throw SOAP_DESERIALIZATION_ERROR, sprintf("element %y is not a valid element for choice / union in type %y for element %y (valid elements: %y)", key, getName(), en, emap.keys());

        return (key: emap{key}.deserialize(tmap, mrh, getValue(mrh, val{key}), val.hasKey(key)));
    }
}

#! web service operation class
public class WSDL::WSOperation inherits WSDL::XsdNamedData {
    public {
        #! request message
        WSMessage input;
        #! response message
        WSMessage output;
        #! request message name
        *string input_name;
        #! response message name
        *string output_name;

        #! namespace container
        Namespaces nsc;

        #! the SOAPAction header value to send with this operation
        *string soapAction;

        #! a hash of top-level request names for this operation (depends on bindings)
        hash<string, bool> reqh;

        #! params per associated binding; key = binding name; value = OperationalBinding object
        hash<string, OperationalBinding> bindings;
    }

    private {
        #! fault messages keyed by fault name
        hash<string, WSMessage> faults;
    }

    #! creates the WSOperation object from the arguments supplied
    /** @param p the raw hash from deserialized XML data for the operation
        @param nsc the namespace container
        @param messages a hash of messages defined in the WSDL; keys are message names; values are WSMessage objects
     */
    constructor(hash<auto> p, Namespaces nsc, *hash<auto> messages) : XsdNamedData(\p) {
        self.nsc := nsc;

        if (p.input) {
            hash<auto> msghash = processNSValue(p.input."^attributes^");

            *WSMessage msg = messages.(msghash.message.val);
            if (!msg)
                throw WSDL_ERROR, sprintf("missing definition for input message %y required by operation %y", msghash.name.val ?? msghash.name ?? msghash.message.val, name);
            input := msg;

            #printf("DBG: WSOperation::constructor() name: %y msghash: %y\n", name, msghash);
            if (msghash.name)
                input_name = msghash.name.val ?? msghash.name;
        }

        if (p.output) {
            hash<auto> msghash = processNSValue(p.output."^attributes^");

            *WSMessage msg = messages.(msghash.message.val);
            if (!msg)
                throw WSDL_ERROR, sprintf("missing definition for output message %y required by operation %y", msghash.name.val ?? msghash.name ?? msghash.message.val, name);

            output := msg;
            if (msghash.name)
                output_name = msghash.name.val ?? msghash.name;
        }

        # issue #2804: process fault messages
        foreach hash<auto> fh in (p.fault) {
            hash<auto> msghash = processNSValue(fh."^attributes^");

            *WSMessage msg = messages{msghash.message.val};
            if (!msg) {
                throw WSDL_ERROR, sprintf("missing definition for fault message %y required by operation %y", msghash.name.val, name);
            }

            string fault_name = msghash.name.val ?? msghash.name;
            faults{fault_name} = msg;
            #printf("DEBUG: op %y fault %y msg %y\n", name, fault_name, msg.name);
        }

        *string op_ns = nsc.getTargetNamespaceUri();
        if (op_ns && op_ns !~ /\/$/)
            op_ns += "/";
        soapAction = op_ns ? op_ns + name : name;
    }

    #! returns a hash of fault messages keyed by fault name
    hash<string, WSMessage> getFaultMessages() {
        return faults;
    }

    #! returns True if the given string is a valid fault message for the operation
    bool hasFault(string fault) {
        return faults.hasKey(fault);
    }

    #! this method is called if this operation supports at least one binding with document style
    setDocStyleBinding(reference idocmap) {
        foreach string key in (keys input.args) {
            # FIXME: could be a type here instead of an element
            if (!input.args{key}.element.name) {
                return;
            }

            string element = input.args{key}.element.name;
            idocmap{element} := input.args{key}.element;
            reqh{element} = True;
        }
    }

    #! this method is called if this operation supports at least one binding with RPC style
    markRpcStyleBinding() {
        reqh{name} = True;
    }

    #! returns all top-level request names for this operation
    list<auto> getTopLevelRequestNames() {
        return reqh.keys();
    }

    #! returns a hash representing the given binding
    /** @param bname the name of the binding, if not provided then uses the first assigned binding

        @return a binding param hash describing the binding with the following keys:
        - \c "httpMethod"
        - \c "soapTransport"

        @throw WSDL-BINDING-ERROR unknown binding
     */
    OperationalBinding getBinding(*string bname) {
        if (bindings && !exists bname)
            return bindings.firstValue();
        if (!exists bindings{bname})
            throw "WSDL-BINDING-ERROR", sprintf("binding %y is not a known binding for operation %y; known bindings: %y", bname, name, bindings.keys());
        return bindings{bname};
    }

    #! adds the given binding
    /** @param bname binding name, must be unique in operation
        @param opparams a hash with the following keys:
        - \c "httpMethod"
        - \c "soapTransport"

        @throw WSDL-BINDING-ERROR when binding already registered
     */
    addBinding(WSDL::OperationalBinding b) {
        string bname = b.getName();
        if (bindings.hasKey(bname))
            throw "WSDL-BINDING-ERROR", sprintf("binding %y is already registered in operation %y", bname, name);
        bindings{bname} = b;
    }

    #! serializes a fault response to an XML string or HTTP payload for the operation.
    /** @param fault an optional fault message for the operation (@see getFaultMessages())
        @param h the fault data to serialize
        @param header optional soap header info to serialize if required (ex: authorization info). In the first step headers are matched to binding/input/header WSDL definition, remaining headers are passed as-is
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @param nsh an optional namespace hash for the output message
        @param xml_opts optional XML generation options
        @param req_soapaction if present will override any SOAPAction value for the request, ignored for HTTP binding
        @param bname SOAP binding name or empty to get the first assigned binding

        @return a hash with keys:
        - \c body: XML string in the SOAP response format or body part of HTTP message (string or binary). Target content type is evaluated from WSDL or in case of ambiguity
        using "^attributes^"."^content-type^". Provided content type must match allowed types in WSDL. Also "application/x-www-form-urlencoded" or any general type are supported.
        - \c hdr: hash of HTTP headers
        - \c path: the path part of URL. Used when urlEncoded is defined
        - \c method: the HTTP request method
        */
    hash<auto> serializeFault(*string fault, string faultmsg, auto h, *hash<auto> header, *string enc, *hash<auto> nsh, *int xml_opts, *string req_soapaction, *string bname) {
        if (exists fault && !faults{fault}) {
            throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize unknown fault %y for operation %y; known faults: %y", fault, name, keys faults);
        }
        return getBinding(bname).serializeMessage(self, faults{fault}, False, nsc.hasSoap12(), h, header, enc, nsh, xml_opts, req_soapaction, faultmsg);
    }

    #! serializes a request to an XML string or HTTP payload for the operation.
    /** @param h the request to serialize
        @param header optional soap header info to serialize if required (ex: authorization info). In the first step headers are matched to binding/input/header WSDL definition, remaining headers are passed as-is
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @param nsh an optional namespace hash for the output message
        @param xml_opts optional XML generation options
        @param req_soapaction if present will override any SOAPAction value for the request, ignored for HTTP binding
        @param bname SOAP binding name or empty to get the first assigned binding

        @return a hash with keys:
        - \c body: XML string in the SOAP request format or body part of HTTP message (string or binary). Target content type is evaluated from WSDL or in case of ambiguity
        using "^attributes^"."^content-type^". Provided content type must match allowed types in WSDL. Also "application/x-www-form-urlencoded" or any general type are supported.
        - \c hdr: hash of HTTP headers
        - \c path: the path part of URL. Used when urlEncoded is defined
        - \c method: the HTTP request method
    */
    hash<auto> serializeRequest(auto h, *hash<auto> header, *string enc, *hash<auto> nsh, *int xml_opts, *string req_soapaction, *string bname, *hash<auto> http_headers) {
        return getBinding(bname).serializeMessage(self, input, True, nsc.hasSoap12(), h, header, enc, nsh, xml_opts, req_soapaction, NOTHING, http_headers);
    }

    #! serializes a SOAP response to an XML string for the operation
    /** @param h the response to serialize
        @param header SOAP header hash. In the first step headers are matched to binding/input/header WSDL definition, remaining headers are passed as-is
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @param nsh namespace hash
        @param soap12 set to True if the response should use SOAP 1.2 encoding
        @param xml_opts optional XML generation options
        @param bname SOAP binding name, leave empty to get the first assigned binding
        @param http_headers HTTP headers to serialize in the response

        @return a hash with keys:
        - \c body: XML string in the SOAP request format or body part of HTTP message (string or binary). Target content type is evaluated from WSDL or in case of ambiguity
        using "^attributes^"."^content-type^". Provided content type must match allowed types in WSDL.
        - \c hdr: hash of HTTP headers
    */
    hash<auto> serializeResponse(auto h, *hash<auto> header, *string enc, *hash<auto> nsh, *bool soap12, *int xml_opts, *string bname, *hash<auto> http_headers) {
        if (exists soap12) {
            if (soap12) {
                if (!nsc.hasSoap12())
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize response for operation %y with SOAP 1.2 encoding; this operation does not support SOAP 1.2", name);
            }
            else {
                if (!nsc.hasSoap11())
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize response for operation %y with SOAP 1.1 encoding; this operation does not support SOAP 1.1", name);
            }
        }
        else
            soap12 = nsc.hasSoap12();

        return getBinding(bname).serializeMessage(self, output, False, soap12, h, header, enc, nsh, xml_opts, NOTHING, NOTHING, http_headers);
    }

    #! parses a hash representing a parsed XML request (parsed with @ref parse_xml() "parse_xml(XPF_PRESERVE_ORDER)") for the operation and returns the corresponding Qore data structure
    /** @param o the parsed SOAP or HTTP request with @ref WSDLLib::parseSOAPMessage() for the operation
        @param bname SOAP binding name, leave empty to use the first assigned binding
        @return the Qore data structure corresponding to the request data. When SOAP header is deserialized according binding/input WSDL then all data are passed under subhash vales prefixed by message name
        In case of HTTP binding the content type is matched against WSDL binding when wildcards are supported and current content type value is applied to "^attributes^"."^content-type^".
    */
    auto deserializeRequest(hash<auto> o, *string bname) {
        return getBinding(bname).deserializeMessage(self, o, True);
    }

    #! parses a hash representing a parsed XML response (parsed with @ref parse_xml() "parse_xml(XPF_PRESERVE_ORDER)") for the operation and returns the corresponding Qore data structure
    /** @param o the parsed SOAP or HTTP request with @ref WSDLLib::parseSOAPMessage() for the operation
        @param bname SOAP binding name, leave empty to use the first assigned binding
        @return the Qore data structure corresponding to the response data. When SOAP header is deserialized according binding/output WSDL then all data are passed under subhash vales prefixed by message name
        In case of HTTP binding the content type is matched against WSDL binding when wildcards are supported and current content type value is applied to "^attributes^"."^content-type^".
    */
    auto deserializeResponse(hash<auto> o, *string bname) {
        return getBinding(bname).deserializeMessage(self, o, False);
    }

    /** Operation is resolved from method and path so let's look if data are passed in URL.
        When URL replacement is defined for operation then exception is raised.
        @return NOTHING if data are not encoded in URL for operation
    */
    *hash<auto> deserializeRequestPath(string path, *string bname) {
        return getBinding(bname).deserializeRequestPath(self, path);
    }

    #! processes a hash of raw deserialized XML data and removes any namespace prefix from keys (saved to a \c "ns" key in the hash vale assigned to the key) and returns the processed version of the hash
    static private hash<auto> processNSValue(hash<auto> h) {
        foreach string k in (keys h) {
            (*string ns, *string name) = h{k} =~ x/([^:]+):([^:]+)/;
            if (!name)
                h{k}.val = h{k};
            else {
                h{k}.ns = ns;
                h{k}.val = name;
            }
        }
        return h;
    }

    #! returns True if the operation is a SOAP 1.2 operation
    /** @return True if the operation is a SOAP 1.2 operation
    */
    bool isSoap12() {
        return nsc.hasSoap12();
    }

    #! returns the target namespace for the operation
    /** @return the target namespace for the operation
    */
    string getTargetNS() {
        return nsc.getTargetNamespaceUri();
    }
}

#! message argument hash description
public hashdecl WSDL::ArgInfo {
    #! the arg name
    string name;

    #! unique part name
    string part;

    #! type for the argument
    XsdAbstractType type;

    #! element for the argument
    XsdElement element;
}

#! web service message class
/**
Message definition consists of part definition. Part name is important for simple types to name it at both SOAP and Qore side (hash key).
For elements is not used at the SOAP side, it implies condition the element name must be unique in message. In the other words
it's forbidden definition of two parts with the same element. It's unclear if is legal in Wsdl and how to handle it. Class raises
exception if detects it. The part name is also used for references from binding (header, content).
*/
public class WSDL::WSMessage inherits WSDL::XsdNamedData {
    public {
        #! args keys are part names for types reps. element names for element. Definition must provide unique values.
        hash<string, hash<WSDL::ArgInfo>> args;

        #! part map; maps element names to part names
        #! maps part names to args key, all parts are in hash
        hash<string, string> pmap;

        #! type map
        hash<string, XsdAbstractType> tmap;

        # keep a weak reference to the namespace map
        Namespaces nsc;
    }

    constructor(hash<auto> m, hash<string, hash<string, XsdElement>> emap, hash<string, XsdAbstractType> tmap, Namespaces nsc) : XsdNamedData(\m) {
        self.tmap = tmap;
        self.nsc := nsc;

        #printf("DEBUG: WSMessage::constructor() m: %y emap: %y\n", m, emap);

        name = m."^attributes^".name;
        foreach auto p in (m.part) {
            *hash<auto> part = p."^attributes^";

            # issue #2786: make sure and capture any ns prefix definitions / overrides here
            NamespacePrefixHelper nph(nsc, part);

            if (!exists part.name)
                throw WSDL_ERROR, sprintf("missing part name message %y", name);
            if (pmap{part.name})
                throw WSDL_ERROR, sprintf("duplicate part name %y in message %y", part.name, name);
            if (part.element) {
                (*string ns, *string ename) = part.element =~ x/([^:]+):([^:]+)/;
                if (!ename)
                    ename = part.element;
                if (args{ename})
                    throw WSDL_ERROR, sprintf("ambiguous element name %y in message %y", ename, name);

                # is unique name required or not ?
                if (!args{ename})
                    args{ename} = new hash<ArgInfo>();
                args{ename}.part = part.name;
                pmap{part.name} = ename;

                args{ename}.element = emap_get(emap, nsc.getNamespaceUri(ns), ename);
            }
            else {
                if (args{part.name})
                    throw WSDL_ERROR, sprintf("part name collides with element %y in message %y, ", part.name, name);
                hash<auto> h;
                args{part.name} = cast<hash<ArgInfo>>(part{("name", "part")});
                if (!nsc.doType(part.type, \h, \args{part.name}.type))
                    throw WSDL_ERROR, sprintf("cannot resolve type %y for element %y in message %y, ", part.type, part.name, name);
                pmap{part.name} = part.name;
            }
        }
    }

    /**
        Just serialize value and return namespace
        @param ons is reference to string
    */
    auto serializeRpcValue(string part, bool encoded, reference h, reference ons) {
        string key = pmap{part};
        auto v = getValueFromHash(key, \h, True);
        if (!exists v) {
            if (key || args.size() == 1) {
                v = getValueFromHash(args{key}.element, \h, True);
            }
            if (!exists v)
                return;
        }
        if (v.typeCode() == NT_NULL)
            delete v;

        auto hv;
        #printf("DEBUG: part: %y, key: %y, with %y\n", part, key, args{key});
        #printf("DEBUG: serializeRpcValue, part: %y, key: %y, val: %y\n", part, key, v."^val^" ?? v);
        if (args{key}.element) {
            hv = args{key}.element.serialize(nsc, v, !encoded, key, name);
            ons = nsc.getOutputNamespacePrefix(args{key}.element.ns);
        }
        else {
            hv = args{key}.type.serialize(nsc, v, !encoded);
            ons = args{key}.type.getOutputNamespacePrefix();
        }
        #printf("DEBUG: arg %s got %y from %y (%y)\n", k, hv, v, exists args{key}.element ? args{key}.element : args{key}.type);
        return hv;
    }

    #! serializes data into a hash with SOAP namespaces etc. with RPC-style messages
    /**
        @param parts if present then serializes only particular element or part, if NOTHING then serializes all message elements
        @param msginfo a description of the message for the current binding, if available
        @param n_name name of output key
        @param encoded if the encoded use module should be used (or the literal use model)
        @param h data to be serialized, keys are wsdl element names (or optionally the part name) and part names for simple types
        @param fault @ref True if serializing a fault response
     */
    *hash<auto> serializeRpc(*softlist<auto> parts, *WSDL::BindingMessageDescription msginfo, *MultiPartRelatedMessage mpm, string n_name, bool encoded, reference h, bool fault) {
        hash<auto> rh;
        #printf("DEBUG: message %s: parts: %y, pmap: %y, h: %y\n", name , parts, pmap, ,h);
        foreach string part in (parts ?? keys pmap) {
            string ons;
            auto hv = serializeRpcValue(part, encoded, \h, \ons);
            if (!exists hv)
                continue;
            string k = pmap{part};
            /* FIXME: handle multipart messages
            #printf("DEBUG: WSMessage::serialize() k: %y args: %y, parts: %y\n", k, keys args, msginfo.parts);
            if (msginfo.parts{k}) {
                any ct = msginfo.parts{k};
                if (ct.typeCode() == NT_LIST)
                    ct = shift ct;
                mpm.addPart(hv, sprintf("<%s>", k), ct);
                hv."^attributes^".href = "cid:" + k;
            }
            */
            rh{args{k}.element ? (ons + ":" +  k) : k} = hv;
        }

        if (rh) {
            if (encoded)
                rh."^attributes^" += (
                    "soapenv:encodingStyle": SOAP_ENCODING,
                    "xmlns:soapenc": SOAP_ENCODING,
                );

            # issue #2804: do not wrap the fault data with the request name
            if (fault) {
                return rh;
            }

            return {"ns1:" + n_name: rh};
        }
    }

    #! serializes data into a hash with SOAP namespaces etc. with document-style messages
    /**
        @param parts if present then serializes only particular element or part, if NOTHING then serializes all message elements
        @param msginfo a description of the message for the current binding, if available
        @param mpm a multipart message object, for future use
        @param encoded if the encoded use module should be used (or the literal use model)
        @param h data to be serialized, keys are wsdl element names (optionally part name is also possible) and part names for simple types
        @param fault @ref True if serializing a fault response
     */
    *hash<auto> serializeDocument(*softlist<auto> parts, *WSDL::BindingMessageDescription msginfo, *MultiPartRelatedMessage mpm, bool encoded, reference h, bool fault) {
        hash<auto> rh;

        #printf("DEBUG: WSMessage::serializeDocument() parts: %y h: %y args: %y, pmap: %y\n", parts, h.typeCode()==NT_HASH ?  h.keys() : h, args.keys(), pmap);

        if (args.size() == 1) {
            string fk = args.firstKey();
            if (!parts) {
                /*
                for backwards compatibility with a single argument, just when parts is NOTHING which is used for body
                serialization when is no explicit part name.
                */
                if (h.typeCode() != NT_HASH) {
                    h  = (fk: h);
                } else {
                    # it is ambiguous so do not do any heuristic
                }
            }
        }
        foreach string p in (parts ?? keys pmap) {
            string k = pmap{p};
            auto val = getValueFromHash(k, \h, True);
            if (!exists val) {
                if (parts || args.size() == 1) {
                    val = getValueFromHash(args{k}.element, \h, True);
                }
                if (!exists val) continue;
            }
            if (val.typeCode() == NT_NULL)
                val = NOTHING;
            if (val.typeCode() == NT_HASH)
                XsdBase::removeNS2(\val);
            #printf("DEBUG: k: %y val: %y, args: %y\n", k, val, keys args);
            hash<auto> arg = args{k};
            if (arg.element) {
                auto th = arg.element.serialize(nsc, val, !encoded, k, name);
                string ons = nsc.getOutputNamespacePrefix(arg.element.ns);
                rh{ons + ":" + k} = th;
            } else {
                auto th = arg.type.serialize(nsc, val, !encoded);
                rh{p} = th;
            }
        }

        if (encoded && rh)
            rh."^attributes^" += (
                "soapenv:encodingStyle": SOAP_ENCODING,
                "xmlns:soapenc": SOAP_ENCODING,
            );

        #printf("DEBUG: message %s: pmap: %y rh: %y\n", name, pmap, rh);

        return rh;
    }

    #! deserialize RPC message
    /**
    @param val, keys are element names or part names for simple types
    @param part if exists then deserialize only particular part
    @return serialized data, keys are wsdl element names (optionally part name is also possible) and part names for simple types
    */
    *hash<auto> deserializeRpc(*hash<auto> mrh, hash<auto> val, *string part) {
        #printf("DBG WSMessage::deserializeRpc() pmap: %y part: %y val: %y\n", pmap, part, val);
        hash<auto> ro;

        foreach string p in (part ?? keys pmap) {
            string k = getSerializedKey(p);
            bool present = val.hasKey(k);
            auto v = remove val{k};
            hash<auto> arg = args{k};
            #printf("DBG WSMessage::deserializeRpc() part: %y, key: %y, val: %y\n", p, k, v);
            if (v.typeCode() == NT_HASH) {
                XsdBase::removeNS2(\v);
            }
            if (arg.element) {
                ro{p} = arg.element.deserialize(tmap, mrh, getValue(mrh, v), present);
            } else {
                ro{p} = arg.type.deserialize(name, tmap, mrh, getValue(mrh, v));
            }
        }

        if (val && !exists part)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", val.keys(), name);

        # if there is only one argument, return it directly
        return ro;
    }

    *hash<auto> deserializeDocument(*hash<auto> mrh, auto val, *string parts) {
        hash<auto> rh;

        *hash<auto> attr = remove val."^attributes^";

        #printf("DBG WSMessage::deserializeDocument() pmap: %y val: %y\n", pmap, val);
        if (args.size() == 1) {
            string k = getSerializedKey(pmap.firstKey());
            if (val.typeCode() != NT_HASH || !val.hasKey(k)) {
                auto v = val;
                val = hash();
                val{k} = v;
            }
        }

        foreach string p in (parts ?? keys pmap) {
            string k = getSerializedKey(p);
            bool present = val.hasKey(k);
            auto v = remove val{k};
            #printf("DBG WSMessage::deserializeDocument() part: %y, key: %y, val: %y\n", p, k, v);
            if (v.typeCode() == NT_HASH) {
                XsdBase::removeNS2(\v);
            }
            hash<auto> arg = args{pmap{p}};
            if (arg.element) {
                rh{p} = arg.element.deserialize(tmap, mrh, getValue(mrh, v), present);
            } else {
                rh{p} = arg.type.deserialize(name, tmap, mrh, getValue(mrh, v));
            }
        }

        if (val && !exists parts)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", val.keys(), name);

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\nRH: %y\n", args.keys(), val, rh);
        return rh;
    }

    #! serialize all values as string or binary
    /**
        @return hash of all parts in key-value pair
    */
    hash<auto> serializeAllPartData(*hash<auto> val) {
        return map {$1: serializeData(nsc, $1, val).value}, keys args;
    }

    #! serialized value of particular type value as string or binary
    /**
        @param val value to be resolved
        @param key member name, it is requires reference to a simple type, not compaund element

        @return as hash with 'value' and optional 'content-type' key passed from v.content-type if exists
     */
    hash<auto> serializeData(Namespaces nsc, string key, *hash<auto> val) {
        if (args{key}.element) {
            throw SOAP_SERIALIZATION_ERROR, sprintf("cannot get element value %y in message %y. Type part is needed", key, name);
        }
        auto v = getValueFromHash(key, \val, False);
        if (v.typeCode() == NT_NULL)
            v = NOTHING;
        hash<auto> rv.value = args{key}.type.serialize(nsc, v, False){"^value^"};
        if (v.typeCode() == NT_HASH) {
            rv."content-type" = v."^attributes^"."^content-type^";
        }
        return rv;
    }

    #! deserialize value in string or binary form
    /**
        @return hash<auto> in key-value pair
    */
    hash<auto> deserializeData(string part, hash<auto> val) {
        hash<auto> rv;
        hash<auto> arg = args{pmap{part}};
        rv{part} = arg.element
            ? arg.element.deserialize(tmap, NOTHING, val{pmap{part}}, val.hasKey(pmap{part}))
            : arg.type.deserialize(name, tmap, NOTHING, val{pmap{part}});
        return rv;
    }

    #! deserialize all values in string or binary form
    /**
        @return hash of all parts in key-value pair
    */
    hash<auto> deserializeAllPartData(hash<auto> val) {
        hash<auto> rv = {};
        #printf("deserializeAllPartData: pmap: %y, val: %y\n", pmap, val);
        foreach string p in (keys pmap) {
            rv += deserializeData(p, val);
        }
        return rv;
    }

    #! find part in value, remove that value from the hash
    /**
        @param ename element/type name
        @param reference to hash, supposed structure is [msgname.](partname|elemname) = value to support more message data in one hash
        @param removeFound if True found values are removed from the hash

        @return resolved value, if not found then returns NOTHING
    */
    private:internal auto getValueFromHash(string ename, reference v, bool removeFound) {
        #printf("DEBUG: WSMessage::getValueFromHash() ename: %y v: %y rF: %y args: %y args{%y}.part: %y\n", ename, v, removeFound, args.keys(), ename, args{ename}.part);

        auto rv;
        string k;
        # there is no unique part namespace as it may contain more messages in one hash, so let's do a little heuristic
        if (v.hasKey(name)) {
            if (args{ename}.part && exists v{name}{args{ename}.part}) {
                k = args{ename}.part;
            } else if (exists v{name}{ename}) {
                k = ename;
            }
            if (k) {
                rv = v{name}{k};
                if (removeFound) {
                    remove v{name}{k};
                    if (!v{name}) {
                        remove v{name};
                    }
                }
            }
        }
        if (!k) {
            if (args{ename}.part && exists v{args{ename}.part}) {
                k = args{ename}.part;
            } else if (v.hasKey(ename)) {
                k = ename;
            }
            if (k) {
                rv = v{k} ?? NULL;
                if (removeFound) {
                    remove v{k};
                    if (!v{name}) {
                        remove v{name};
                    }
                }
            }
        }
        return rv;
    }

    #! when only one arg then try to get values based on element keys
    private:internal auto getValueFromHash(*WSDL::XsdElement element, reference v, bool removeFound) {
        if (!element) return;
        if (element.type instanceof WSDL::XsdComplexType) {
            XsdComplexType type = cast<WSDL::XsdComplexType>(element.type);
            hash<auto> rv;
            if (type.isEmpty()) {
                # special case, empty complex type
                return NULL;
            } else {
                foreach string ename in (keys type.elementmap) {
                    auto val = getValueFromHash(ename, \v, removeFound);
                    if (exists val) {
                        if (val.typeCode() == NT_NULL)
                            val = NOTHING;
                        rv{ename} = val;
                    }
                }
            }
            return rv;
        }
    }

    string getSerializedKey(string part) {
        return args{pmap{part}}.element ? pmap{part} : part;
    }

    #! check if pname is defined as message part
    /** @return translated part name to element/type name
     */
    string checkPart(string pname) {
        if (!pmap{pname}) {
            throw sprintf("%y is an unknown part in message %y, defined parts: %y", pname, name, keys pmap);
        }
        return pmap{pname};
    }
}

# private helper class for lazy name resolution
class WSDL::XsdLateResolverHelper {
    private {
        list<object> l();
    }

    constructor() {
    }

    add(object v) {
        l += v;
    }

    list<auto> getList() {
        return l;
    }

    clearResolved() {
        l = map $1, l, !isResolved($1);
    }

    static bool isResolved(XsdTypedData t) {
        return t.type instanceof XsdAbstractType;
    }

    static bool isResolved(XsdSimpleType t) {
        return t.type instanceof XsdAbstractType;
    }

    static bool isResolved(XsdComplexType t) {
        return t.simpleType instanceof XsdAbstractType;
    }

    static bool isResolved(auto t) {
        return False;
    }
}

#! class for WSDL bindings associated with a SOAP operation
public class WSDL::OperationalBinding inherits WSDL::XsdNamedData {
    public {
        bool docstyle;
        *WSDL::BindingMessageDescription input;
        *WSDL::BindingMessageDescription output;
        *string soapAction;
    }

    constructor(string name, string ns, bool docstyle, *string soapAction, *WSDL::BindingMessageDescription input, *WSDL::BindingMessageDescription output) : XsdNamedData(name, ns) {
        self.docstyle = docstyle;
        self.soapAction = soapAction;
        self.input = input;
        self.output = output;
    }

    hash<auto> serializeMessage(WSOperation op, *WSMessage msg, bool request, bool soap12, auto h, *hash<auto> header, string enc = "UTF-8", *hash<auto> nsh, *int xml_opts, *string req_soapaction, *string faultmsg, *hash<auto> http_headers) {
        return serializeMessageImpl(op, msg, request, soap12, h, header, enc, nsh, xml_opts, req_soapaction, faultmsg, http_headers);
    }

    auto deserializeMessage(WSOperation op, hash<auto> o, bool request) {
        return deserializeMessageImpl(op, o, request);
    }

    auto deserializeRequestPath(WSOperation op, string path) {
        return deserializeRequestPathImpl(op, path);
    }

    abstract hash<auto> serializeMessageImpl(WSOperation op, *WSMessage msg, bool request, bool soap12, auto h, *hash<auto> header, string enc, *hash<auto> nsh, *int xml_opts, *string req_soapaction, *string faultmsg, *hash<auto> http_headers);

    abstract auto deserializeMessageImpl(WSOperation op, hash<auto> o, bool request);

    abstract auto deserializeRequestPathImpl(WSOperation op, string path);
}

public class WSDL::SoapBinding inherits WSDL::OperationalBinding {
    public {
        string soapTransport;
    }

    constructor(string name, string ns, bool docstyle, string soapTransport, *string soapAction, *WSDL::BindingMessageDescription input, *WSDL::BindingMessageDescription output) : OperationalBinding(name, ns, docstyle, soapAction, input, output) {
        self.soapTransport = soapTransport;
    }

    hash<auto> serializeMessageImpl(WSOperation op, *WSMessage msg, bool request, bool soap12, auto h, *hash<auto> header, string enc, *hash<auto> nsh, *int xml_opts, *string req_soapaction, *string faultmsg, *hash<auto> http_headers) {
        hash<auto> rv;

        if (request) {
            # make sure that rv stays hash<auto> instead of hash<string, string>
            rv = hash({
                "method": "POST",
            });
        }

        string io = request ? "input" : "output";

        BindingMessageDescription bmd = self{io};

        if (!exists req_soapaction)
            req_soapaction = soapAction;

        MultiPartRelatedMessage mpm;

        rv.body = make_xml(serializeSoapMessage(op, msg, h, header, nsh, request, soap12, \mpm, faultmsg), xml_opts, enc);

        string ct = WSDLLib::getSoapMimeType12(soap12);
        # FIXME: fix multipart message handling
        /*
        if (mpm) {
            mpm.splicePart(rv.body, sprintf("<%s>", (bmd.body.parts ?? keys msg.args).join(" ")), ct);

            rv = mpm.getMsgAndHeaders();
        }
        */

        if (req_soapaction) {
            rv.hdr += {"SOAPAction": req_soapaction};
            if (soap12) {
                ct += sprintf(";action=%s", req_soapaction);
            }
        }

        if (rv.body) {
            if (exists enc) {
                ct += sprintf(";charset=%s", enc);
            }

            rv.hdr."Content-Type" = ct;
        }

        rv.hdr."Accept" = WSDLLib::SoapMimeTypes.join(",");

        rv.hdr += http_headers;

        return rv;
    }

    private:internal hash<auto> serializeSoapMessage(WSOperation op, *WSMessage msg, auto val, *hash<auto> header, *hash<auto> nsh, bool request, bool soap12, reference mpm, *string faultmsg) {
        string io = request ? "input" : "output";
        # setup namespaces for SOAP envelope
        #printf("DEBUG: serializeSoapMessage: io:%s, h: %y, header: %y, soap12:%y\n", io, val, header, soap12);
        # make sure that rh stays hash<auto> instead of hash<string, string>
        hash<auto> rh = hash(soap12 ? WSDL::ENVELOPE_12_NS : WSDL::ENVELOPE_11_NS);
        string soapenvEnvelope = rh.firstKey();
        rh{soapenvEnvelope}."^attributes^" += op.nsc.getOutputNamespaceHash(nsh);

        BindingMessageDescription bmd = self{io};

        # FIXME: implement multipart support
        /*
        if (exists bmd.multipart)
            mpm = new MultiPartRelatedMessage();
        */

        bool fault = exists faultmsg;

        #printf("DEBUG: docstyle: %y fault: %y\n", docstyle, fault);
        #printf("DEBUG: op: %y io: %y op{io}: %s %d %y\n", op.keys(), io, op{io}.type(), op{io}.typeCode(), boolean(op{io}));
        *hash<auto> body;
        if (msg) {
            if (docstyle) {
                bool encoded = bmd.body.encoded;
                # bmd.body.encoded == False = literal encoding
                #printf("parts: %y, args: %y\n", bmd.body.parts, msg.args.keys());
                body = msg.serializeDocument(bmd.body.parts, bmd, mpm, encoded, \val, fault);
            }
            else {
                string mname = (request ? op.output_name : op.input_name) ?? (op.name + (request ? "" : "Response"));
                body = msg.serializeRpc(bmd.body.parts, bmd, mpm, mname, bmd.body.encoded, \val, fault);
            }
            #printf("DEBUG: body: %N\nval: %N\n", body, val);
        }

        if (bmd.hasHeaders()) {
            #printf("DEBUG: %s header: %y\n", io, header);
            #printf("DEBUG: doc: %y bhdr: %N\n", docstyle, (map $1.("message", "part"), bmd.getHeaders()));
            hash<auto> outh;
            foreach BindingMessageHeaderDescription hdr in (bmd.getHeaders()) {
                #printf("DEBUG: hdr: %y (%y)\n", hdr.("encoded", "part"), hdr.msg.args.keys());
                # only style="document" is assumed since headers do not contain parameters.
                *hash<auto> h;
                if (header)
                    h = hdr.msg.serializeDocument(hdr.part, NOTHING, NOTHING, hdr.encoded, \header, False);
                if (!h && val) {
                    # header data provided in val ?
                    h = hdr.msg.serializeDocument(hdr.part, NOTHING, NOTHING, hdr.encoded, \val, False);
                }
                if (h) {
                    remove h."^attributes^".("soapenv:encodingStyle", "xmlns:soapenc");
                    outh += h;
                }
            }
            #printf("DEBUG: outh: %y\n", outh);
            rh{soapenvEnvelope}."soapenv:Header" = outh;
        }
        if (header.typeCode() == NT_HASH && header) {
            if (op.nsc.opt_allow_any_header) {
                rh{soapenvEnvelope}."soapenv:Header" += header;
            }
            else {
                throw SOAP_SERIALIZATION_ERROR, sprintf("%s header data provided for operation %y remains unserialized: %y", io, op.name, header);
            }
        }
        if (val.typeCode() == NT_HASH && val)
            throw SOAP_SERIALIZATION_ERROR, sprintf("%s data provided for operation %y remains unserialized: %y", io, op.name, val);

        if (fault) {
            if (soap12) {
                rh{soapenvEnvelope}."soapenv:Body" = {
                    "soapenv:Fault": {
                        "soapenv:Code": {
                            "soapenv:Value": "soapenv:Sender",
                        },
                        "soapenv:Reason": {
                            "soapenv:Text": faultmsg,
                        },
                    } + (body ? {"soapenv:Detail": body} : NOTHING),
                };
                # optional Node, Role, Detail, see https://www.w3.org/TR/soap12/, 5.4 Fault
            }
            else {
                # soap 1.1
                rh{soapenvEnvelope}."soapenv:Body" = {
                    "soapenv:Fault": {
                        "faultcode": "soapenv:Client",
                        "faultstring": faultmsg,
                    } + (body ? {"detail": body} : NOTHING),
                };
            }
        }
        else {
            if (body) {
                rh{soapenvEnvelope}."soapenv:Body" = body;
            }
        }
        return rh;
    }

    auto deserializeMessageImpl(WSOperation op, hash<auto> o, bool request) {
        #printf("DEBUG: deserializeSoapMessage(%N, %y)\n", o, request);
        string io = request ? "input" : "output";
        WSDL::XsdBase::removeNS2(\o);
        WSDL::XsdBase::removeNS2(\o.Envelope);
        hash<auto> hrv;

        BindingMessageDescription bmd = self{io};

        if (bmd.hasHeaders()) {
            *hash<auto> header = o.Envelope.Header;
            WSDL::XsdBase::removeNS2(\header);

            #printf("DEBUG: Deserialize SOAP headers: %N\n", header);
            foreach BindingMessageHeaderDescription hdr in (bmd.getHeaders()) {
                if (header.hasKey(hdr.msg.getSerializedKey(hdr.part))) {
                    # seems it may appear part name conflict between messages when namespace is stripped
                    hrv{hdr.msg.name} += hdr.msg.deserializeDocument(NOTHING, header, hdr.part);
                }
            }
            #printf("DEBUG: Deserialized SOAP headers: %N\n", hrv);
        }

        *hash<auto> body = o.Envelope.Body;

        if (!op{io}) {
            if (exists body) {
                throw SOAP_DESERIALIZATION_ERROR, sprintf("%s value given for operation %y binding %y with no %s message: %y", request ? "request" : "response", op.name, name, io, body);
            }
        }
        else if (!exists body)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("no %s body value given for operation %y binding %y", request ? "request" : "response", op.name, name);

        *WSMessage msg = op{io};

        auto rv;
        if (exists body) {
            (*hash<auto> mrh, hash<auto> msgh) = processMultiRef(body);

            if (!request) {
                # check for Soap Fault, if so raise an exception immediately with the fault info
                WSDL::XsdBase::removeNS2(\body);

                if (body.Fault) {
                    WSDL::XsdBase::removeNS(\body.Fault);
                    delete body.Fault.".ns";
                    if (op.nsc.hasSoap12()) {
                        WSDL::XsdBase::removeNS(\body.Fault.Code);
                        WSDL::XsdBase::removeNS(\body.Fault.Reason);
                        # remove extraneous "ns" keys
                        remove body.Fault.Code.ns;
                        remove body.Fault.Reason.ns;
                        string desc = sprintf("The following fault response was received from the server: code: %y", body.Fault.Code.Value);
                        auto sc = body.Fault.Code.Subcode;
                        while (exists sc) {
                            WSDL::XsdBase::removeNS(\sc);
                            # remove extraneous "ns" keys
                            remove sc.ns;
                            desc += sprintf(", subcode: %y", sc.Value);
                            sc = sc.Subcode;
                        }
                        foreach auto rn in (body.Fault.Reason.Text) {
                            desc += sprintf(", text: %y", rn);
                        }

                        throw "SOAP-SERVER-FAULT-RESPONSE", desc, body.Fault;
                    }
                    else {
                        string desc = sprintf("The following fault response was received from the server: code: %y", body.Fault.faultcode);
                        if (exists body.Fault.faultstring)
                            desc += sprintf(", faultstring: %y", body.Fault.faultstring);
                        if (exists body.Fault.desc)
                            desc += sprintf(", desc: %y", body.Fault.desc);

                        throw "SOAP-SERVER-FAULT-RESPONSE", desc, body.Fault;
                    }
                }
            }

            #any ns = msgh.".ns";
            msgh -= ("ns", ".ns");
            if (docstyle) {
                rv = msg.deserializeDocument(mrh, msgh);
            } else {
                string mname = (request ? op.output_name : op.input_name) ?? (op.name + (request ? "" : "Response"));
                if (!msgh{mname})
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("missing %s message name %y as top-level element; got elements: %y", io, mname, keys msgh);
                msgh = remove msgh{mname};
                XsdBase::removeNS2(\msgh);
                msgh -= (".ns", "ns");

                rv = msg.deserializeRpc(mrh, msgh);
            }
        }

        if (exists hrv) {
            # for backwards compatibility with a flat hash when there was only argument
            # but we must be care of when the argument is a type (not element)
            if (rv.size() == 1 && rv.typeCode() == NT_HASH && !exists hrv{rv.firstKey()} ) {
                rv = rv.firstValue();
            } else {
                foreach string k in (keys hrv) {
                    if (exists rv{k}) {
                        # name conflict
                        rv{msg.name} = rv;
                        break;
                    }
                }
            }
            rv += hrv;
        } else if (exists rv ) {
            # for backwards compatibility with a flat hash when there was only argument
            # but we must be care of when the argument is a type (not element)
            if (rv.size() == 1 && rv.typeCode() == NT_HASH) {
                rv = rv.firstValue();
            }
        }

        return rv;
    }

    #! processes multi-part references and returns a hash of multi-part reference info and the updated message body hash
    private:internal static list<auto> processMultiRef(hash<auto> body) {
        # setup message info hash and multiRef lookup hash key, if any are present
        hash<auto> mrh = {
            # save original msg body hash
            "body": body,
        };
        # remove namespace prefixes from body element keys
        WSDL::XsdBase::removeNS2(\mrh.body);

        if (body.multiRef) {
            foreach auto mr in (body.multiRef)
                mrh.mrh.(mr."^attributes^".id) = mr;

            # resolve interior references to multiRefs
            foreach string id in (keys mrh.mrh) {
                foreach string key in (keys mrh.mrh{id}) {
                    if (key == "^attributes^")
                        continue;

                    #printf("multiRef id: %y key: %y val: %y\n", id, key, mrh.mrh{id}{key});

                    if (mrh.mrh{id}{key}.typeCode() == NT_LIST) {
                        foreach auto e in (\mrh.mrh{id}{key}) {
                            auto href = substr(e."^attributes^".href, 1);
                            if (exists href) {
                                if (!exists mrh.mrh{href})
                                    throw "INVALID-MULTIREF", sprintf("multiRef id: %y does not exist", href);
                                e = mrh.mrh{href};
                            }
                        }
                    }
                    else if (mrh.mrh{id}{key}.typeCode() == NT_HASH) {
                        auto href = substr(mrh.mrh{id}{key}."^attributes^".href, 1);
                        if (exists href) {
                            if (!exists mrh.mrh{href})
                                throw "INVALID-MULTIREF", sprintf("multiRef id: %y does not exist", href);
                            mrh.mrh{id}{key} = mrh.mrh{href};
                        }
                    }
                }
            }

            delete body.multiRef;
        }
        #printf("mrh: %y\n", mrh.mrh);
        #printf("operation: %y\n", self);

        # remove namespace tags from element names
        WSDL::XsdBase::removeNS2(\body);
        remove body.".ns";

        return (mrh, body);
    }

    hash<auto> deserializeRequestPathImpl(WSOperation op, string path) {
        throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize URI request path %y for SOAP binding %y", path, name);
    }
}

public class WSDL::HttpBinding inherits WSDL::OperationalBinding {
    public {
        string httpMethod;
        string location;
    }

    constructor(string name, string ns, bool docstyle, string httpMethod, string location, *string soapAction, *WSDL::BindingMessageDescription input, *WSDL::BindingMessageDescription output) : OperationalBinding(name, ns, docstyle, soapAction, input, output) {
        self.httpMethod = httpMethod;
        self.location = location;
    }

    hash<auto> serializeMessageImpl(WSOperation op, *WSMessage msg, bool request, bool soap12, auto h, *hash<auto> header, string enc, *hash<auto> nsh, *int xml_opts, *string req_soapaction, *string faultmsg, *hash<auto> http_headers) {
        hash<auto> rv;

        if (request) {
            # make sure that rv stays hash<auto> instead of hash<string, string>
            rv = hash({
                "path": serializeRequestPath(op, h),
                "method": httpMethod,
            });
        }

        string io = request ? "input" : "output";

        string ct;

        BindingMessageDescription bmd = self{io};

        if (!msg && (bmd.content || bmd.mimeXml))
            throw SOAP_SERIALIZATION_ERROR, sprintf("%s value given for operation %y with no %s message: %y", request ? "request" : "response", name, io, h);

        if (bmd.content.formUrlEncoded) {
            ct = MimeTypeFormUrlEncoded;
            # application/x-www-form-urlencoded Content-Type does not have any parameters
            delete enc;
            # TODO: throws exception when character is > 127, discussed e.g. https://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm
            rv.body = mime_get_form_urlencoded_string(msg.serializeAllPartData(h));
        } else if (bmd.content) {
            hash<auto> v = msg.serializeData(op.nsc, bmd.content.part, h);
            if (v."content-type") {
                if (!bmd.content.acceptAllContentTypes) {
                    WsdlLibPriv::checkContentType(v."content-type", bmd.content.acceptedContentTypeSubtypes + bmd.content.acceptedContentTypes);
                }
                ct = v."content-type";
            } else {
                if (bmd.content.acceptAllContentTypes || bmd.content.acceptedContentTypes || bmd.content.acceptedContentTypeSubtypes.size() != 1) {
                    throw SOAP_SERIALIZATION_ERROR, sprintf("ambiguous content type in message %y related to %s operation %y", msg.name, io, op.name);
                }
                ct = bmd.content.acceptedContentTypeSubtypes[0];
            }
            if (v.value.typeCode() == NT_BINARY) {
                delete enc;
                rv.body = v.value;
            } else {
                rv.body = convert_encoding(v.value, enc);
            }
        } else if (bmd.mimeXml) {
            ct = MimeTypeXml;
            # in case of mimeXml is body content, i.e. XML tag based on element/type name, not part
            string ons;
            hash<auto> hh;
            hh{msg.getSerializedKey(bmd.mimeXml.part)} = msg.serializeRpcValue(bmd.mimeXml.part, False, \h, \ons);
            rv.body = make_xml(hh);
        }

        # add request headers if necessary
        if (request) {
            if (output.content) {
                if (output.content.acceptAllContentTypes) {
                    rv.accept = "*/*";
                } else {
                    softlist<auto> l = output.content.acceptedContentTypeSubtypes;
                    map l += $1 + "*", output.content.acceptedContentTypes;
                    rv.accept = foldl $1 + "," + $2, l;
                }
            } else if (output.mimeXml) {
                rv.accept = MimeTypeXml;
            }
        }

        if (exists rv.body && exists ct) {
            if (exists enc) {
                ct += sprintf(";charset=%s", enc);
            }
            rv.hdr."Content-Type" = ct;
        }

        if (rv.accept) {
            rv.hdr."Accept" = rv.accept;
        }

        rv.hdr += http_headers;

        return rv;
    }

    #! serializes path part of URL when urlEncoded WSDL is defined
    private:internal string serializeRequestPath(WSOperation op, auto h) {
        string path = location;
        if (input.urlReplacement) {
            path = "";
            foreach string k in (keys input.urlReplacement) {
                if (k =~ /^string/) {
                    path += input.urlReplacement{k};
                } else if (k =~ /^part/) {
                    if (!op.input) {
                        throw SOAP_SERIALIZATION_ERROR, sprintf("url replacement requested for operation %s with no message (%y)", op.name, h);
                    }
                    hash<auto> v = op.input.serializeData(op.nsc, input.urlReplacement{k}, h);
                    path += encode_url(string(v.value), True);
                }
            }
        } else if (input.urlEncoded) {
            string s = mime_get_form_urlencoded_string(op.input.serializeAllPartData(h));
            if (s) {
                path += location =~ /\?/ ? "&" : "?";
                path += s;
            }
        }

        return path;
    }

    auto deserializeMessageImpl(WSOperation op, hash<auto> v, bool request) {
        string io = request ? "input" : "output";

        BindingMessageDescription bmd = self{io};

        *string ct = v."content-type";
        if (!exists ct && !bmd.mimeXml) {
            throw SOAP_DESERIALIZATION_ERROR, sprintf("missing content-type in input hash: %y", v);
        }

        if (bmd.urlEncoded || bmd.urlReplacement) {
            # is should be processed via deserializeUrl()
            throw SOAP_DESERIALIZATION_ERROR, sprintf("urlencoded message deserialization is not supported in binding: %y", name);
        }

        if (!op{io} && (bmd.content || bmd.mimeXml))
            throw SOAP_DESERIALIZATION_ERROR, sprintf("%s value given for operation %y with no %s message: %y", request ? "request" : "response", name, io, v);

        *WSMessage msg = op{io};

        if (bmd.content.formUrlEncoded) {
            WsdlLibPriv::checkContentType(ct, list(MimeTypeFormUrlEncoded));
            if (v.body.typeCode() == NT_BINARY) {
                v.body = binary_to_string(v.body);
            }
            hash<auto> h = mime_parse_form_urlencoded_string(v.body); # TODO: data have no encoding
            return msg.deserializeAllPartData(h);
        }

        if (bmd.content) {
            if (!bmd.content.acceptAllContentTypes) {
                WsdlLibPriv::checkContentType(ct, bmd.content.acceptedContentTypeSubtypes + bmd.content.acceptedContentTypes);
            }
            hash<auto> v2;
            v2{bmd.content.part} = v.body;
            hash<auto> h = msg.deserializeData(bmd.content.part, v2);
            string k = h.firstKey();
            h{k}."^value^" = remove h{k};
            h{k}."^attributes^"."^content-type^" = ct;
            return h;
        }

        if (bmd.mimeXml) {
            *hash<auto> h = msg.deserializeData(bmd.mimeXml.part, v);
            return h;
        }
    }

    hash<auto> deserializeRequestPathImpl(WSOperation op, string path) {
        if (input.urlReplacement) {
            # all parameters are somehow encoded in path
            throw SOAP_DESERIALIZATION_ERROR, sprintf("url replacement message deserialization is not supported in binding %y", name);
        }
        if (input.urlEncoded) {
            hash<auto> h;
            if (index(path, "?") >= 0) {
                # any params ?
                int i = index(path, location);
                if (i >= 0) {
                    # strip potential prefix in URL params
                    path = substr(path, i + location.size());
                }
                # all parameters are in URL
                i = index(path, "?");
                if (i >= 0) {
                    path = substr(path, i+1);
                }
                i = 0;
                while (path[i] == "&") {
                    i++;
                }
                if (i) {
                    path = substr(path, i);
                }
                if (path != "") {
                    h = mime_parse_form_urlencoded_string(path);
                    return op.input.deserializeAllPartData(h);
                }
            }
            return {};
        }
        throw SOAP_DESERIALIZATION_ERROR, sprintf("BUG: cannot deserialize URI request path %y for HTTP binding %y", path, name);
    }
}

#! describes the message body for a SOAP operational binding message description
/** @see https://www.w3.org/TR/wsdl#_soap:body
*/
public class WSDL::BindingMessageBodyDescription {
    public {
        #! required attribute
        /** if @ref Qore::True "True", then use = \c "encoded" (each message part references an abstract type using the \c type attribute),
            otherwise use = \c "literal" (each part references a concrete schema definition using either the \c element or \c type attribute)
         */
        bool encoded;

        #! when encoded @ref Qore::True "True", this is used to produce a concrete message by applying the specified encoding
        *string encodingStyle;

        #! namespace; "only applies to content not explicitly defined by the abstract types"
        *string ns;

        #! indicates which parts appear somewhere within the SOAP Body portion of the message
        *list<auto> parts;
    }

    constructor(bool encoded, *string encodingStyle, *string ns, *string parts) {
        self.encoded = encoded;
        self.encodingStyle = encodingStyle;
        self.ns = ns;
        # get a list of strings ignoring whitespace
        if (parts.val())
            self.parts = select (map trim($1), parts.split(" ")), $1.val();
    }

    bool isMultipart() {
        return False;
    }
}

#! describes a SOAP message header for a SOAP operational binding message description
public class WSDL::BindingMessageHeaderDescription {
    public {
        #! message part name
        string part;

        #! required attribute
        /** if @ref Qore::True "True", then use = \c "encoded" (each message part references an abstract type using the \c type attribute),
            otherwise use = \c "literal" (each part references a concrete schema definition using either the \c element or \c type attribute)
            */
        bool encoded;

        #! a weak reference to the actual message
        WSMessage msg;
    }

    #! creates the object
    /*
        @param part message part name
        @param encoded if @ref Qore::True "True", then use = \c "encoded" (each message part references an abstract type using the \c type attribute), otherwise use = \c "literal" (each part references a concrete schema definition using either the \c element or \c type attribute)
        @param msg actual message
    */
    constructor(string part, bool encoded = False, WSMessage msg) {
        self.part = part;
        self.encoded = encoded;
        self.msg := msg;
    }
}

#! describes MIME content information for SOAP operational binding message descriptions
/** @see https://www.w3.org/TR/wsdl#_mime:content
 */
public class WSDL::BindingContentDescription {
    public {
        #! specifies the name of the message part
        string part;

        # list of accepted content types (with "xxx/*")
        list<auto> acceptedContentTypes = ();

        # list of accepted specific content types
        list<auto> acceptedContentTypeSubtypes = ();

        #! are all content-types form URL encoded?
        bool formUrlEncoded = False;

        #! are all content-types accepted?
        bool acceptAllContentTypes = False;
    }

    addContentType(string type) {
        bool isFormUrlEncoded = (type == MimeTypeFormUrlEncoded);
        if (isFormUrlEncoded && (acceptedContentTypes || acceptedContentTypeSubtypes))
            throw WSDL_ERROR, sprintf("%y content type cannot be declared with other content-types: %y", MimeTypeFormUrlEncoded, (acceptedContentTypes + acceptedContentTypeSubtypes));
        if (!isFormUrlEncoded && formUrlEncoded)
            throw WSDL_ERROR, sprintf("%y content type cannot be declared in conjunction with the %y content-type (this last type cannot be mixed with other types)", type, MimeTypeFormUrlEncoded);
        if (isFormUrlEncoded && !formUrlEncoded)
            formUrlEncoded = True;

        if (!type || type == "*/*") {
            acceptAllContentTypes = True;
            return;
        }

        hash<auto> act;

        list<auto> st = type.split("/");
        if (st.size() != 2)
            throw WSDL_ERROR, sprintf("Content type %y does not match 'type/subtype' pattern", type);
        if (bindex(st[0], "*") != -1)
            throw WSDL_ERROR, sprintf("Content type %y contains unexpected asterisk in type part", type);

        act.type = st[0];

        # check for a wildcard
        if (st[1] == "*") {
            acceptedContentTypes += (st[0] + "/");
            return;
        }

        if (bindex(st[1], "*") != -1) {
            throw WSDL_ERROR, sprintf("Content type %y contains unexpected asterisk in subtype part", type);
        }

        acceptedContentTypeSubtypes += (st[0] + "/" + st[1]);
    }
}

#! describes a mimeXml payload for a SOAP operational binding message description
/** @see https://www.w3.org/TR/wsdl#_mime:mimeXml
 */
public class WSDL::MimeXmlMessageDescription {
    public {
        #! refers to a message part defining the concrete schema of the root XML element
        /** The part references a concrete schema using the element attribute for simple parts or type attribute for composite parts
         */
        string part;
    }

    constructor(string part) {
        self.part = part;
    }
}

#! describes an input or output message in a SOAP operational binding
public class WSDL::BindingMessageDescription {
    public {
        #! the description of the message body
        *WSDL::BindingMessageBodyDescription body;

        #! a hash of URL replacement values keyed by part name, values are URI paths
        /** @note for HTTP bindings only
         */
        *hash<auto> urlReplacement;

        #! indicates that all the message parts are encoded into the HTTP request URI using the standard URI-encoding rules
        /** ex: name1=value&name2=value...

            The names of the parameters correspond to the names of the message parts.
            Each value contributed by the part is encoded using a name=value pair.
            This may be used with GET to specify URL encoding, or with POST to specify a FORM-POST.
            For GET, the "?" character is automatically appended as necessary.

            @note for HTTP bindings only

            @see https://www.w3.org/TR/wsdl#_http:urlEncoded
         */
        bool urlEncoded = False;

        #! optional content-type descriptions
        *WSDL::BindingContentDescription content;

        #! optional mimeXml message scription
        *WSDL::MimeXmlMessageDescription mimeXml;
    }

    private:internal {
        #! a list of WSDL::BindingMessageHeaderDescription objects
        list<BindingMessageHeaderDescription> headers = cast<list<BindingMessageHeaderDescription>>(());
    }

    addHeader(BindingMessageHeaderDescription hdr) {
        headers += hdr;
    }

    #! returns @ref Qore::True "True" if the header descriptions are available
    bool hasHeaders() {
        return !headers.empty();
    }

    #! returns a list of WSDL::BindingMessageHeaderDescription objects
    list<BindingMessageHeaderDescription> getHeaders() {
        return headers;
    }

    setUrlReplacement(string loc) {
        int i = 0;
        while (i < loc.size()) {
            int j = index(loc, "(", i);
            if (j < 0) {
                j = loc.size();
            }
            if (j > i) {
                urlReplacement{sprintf("string^%d", urlReplacement.size() + 1)} = substr(loc, i, j - i);
            }
            if (j < loc.size()) {
                i = j + 1;
                j = index(loc, ")", i);
                if (j == i) {
                    throw WSDL_ERROR, sprintf("empty replace token in %y near %y", loc, substr(loc, i-1, loc.size()));
                } else if (j < 0) {
                    throw WSDL_ERROR, sprintf("missing close parentheses in %y near %y", loc, substr(loc, i-1, loc.size()));
                }
                string p = substr(loc, i, j-i);
                # if (messages)   TODO test messages / part here probably not ?
                urlReplacement{sprintf("part^%d", urlReplacement.size() + 1)} = p;
                ++j;
            }
            i = j;
        }
    }
}

#! class for WSDL bindings
public class WSDL::Binding inherits WSDL::XsdNamedData {
    private:internal {
        string port;

        #! use RPC or document style
        /** according to https://www.w3.org/TR/wsdl#_soap:operation
            'If the soap:binding element does not specify a style, it is assumed to be "document".'
         */
        bool docstyle = True;

        *string httpMethod;
        *string soapTransport;
    }

    constructor(hash<auto> data, Namespaces nsc, reference portTypes, reference idocmap, *hash<auto> messages) : XsdNamedData(\data) {
        # get binding attributes
        {
            *hash<auto> ba = data."^attributes^";

            (*string ns, *string prt) = ba.type =~ x/(?:([^:]+):)?([^:]+)/;
            if (!prt)
                throw WSDL_ERROR, sprintf("missing port type for binding %y", name);
            port = prt;
        }

        if (data.binding) {
            *hash<auto> bba = data.binding."^attributes^";
            if (bba.verb) {
                # HTTP binding
                httpMethod = bba.verb;
            }

            if (bba.transport) {
                # SOAP binding
                if (!SOAP_TRANSPORT.(bba.transport))
                    throw WSDL_ERROR, sprintf("unsupported transport %y in binding %y (known transports: %y)", bba.transport, name, SOAP_TRANSPORT.keys());
                soapTransport = bba.transport;
            }
            if (!soapTransport && !httpMethod)
                throw WSDL_ERROR, sprintf("missing SOAP verb or transport in binding %y (known SOAP transports: %y)", name, SOAP_TRANSPORT.keys());

            if (exists bba.style) {
                *bool ds = SoapStyleMap{bba.style};
                if (!exists ds)
                    throw WSDL_ERROR, sprintf("invalid '\"style\" attribute %y in binding %y; expected one of: %y", bba.style, name, SoapStyleMap.keys());
                if (!ds)
                    docstyle = False;
            }

            hash<string, string> nsh;
            # issue #2858: add any XML namespaces to namespace object here
            foreach hash<auto> h in (bba.pairIterator()) {
                if (h.key =~ /^xmlns:/) {
                    nsh{h.key} = h.value;
                }
            }
            if (nsh) {
                nsc.addNamespaces(nsh);
            }
        }

        foreach hash<auto> ophash in (data.operation) {
            string opname = ophash."^attributes^".name;
            if (!exists portTypes{port}.operations{opname})
                throw WSDL_ERROR, sprintf("binding %y references unknown porttype %y operation %y", name, port, opname);

            WSDL::XsdBase::removeNS(\ophash);

            bool b_docstyle = docstyle;

            *hash<auto> opah = ophash.operation."^attributes^";
            *string soapAction = opah.soapAction;
            if (!exists soapAction) {
                *string op_ns = portTypes{port}.operations{opname}.nsc.getTargetNamespaceUri();
                if (op_ns && op_ns !~ /\/$/)
                    op_ns += "/";
                soapAction = op_ns ? op_ns + opname : opname;
            }

            {
                *string style = opah.style;
                if (exists style) {
                    *bool ds = SoapStyleMap{style};
                    if (!exists ds)
                        throw WSDL_ERROR, sprintf("invalid '\"style\" attribute %y in binding %y operation %y; expected one of: %y", style, name, opname, SoapStyleMap.keys());
                    b_docstyle = ds;
                }
            }

            if (b_docstyle)
                portTypes{port}.operations{opname}.setDocStyleBinding(\idocmap);
            else
                portTypes{port}.operations{opname}.markRpcStyleBinding();

            *string location;

            if (httpMethod) {
                location = ophash.operation."^attributes^".location;
                if (!location) {
                    throw WSDL_ERROR, sprintf("location is missing binding %y, operation %y", name, opname);
                }
            }

            # input/output hash
            hash<auto> ioh;
            hash<auto> op = remove ophash{"input", "output"};

            foreach string io in (keys op) {
                WSDL::XsdBase::removeNS(\op{io});
                if (!exists portTypes{port}.operations{opname}{io}) {
                    *hash<auto> hk = map {$1: True}, keys op{io};
                    remove hk.("header", "ns");
                    if (hk)
                        throw WSDL_ERROR, sprintf("binding %y for operation %y does not reference %s message in porttype %y",  name, opname, io, port);
                }

                BindingMessageDescription bmd();

                if (exists op{io}.body) {
                    hash<auto> bh = remove op{io}.body;
                    *hash<auto> pa = bh."^attributes^";

                    *bool encoded = SoapUseMap{pa.use};
                    if (!exists encoded)
                        throw WSDL_ERROR, sprintf("binding %y for operation %y for the %s message has an invalid 'use' attribute: %y", name, opname, io, pa.use);

                    bmd.body = new BindingMessageBodyDescription(encoded, pa.encodingStyle, pa."namespace", pa.parts);
                }

                if (exists op{io}.multipartRelated) {
                    if (bmd.body)
                        throw WSDL_ERROR, sprintf("%s binding %y for operation %y specifies both body and multipart elements", io, name, opname);

                    throw WSDL_ERROR, "unsupported multipartRelated";

                    /*
                    ioh{io}.multipart = Mime::MPT_RELATED;
                    ioh{io}.parts = {};
                    WSDL::XsdBase::removeNS(\op{io}.multipartRelated);

                    if (!exists op{io}.multipartRelated.part)  # TODO: do I need explicite check or is handled by validator ?
                        throw WSDL_ERROR, sprintf("binding %y is missing part definition(s) in %s message definition for operation %y: %y", name, io, opname, op);

                    foreach any part in (op{io}.multipartRelated.part) {
                        WSDL::XsdBase::removeNS(\part);
                        #any a = part."^attributes^";
                        part -= "^attributes^";
                        if (exists part.body) {
                            if (exists op{io}.body)
                                throw WSDL_ERROR, sprintf("%s binding %y for operation %y specifies multiple body parts in multipart elements", io, name, opname);
                            any pa = part.body."^attributes^";
                            if (pa.use != "literal")
                                throw WSDL_ERROR, sprintf("unsupported body part without use=\"literal\": %y", part.body);

                            ioh{io}.body.parts = pa.parts;
                        } else if (exists part.content) {
                            *string pcname;
                            foreach any c in (part.content) {
                                WSDL::XsdBase::removeNS(\c);
                                any pa = c."^attributes^";
                                any name = pa.part;
                                if (!exists name)
                                    throw WSDL_ERROR, sprintf("unsupported content part without part attribute: %y", c);
                                if (pcname) {
                                    if (pcname != name)
                                        throw WSDL_ERROR, sprintf("multiple content part names inside part section: %y!=%y", name, pcname);
                                } else {
                                    pcname = name;
                                    name = portTypes{port}.operations{opname}{io}.checkPart(name);
                                }
                                any type = pa.type;
                                if (!exists type)
                                    throw WSDL_ERROR, sprintf("unsupported content part without type attribute: %y", c);

                                if (!exists op{io}.parts{name})
                                    ioh{io}.parts{name} = type;
                                else {
                                    if (op{io}.parts{name}.typeCode() != NT_LIST)
                                        ioh{io}.parts{name} = list(op{io}.parts{name});
                                    ioh{io}.parts{name} += type;
                                }
                            }
                        } else
                            throw WSDL_ERROR, sprintf("cannot parse part: %y", part);

                        #printf("DEBUG: part: %y\nmsg: %y\n", part, op{io});;
                    }
                    delete op{io}.multipartRelated;
                    */
                }

                if (exists op{io}.header) {
                    foreach hash<auto> hdr in (op{io}.header) {
                        *hash<auto> ma = hdr."^attributes^";

                        if (!ma.message)
                            throw WSDL_ERROR, sprintf("%s binding %y for operation %y specifies a soap header element without a 'message' attribute (attr: %y)", io, name, opname, ma);

                        hash<auto> h = nsc.getTypeHash(ma.message);
                        *WSMessage msg = messages.(h.val);
                        if (!msg)
                            throw WSDL_ERROR, sprintf("%s binding %y for operation %y references unknown message %y in the soap header element", io, name, opname, h.val);

                        string part = checkMessagePart(msg, ma.part, sprintf("header %s operation %y", io, opname));

                        *bool encoded = SoapUseMap{ma.use};
                        if (!exists encoded)
                            throw WSDL_ERROR, sprintf("binding %y for operation %y for the %y header of the %s message has an invalid 'use' attribute: %y", name, opname, ma.part, io, ma.use);

                        #printf("DEBUG: match part to message: %y, part: %y\n", msg.name, part);
                        bmd.addHeader(new BindingMessageHeaderDescription(part, encoded, msg));
                    }
                    delete op{io}.header;
                }

                if (op{io}.hasKey("urlReplacement")) {
                    if (!location)
                        throw WSDL_ERROR, sprintf("%s binding %y for operation %y has a 'urlReplacement' element but does not use HTTP binding", io, name, opname);

                    bmd.setUrlReplacement(location);
                    delete op{io}.urlReplacement;
                }

                if (op{io}.hasKey("urlEncoded")) {
                    if (!location)
                        throw WSDL_ERROR, sprintf("%s binding %y for operation %y has a 'urlEncoded' element but does not use HTTP binding", io, name, opname);

                    bmd.urlEncoded = True;
                    delete op{io}.urlEncoded;
                }

                if (exists op{io}.content) {
                    BindingContentDescription bcd();

                    foreach auto cnt in (op{io}.content) {
                        WSDL::XsdBase::removeNS(\cnt);
                        cnt = remove cnt."^attributes^";

                        bcd.addContentType(cnt.type);

                        if (bcd.formUrlEncoded)
                            continue;

                        string part = checkMessagePart(portTypes{port}.operations{opname}{io}, cnt.part, sprintf("content %s operation %y", io, opname));
                        if (exists bcd.part) {
                            if (bcd.part != part) {
                                throw WSDL_ERROR, sprintf("ambiguous part %y in message %y in binding %y for %s operation %y", part, portTypes{port}.operations{opname}{io}.name, name, io, opname);
                            }
                        } else {
                            bcd.part = part;
                        }
                    }

                    bmd.content = bcd;
                    delete op{io}.content;
                }

                if (op{io}.hasKey("mimeXml")) {
                    string part = checkMessagePart(portTypes{port}.operations{opname}{io}, ioh{io}.mimeXml."^attributes^".part, sprintf("%s operation %y", io, opname));
                    bmd.mimeXml = new MimeXmlMessageDescription(part);
                    delete op{io}.mimeXml;
                }

                delete op{io}.("^attributes^", "ns");

                if (op{io}) {
                    throw WSDL_ERROR, sprintf("unknown element(s) in binding %y for %s operation %y: %y", name, io, opname, keys op{io});
                }

                ioh{io} = bmd;
            }

            if (ioh.output.content.formUrlEncoded) {
                throw WSDL_ERROR, sprintf("%y type is not supported as output type in binding %y for output operation %y", MimeTypeFormUrlEncoded, name, opname);
            }

            OperationalBinding b = soapTransport
                ? new SoapBinding(name, ophash.ns ?? "", b_docstyle, soapTransport, soapAction, ioh.input, ioh.output)
                : new HttpBinding(name, ophash.ns ?? "", b_docstyle, httpMethod, location, soapAction, ioh.input, ioh.output);

            portTypes{port}.operations{opname}.addBinding(b);
        }

        #binding = data;
    }

    #! check if part exists in massage, if part is empty and message contains single part then return it otherwise raise an exception
    private:internal string checkMessagePart(WSMessage msg, *string partname, string errs) {
        if (exists partname) {
            msg.checkPart(partname);
            return partname;
        }
        if (msg.pmap.size() == 1) {  # some args may be defined without part name so use pmap to test
            return msg.pmap.firstKey();
        } else {
            throw WSDL_ERROR, sprintf("message %y must have exactly one part to resolve the part name with binding %y: %s (parts: %y args: %y)", msg.name, name, errs, keys msg.pmap, keys msg.args);
        }
    }

    string getPort() {
        return port;
    }

    bool isSoapBinding() {
        return exists soapTransport;
    }

    bool isHttpBinding() {
        return exists httpMethod;
    }
}

# private namespace prefix redefinition class
class WSDL::NamespacePrefixHelper {
    public {
    }

    private {
        #! namespaces data
        Namespaces nsc;

        # overriden prefixes
        hash<auto> h;

        # overridden target namespace
        bool targ_ns;

        # overridden default namespace
        bool def_ns;
    }

    constructor(Namespaces nsc, *hash<auto> nsattr) {
        self.nsc := nsc;

        if (nsattr) {
            nsc.addNamespaces(nsattr, self);
            if (nsattr.targetNamespace) {
                nsc.pushTargetNamespace(nsattr.targetNamespace);
                targ_ns = True;
            }
            if (nsattr.xmlns) {
                nsc.pushDefaultNamespace(nsattr.xmlns);
                def_ns = True;
            }
        }
    }

    destructor() {
        if (def_ns)
            nsc.popDefaultNamespace();
        if (targ_ns)
            nsc.popTargetNamespace();
        if (h)
            nsc.restorePrefixes(h);
    }

    save(string k, string v) {
        h{k} = v;
    }
}

#! namespace container class
public class WSDL::Namespaces {
    public {
        # options are here since this object is passed through all serialization and deserialization
        bool opt_empty_string_is_nothing = False;
        bool opt_allow_any_header = False;
    }

    private {
        #! maps output namespace prefixes to namespace URIs
        hash<string, string> ns = {
            "xsd": XSD_NS,
        };

        #! maps namespace URIs to output namespace prefixes
        hash<string, string> nsr = {
            XSD_NS: "xsd",
        };

        #! hash for valid XSD namespaces, maps input namespace prefixes -> True if it refers to an XSD schema
        hash<string, bool> xsd_schema = {
            "xsd": True,
        };

        #! hash mapping input namespace prefixes to namespaces URIs
        hash<string, string> imap = {
            "xsd": XSD_NS,
        };

        #! hash mapping input namespace URIs to input namespace prefixes
        hash<string, string> imapr = {
            XSD_NS: "xsd",
        };

        #! integer providing a sequence for output namespace prefixes
        int nsn;

        #! if True then has SOAP 1.1
        bool hassoap11 = False;

        #! if True then has SOAP 1.2
        bool hassoap12 = False;

        #! current target namespace
        *string target_ns;

        #! target namespace stack;
        list<auto> nss = ();

        #! default namespace for unprefixed definitions
        *string default_ns;

        #! default namespace stack;
        list<auto> dss = ();

        #! base type map
        hash<string, XsdBaseType> base_types;
    }

    #! creates the object with the WSDL definitions attribute hash
    constructor(hash<auto> nsh, *Namespaces nsc) {
        nsn = nsc ? nsc.nsn : 1;

        if (nsh.targetNamespace)
            target_ns = nsh.targetNamespace;

        # set default namespace for unprefixed definitions
        if (nsh.xmlns)
            default_ns = nsh.xmlns;

        #printf("*** DEBUG: Namespaces::constructor() nsh: %y imap: %y\n", nsh, imap);
        addNamespaces(nsh);

        base_types += nsc.base_types;
        #printf("*** DEBUG: Namespaces::constructor() imap: %y\n", imap);
    }

    *string getDefaultNs() {
        return default_ns;
    }

    addNamespaces(hash<auto> nsh, *NamespacePrefixHelper nph) {
        foreach string k in (keys nsh) {
            *string ns = (k =~ x/xmlns:([^:]+)/)[0];

            if (!ns)
                continue;

            if (imap{ns}) {
                # ignore if the definition is the same
                if (imap{ns} == nsh{k})
                    continue;

                if (nph) {
                    string ov = imap{ns};
                    if (imapr{ov} == target_ns)
                        remove imapr{ov};
                    if (nsh{ns} == XSD_NS)
                        remove xsd_schema{ns};
                    nph.save(ns, ov);
                }
                else
                    throw "WSDL-NAMESPACE-ERROR", sprintf("namespace prefix %y defined twice", ns);
            }
            addNamespaceIntern(ns, nsh{k});
        }
    }

    restorePrefixes(hash<auto> h) {
        map addNamespaceIntern($1.key, $1.value, True), h.pairIterator();
    }

    private addNamespaceIntern(string ns, string val, *bool override) {
        imap{ns} = val;

        if (override || !imapr{val})
            imapr{val} = ns;

        if (val == XSD_NS)
            xsd_schema{ns} = True;

        if (!hassoap11 && val == SOAP_11_NS)
            hassoap11 = True;

        if (!hassoap12 && val == SOAP_12_NS)
            hassoap12 = True;
    }

    #! merges namespaces when parsing imported schemas
    merge(Namespaces nsc) {
        nsn = nsc.nsn;
        foreach string k in (keys nsc.ns) {
            string v = nsc.ns{k};

            if (ns{k}) {
                if (ns{k} == v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", k, v, ns{k});
            }
            if (!nsr{v}) {
                ns{k} = v;
                nsr{v} = k;
            }
        }
        # merge input namespace mappings
        foreach string k in (keys nsc.imap) {
            string v = nsc.imap{k};
            if (imap{k}) {
                if (imap{k} == v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", k, v, imap{k});
            }
            imap{k} = v;
        }

        base_types += nsc.base_types;
    }

    #! returns the namespace URI for the given output namespace prefix
    string getOutputNamespaceUri(string nsp) {
        *string n_ns = ns{nsp};
        if (!n_ns)
            throw "WSDL-NAMESPACE-ERROR", sprintf("output namespace prefix %y is unknown (known output namespace prefixes: %y)", nsp, ns.keys());
        return n_ns;
    }

    #! returns a hash of namespace attributes for outgoing SOAP messages
    *hash<auto> getOutputNamespaceHash(*hash<auto> nsh) {
        hash<auto> h;
        map h.("xmlns:" + $1.key) = $1.value, ns.pairIterator();

        foreach string k in (keys nsh) {
            string xs = "xmlns:" + k;
            if (h{xs}) {
                if (h{xs} != nsh{k})
                    throw "WSDL-NAMESPACE-ERROR", sprintf("namespace %y has already been added automatically as %y and therefore cannot be overridden as %y", k, h{xs}, nsh{k});
            }
            else
                h{xs} = nsh{k};
        }

        return h;
    }

    #! returns the primary target namespace Uri
    *string getTargetNamespaceUri() {
        return target_ns;
    }

    #! returns the namespace URI for the given prefix or the target namespace Uri
    *string getNamespaceUri(*string nsp) {
        if (exists nsp)
            return getInputNamespaceUri(nsp);
        return getTargetNamespaceUri();
    }

    #! pushes the current target namespace URI on the stack when parsing schemas and sets the current target namespace URI to the current value
    pushTargetNamespace(string ns) {
        nss += target_ns;
        target_ns = ns;
    }

    #! restores any previous target namespace URI from the stack to the current target namespace URI
    popTargetNamespace() {
        target_ns = pop nss;
    }

    #! pushes the current default namespace URI on the stack when parsing schemas and sets the current default namespace URI to the current value
    pushDefaultNamespace(string ns) {
        dss += default_ns;
        default_ns = ns;
    }

    #! restores any previous default namespace URI from the stack to the current default namespace URI
    popDefaultNamespace() {
        default_ns = pop dss;
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getOutputNamespacePrefix(string ns) {
        *string nsa = nsr{ns};
        if (nsa)
            return nsa;
        return registerNamespaceIntern(ns);
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getTargetNamespaceInputPrefix() {
        if (!target_ns)
            throw "NAMESPACE-ERROR", sprintf("no target namespace");
        return imapr{target_ns};
    }

    #! registers a namespace internally
    private string registerNamespaceIntern(string n_ns) {
        # create namespace prefix
        string nsa = sprintf("ns%d", nsn++);
        # register namespace in forward and reverse maps
        ns{nsa} = n_ns;
        nsr{n_ns} = nsa;

        return nsa;
    }

    #! returns a hash of namespace prefixes to namespaces URIs actually used
    *hash<auto> getReferencedNamespaceMap() {
        return ns;
    }

    #! returns True if using SOAP 1.1, False if not
    bool hasSoap11() {
        return hassoap11;
    }

    #! returns True if using SOAP 1.2, False if not
    bool hasSoap12() {
        return hassoap12;
    }

    #! returns True if if the input namespace prefix refers to the XSD namespace URI
    *bool isSchema(string ns) {
        return xsd_schema{ns};
    }

    #! returns the input namespace URI from the input namespace prefix
    string getInputNamespaceUri(string nsa) {
        *string rv = imap{nsa};
        if (!rv)
            throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace %y is unknown (known input namespaces: %y)", nsa, imap.keys());
        return rv;
    }

    bool doType(string t, reference<hash> typeinfo, reference<XsdAbstractType> rtype) {
        #printf("DEBUG: XsdBase::doType(%y)\n", t);
        (*string ns, *string type) = t =~ x/([^:]+):([^:]+)/;
        if (!type) {
            #printf("DEBUG: XsdBase::doType(%y) xsd: %y\n", t, default_ns);
            if (default_ns == XSD_NS) {
                rtype = getBaseType(t);
                return True;
            }

            typeinfo = ("val": t);
            return False;
        }

        # if this is in the XML Schema namespace, then it's a base type
        if (xsd_schema{ns}) {
            rtype = getBaseType(type);
            return True;
        }

        typeinfo = ("ns": getOutputNamespacePrefix(getInputNamespaceUri(ns)), "val": type);
        return False;
    }

    hash<auto> getTypeHash(string t) {
        #printf("DEBUG: XsdBase::doType(%y)\n", t);
        (*string ns, *string type) = t =~ x/([^:]+):([^:]+)/;
        if (!type) {
            #printf("DEBUG: XsdBase::doType(%y) xsd: %y\n", t, default_ns);
            return ("val": t);
        }

        return ("ns": getOutputNamespacePrefix(getInputNamespaceUri(ns)), "val": type);
    }

    XsdBaseType getBaseType(string t) {
        if (!base_types{t})
            base_types{t} = new XsdBaseType(t, self);

        XsdBaseType rv := base_types{t};
        return rv;
    }

    #! returns the output namespace prefix for the given input namespace prefix
    string translateOutputNamespacePrefix(*string nsa) {
        return getOutputNamespacePrefix(getInputNamespaceUri(nsa));
    }
}

# private functions
XsdAbstractType sub tmap_get(hash<string, XsdAbstractType> tmap, string name) {
    if (!tmap{name})
        throw WSDL_ERROR, sprintf("no such type %y; known types: %y", name, tmap.keys());
    XsdAbstractType rv := tmap{name};
    return rv;
}

*XsdAbstractType sub tmap_try_get(hash<string, XsdAbstractType> tmap, string name) {
    *XsdAbstractType rv := tmap{name};
    return rv;
}

# private functions
XsdElement sub emap_get(hash<string, hash<string, XsdElement>> emap, string ns, string name) {
    if (!emap{ns})
        throw WSDL_ERROR, sprintf("no such namespace %y; known namespaces: %y", ns, emap.keys());
    if (!emap{ns}{name})
        throw WSDL_ERROR, sprintf("no such element %y in namespace %y; known elements: %y", name, ns, emap{ns}.keys());
    XsdElement rv := emap{ns}{name};
    return rv;
}

*XsdElement sub emap_try_get(hash<string, hash<string, XsdElement>> emap, string ns, string name) {
    *XsdElement rv := emap{ns}{name};
    return rv;
}

#! WSDL port type hash
public hashdecl WSDL::PortTypeInfo {
    hash<string, WSOperation> operations;
}

#! WSDL service info hash
public hashdecl WSDL::ServiceInfo {
    #! service name
    string name;
    #! port info
    hash<string, hash> port;
}

#! WSDL operation info
public hashdecl WSDL::OperationInfo {
    #! the name of the port defining the operation
    string port;

    #! the operation object
    WSDL::WSOperation operation;
}

#! main class representing a parsed WSDL file
/** This is the main class for handling SOAP communication and is based on a WSDL file
*/
public class WSDL::WebService inherits WSDL::XsdBase {
    public {
        #! the WSDL string
        string wsdl;

        #! options used in the constructor
        *hash<auto> opts;

        #! namespace container
        Namespaces nsc;

        #! list of services in this WSDL
        list<string> wsdl_services();

        #! a hash of element names to XsdElement objects for top-level document-style bindings
        hash<string, XsdElement> idocmap();

        #! map of elements
        hash<string, hash<string, XsdElement>> emap();

        #! hash of messages names to messages
        hash<string, WSMessage> messages();

        #! map of types
        hash<string, XsdAbstractType> tmap();

        #! hash of port names to port type information hashes
        hash<string, hash<PortTypeInfo>> portType();

        #! optional closure/call reference to try to resolve import declarations
        *code try_import;

        #! default path for retrieving XSD references
        *string def_path;
    }

    private {
        # service definitions; name -> service info hash
        hash<string, hash<WSDL::ServiceInfo>> services();

        # service bindings; name -> Binding
        hash<string, Binding> binding();
    }

    #! creates the WebService object
    /** @param str the XML string representing the WSDL
        @param opts an optional hash of options with the following possible keys:
        - \c "compat_allow_any_header": allow any SOAP header to be sent without checking the WSDL
        - \c "compat_empty_string_is_nothing": deserialize empty strings to @ref nothing instead of an empty string
        - \c "def_path": the default path to use when retrieving referenced XSDs
        - \c "try_import": a call reference or closure to be passed a string name for XSD imports without any scheme to retrieve the data, must take a string argument (the resource name) and return a string (the resource data)
        - \c "http_client": a HTTPClient object for retrieving data from import commands
        - \c "http_headers": a hash of optional HTTP header info to use when retrieving data from import commands

        @since 0.3.7 added the \c "compat_empty_string_is_nothing" and \c "compat_allow_any_header" options for backwards compatibility
    */
    constructor(string str, *hash<auto> opts) {
        hash<auto> h = parse_xml(str);

        # save WSDL text
        wsdl = str;

        # save options
        self.opts = opts;

        try_import = opts.try_import;
        def_path = opts.def_path;

        # remove namespace (normally "wsdl:") prefix from keys if present
        WSDL::XsdBase::removeNS(\h);
        WSDL::XsdBase::removeNS(\h.definitions);
        nsc = new Namespaces(h.definitions."^attributes^");
        if (opts.compat_empty_string_is_nothing || global_compat_empty_string_is_nothing) {
            nsc.opt_empty_string_is_nothing = True;
        }
        if (opts.compat_allow_any_header || global_compat_allow_any_header) {
            nsc.opt_allow_any_header = True;
        }
        #getNSPrefixes(h.definitions."^attributes^");
        #printf("%y\n", h.definitions.types);

        if (exists h.definitions.types)
            parseTypes(h.definitions.types, opts.http_client instanceof HTTPClient ? opts.http_client : NOTHING, opts.http_headers);

        if (exists h.definitions.message)
            parseMessages(h.definitions.message);

        if (exists h.definitions.portType)
            parsePortType(h.definitions.portType);

        if (exists h.definitions.binding)
            parseBinding(h.definitions.binding);

        if (exists h.definitions.service)
            parseService(h.definitions.service);
    }

    #! allows the WebService to be serialized for sending over the network
    /** @return a hash that can be used in a deserialize() call
    */
    hash<auto> serialize() {
        return self{"wsdl", "opts"};
    }

    #! returns the given operation or throws an exception if it cannot be found; operations are searched in portTypes in the order they are declared
    WSDL::WSOperation getOperation(string opname) {
        foreach hash<auto> pt in (portType.iterator()) {
            if (pt.operations{opname})
                return pt.operations{opname};
        }
        throw "WSDL-OPERATION-ERROR", sprintf("cannot retrieve operation %y; known operations: %y", opname, (foldl $1 + $2, (map $1.operations.keys(), portType.iterator())));
    }

    #! returns a list of known operation names
    softlist<auto> getOperationNames() {
        return foldl $1 + $2, (map keys $1.operations, portType.iterator());
    }

    #! returns the given operation for particular porttype or throws an exception if it cannot be found
    WSDL::WSOperation getPortTypeOperation(string ptname, string opname) {
        *WSOperation op = portType{ptname}.operations{opname};
        if (op)
            return op;
        if (!portType{ptname})
            throw "WSDL-OPERATION-ERROR", sprintf("port %y is not a defined port; known ports: %y", ptname, portType.keys());
        throw "WSDL-OPERATION-ERROR", sprintf("operation %y is not known in port %y; known operations: %y", opname, ptname, portType{ptname}.operations.keys());
    }

    #! returns the given operation for particular binding or throws an exception if it cannot be found
    WSDL::WSOperation getBindingOperation(*string bname, string opname) {
        if (!exists bname) {
            return getOperation(opname);
        } else {
            WSDL::Binding b = getBinding(bname);
            return getPortTypeOperation(b.getPort(), opname);
        }
    }

    #! returns a list of hashes giving supported operation names for each port in the WSDL
    /** @return a list of hashes giving supported operation names for each port in the WSDL; each hash<auto> has the following keys:
        - \c "port": the name of the port defining the operation
        - \c "operation": the @ref WSDL::WSOperation object for the operation
     */
    list<hash<OperationInfo>> listOperations() {
        list<hash<OperationInfo>> l();
        foreach hash<auto> ph in (portType.pairIterator()) {
            foreach WSOperation op in (ph.value.operations.iterator()) {
                l += cast<hash<OperationInfo>>((
                    "port": ph.key,
                    "operation": op,
                ));
            }
        }
        return l;
    }

    #! return a @ref WSDL::Binding object describing the requested binding
    /** @param name the name of the binding

        @return a @ref WSDL::Binding object

        @throw WSDL-BINDING-ERROR unknown binding
     */
    WSDL::Binding getBinding(string name) {
        *Binding b = binding{name};
        if (!b)
            throw "WSDL-BINDING-ERROR", sprintf("binding %y is not a known binding; known bindings: %y", name, binding.keys());
        return b;
    }

    #! returns a list of services defined in the WSDL
    /** @return a list of hashes of services defined in the WSDL; each hash<auto> has the following keys:
        - \c "name": the name of the service
        - \c "port": a hash of port information; the keys are port names and the values have the following keys:
          - \c "address": the location of the port
          - \c "binding": the binding of the port
     */
    list<hash<WSDL::ServiceInfo>> listServices() {
        return map cast<hash<WSDL::ServiceInfo>>($1), services.iterator();
        #return cast<list<hash<WSDL::ServiceInfo>>>(services.values());
    }

    #! returns a hash describing the requested service
    /** @param name the name of the service
        @return a hash describing the service with the following keys:
        - \c "name": the name of the service
        - \c "port": a hash of port information; where each hash<auto> is keyed by port name and the values have the following keys:
          - \c "address": the location of the port
          - \c "binding": the binding of the port

        @throw WSDL-SERVICE-ERROR the service is not known
     */
    hash<WSDL::ServiceInfo> getService(string name) {
        *hash<WSDL::ServiceInfo> h = services{name};
        if (!h)
            throw "WSDL-SERVICE-ERROR", sprintf("service %y is not a known service; known services: %y", name, services.keys());
        return h;
    }

    #! return a hash value that can be used to serialize a value as a particular type
    hash<auto> getType(string name, auto v) {
        #printf("DBG getType() %y: %y\n", name, tmap);
        return ("^type^": tmap_get(tmap, name), "^val^": v);
    }

    private XsdBaseType getBaseType(string t) {
        return nsc.getBaseType(t);
    }

    private resolveType(XsdSimpleType t) {
        if (!t.union) {
            throw "WSDL-TYPE-ERROR", sprintf("cannot resolve simpleType: %y type %y", t.name, t.typeinfo);
        }
        foreach hash<auto> typeinfo in (t.union) {
            t.unionTypes += resolveType(typeinfo);
        }
    }

    private resolveType(XsdElement xe) {
        if (xe.ref) {
            # find element
            #printf("DEBUG resolveType(XsdElement), ref_ns: %y ref: %y\n", xe.ref_ns, xe.ref);
            XsdElement e = emap_get(emap, xe.ref_ns, xe.ref);
            if (!e.type)
                resolveType(e);
            #printf("resolveType(XsdElement), resolved to e: %y type: %y\n", e.name, e.type.name);
            xe.assimilate(e);
            #throw "OOPS", sprintf("e: %y", xe);
        }
        else if (!xe.type) {
            xe.type = resolveType(xe.typeinfo);
            #printf("resolveType(XsdElement), %y\n", xe.type.name);
        }
    }

    private resolveType(XsdAttribute xd) {
        xd.type = resolveType(xd.typeinfo);
        #printf("resolveType(XsdTypedData), %y\n", xd.type.name);
    }

    private resolveType(XsdComplexType ct) {
        ct.simpleType = resolveType(ct.simpleTypeInfo);
        #printf("resolveType(XsdComplexType), %y\n", ct.simpleTypeInfo);
    }

    private XsdAbstractType resolveType(hash<auto> v) {
        XsdAbstractType rv;
        if (exists v.ns && nsc.isSchema(v.ns)) {
            rv = getBaseType(v.val);
        } else {
            # find type
            rv = tmap_get(tmap, v.val);
        }
        #printf("resolveType(hash), ns: %y, val: %y -> %y\n", v.ns, v.val, rv.name);
        return rv;
    }

    # parse XSD schema types
    private parseTypes(*hash<auto> data, auto http_client, auto http_headers) {
        #printf("DEBUG: parseTypes data: %y, http_client: %y, http_headers: %y\n", keys data, http_client, http_headers);
        WSDL::XsdBase::removeNS(\data);

        XsdLateResolverHelper unresolved();

        foreach *hash<auto> schema in (data.schema) {
            *hash<auto> sa = schema."^attributes^";
            #if (!sa)
            #    throw "OOPS";
            NamespacePrefixHelper nph(nsc, sa);

            bool usedocns = sa.elementFormDefault == "qualified";

            #printf("DEBUG: schema sa: %y\n", sa);
            #printf("DEBUG: schema tn: %y\n", schema."^attributes^"."targetNamespace");
            WSDL::XsdBase::removeNS(\schema);
            #printf("DEBUG: WebService::parseTypes() schema: %y\n", schema);

            # process XSD import if present
            foreach hash<auto> import in (schema.import) {
                *hash<auto> a = import."^attributes^";
                # import file
                if (a.schemaLocation) {
                    hash<auto> h = parse_url(a.schemaLocation);
                    string xsd;
                    if (!h.protocol && try_import)
                        xsd = call_function(try_import, a.schemaLocation);
                    else
                        xsd = WSDLLib::getFileFromURL(a.schemaLocation, "file", http_client, http_headers, NOTHING, def_path);

                    # parse XML to Qore data structure ignoring XML element order
                    hash<auto> xh = parse_xml(xsd);

                    # parse namespace definitions in schema attributes
                    if (xh.size() != 1)
                        throw WSDL_ERROR, sprintf("expecting a single element indicating an XSD schema in the imported file; got instead: %y", xh.keys());

                    # get schema member name
                    string sk = xh.firstKey();

                    #printf("*** DEBUG %y: sk: %y a: %y\n", a.schemaLocation, sk, xh{sk}."^attributes^");

                    # use temporary Namespaces object for import
                    Namespaces n_nsc = nsc;
                    nsc = new Namespaces(xh{sk}."^attributes^", n_nsc);
                    on_exit
                        nsc = n_nsc;
                    on_success
                        n_nsc.merge(nsc);

                    # verify that the top-level key indicates an XSD schema definition
                    (*string ns, *string mem) = (sk =~ x/^([^:]+):([^:]+)$/);
                    if (ns && !nsc.isSchema(ns))
                        throw WSDL_ERROR, sprintf("expecting imported schema definition to be in XSD namespace %y, got %y: %y instead", XSD_NS, ns, nsc.getInputNamespaceUri(ns));

                    parseTypes(xh);
                }
            }

            foreach hash<auto> st in (schema.simpleType) {
                XsdSimpleType t(st, nsc, unresolved, usedocns);
                if (tmap{t.name})
                    throw WSDL_ERROR, sprintf("type %y declared twice", t.name);
                tmap{t.name} = t;

                #tmap.add(t);
                #printf("DEBUG: st: %y\n", t.name);
            }
            foreach hash<auto> ct in (schema.complexType) {
                XsdComplexType t(ct, nsc, unresolved, usedocns);
                if (tmap{t.name})
                    throw WSDL_ERROR, sprintf("type %y declared twice", t.name);
                tmap{t.name} = t;

                #tmap.add(t);
                #printf("DEBUG: ct: %y\n", t.name);
            }
            # make element map
            foreach hash<auto> el in (schema.element) {
                *hash<auto> attr = el."^attributes^";
                XsdElement element;
                if (exists attr.type) {
                    hash<auto> eattr.name = attr.name;

                    *XsdAbstractType type;
                    hash<auto> typeinfo;
                    if (!nsc.doType(attr.type, \typeinfo, \type)) {
                        type = tmap_try_get(tmap, typeinfo.val);
                        if (!type)
                            eattr.type = typeinfo.val;
                        #printf("DEBUG: adding element %y type %y\n", attr.name, keys type);
                    }

                    element = new WSDL::XsdElement(("^attributes^": eattr), nsc, type, unresolved, usedocns);
                }
                else {
                    element = new WSDL::XsdElement(el, nsc, NOTHING, unresolved, usedocns);
                    #printf("DEBUG: adding element %y (ns %y name %y)\n", attr.name, element.ns, element.name);
                }

                if (emap{element.ns}{element.name})
                    throw WSDL_ERROR, sprintf("element %y declared twice in namespace %y", element.name, element.ns);
                emap{element.ns}{element.name} = element;
                #printf("DEBUG: added element %s -> %s\n", element.ns, element.name);
            }
        }

        # resolve types
        map resolveType($1), unresolved.getList();
        unresolved.clearResolved();

        # finalize complex types
        map cast<XsdComplexType>($1).finalize(tmap, nsc), tmap.iterator(), $1 instanceof XsdComplexType;

        # finalize complex types in elements
        map (map cast<XsdComplexType>($1.type).finalize(tmap, nsc), $1.iterator(), $1.type instanceof XsdComplexType), emap.iterator();

        map resolveType($1), unresolved.getList();
    }

    private parseMessages(*softlist<auto> message) {
        # parse messages
        foreach hash<auto> m in (message) {
            WSMessage msg(m, emap, tmap, nsc);
            foreach string arg in (keys msg.args) {
                #printf("DEBUG: WebService::parseMessages(): %y: %y\n", arg, msg);
                #printf("DEBUG: WebService::parseMessages(): %y: %y\n", arg, msg.args{arg}.type);
                if (exists msg.args{arg}.type && !(msg.args{arg}.type instanceof XsdData))
                    msg.args{arg}.type = resolveType(msg.args{arg}.type);
            }
            messages.(msg.name) = msg;
        }
    }

    private parseService(*softlist<auto> svcs) {
        foreach hash<auto> svc in (svcs) {
            WSDL::XsdBase::removeNS(\svc);
            string svcname = svc."^attributes^".name;
            foreach hash<auto> port in (svc.port) {
                WSDL::XsdBase::removeNS(\port);
                hash<auto> pa = port."^attributes^";
                string name = pa.name;

                if (!pa.binding)
                    throw WSDL_ERROR, sprintf("service %y port %y has no binding", svcname, name);
                (*string ns, *string bind) = pa.binding =~ x/(?:([^:]+):)?([^:]+)/;
                if (!bind)
                    throw WSDL_ERROR, sprintf("cannot parse service %y port %y binding: %y", svcname, name, pa.binding);

                if (!binding{bind})
                    throw WSDL_ERROR, sprintf("service %y port %y refers to non-existant binding %y; known bindings: %y", svcname, name, bind, binding.keys());

                # create the ServiceInfo hash if necessary
                if (!services{svcname})
                    services{svcname} = new hash<WSDL::ServiceInfo>(("name": svcname));

                # add the port to the service
                services{svcname}.port{name} = pa + (
                    "address": port.address."^attributes^".location,
                    "binding": binding{bind},
                );
            }
        }
    }

    private parsePortType(*softlist<auto> data) {
        # setup list of services defined in this WSDL
        foreach hash<auto> port in (data) {
            WSDL::XsdBase::removeNS(\port);
            #printf("DEBUG: portType: %y\n", port);
            string name = port."^attributes^".name;
            wsdl_services += name;
            foreach hash<auto> p in (port.operation) {
                WSOperation op(p, nsc, messages);
                if (!portType{name})
                    portType{name} = new hash<PortTypeInfo>();
                portType{name}.operations.(op.name) = op;
            }
        }
    }

    private parseBinding(*softlist<auto> bindings) {
        foreach hash<auto> data in (bindings) {
            WSDL::Binding b(data, nsc, \portType, \idocmap, messages);
            binding.(b.getName()) = b;
        }
    }

    #! returns True if the WSDL describes a SOAP 1.2 service
    /** @return True if the WSDL describes a SOAP 1.2 service
    */
    bool isSoap12() {
        return nsc.hasSoap12();
    }

    #! returns the XML string for the WSDL
    /** @return the XML string for the WSDL
    */
    string getWSDL() {
        return wsdl;
    }

    #! returns the XML string for the WSDL, adjusting the URLs for binding locations depending on the caller
    /** @param base_url the url to be prepended before the service name;
                        it must include all the handler prefixes (like \c /SOAP)
                        to produce valid URL
        @return the XML string for the WSDL
     */
    string getWSDL(string base_url) {
        string wstr = wsdl;

        foreach hash<WSDL::ServiceInfo> sh in (services.iterator()) {
            foreach hash<auto> ph in (sh.port.iterator()) {
                wstr = replace(wstr, ph.address, base_url + "/" + sh.name);
            }
        }

        return wstr;
    }

    private string getOperationParams(WSMessage msg) {
        return sprintf("%s(%s)", msg.name, (foldl $1 + "," + $2, (keys msg.args)));
    }

    #! prepare a WebService report enumerating the services and operations of the WSDL, outputs to the output stream given as the first argument
    /** @param stream the output stream for the report data
        @param wsdl_name name of the WSDL, typically a file name

        @return human readable text report
    */
    getReport(StringOutputStream stream, *string wsdl_name) {
        StreamWriter w(stream);
        w.printf("wsdl: %s\n", wsdl_name);
        foreach hash<WSDL::ServiceInfo> svc in (listServices()) {
            w.printf("  service: %s\n", svc.name);
            foreach string port in (keys svc.port) {
                w.printf("    port: %s\n", port);
                w.printf("      binding: %s\n", svc.port{port}.binding.name);
                w.printf("      address: %s\n", svc.port{port}.address);
                hash<auto> pt = portType{svc.port{port}.binding.getPort()};
                w.printf("      operations:\n");
                foreach string name in (keys pt.operations) {
                    WSOperation op = pt.operations{name};
                    w.printf("        %s\n", name);
                    if (op.input) {
                        w.printf("          input: %s\n", getOperationParams(op.input));
                    }
                    if (op.output) {
                        w.printf("          output: %s\n", getOperationParams(op.output));
                    }
                }
            }
        }
    }

    #! prepare a WebService report enumerating the services and operations of the WSDL
    /** @param wsdl_name name of the WSDL, typically a file name

        @return human readable text report
    */
    string getReport(*string wsdl_name) {
        StringOutputStream stream();
        getReport(stream, wsdl_name);
        return stream.getData();
    }

    #! can be used to create a WebService object from a hash created with serialize()
    /** @return a WebService object from the argument hash created with serialize()
    */
    static WebService deserialize(hash<auto> sws) {
        return new WebService(sws.wsdl, sws.opts);
    }
}

#! helper class implementing sample message generation
/** This is the class for generating sample SOAP messages based on a WSDL file
*/
public class WSDL::WSMessageHelper {
    private {
        WebService ws;
        hash<auto> opts;
    }

    const DefaultOpts = (
        "comments": False,
        "choices": False,
        "max_items": 3,
    );

    #! creates the WebService object
    /** @param ws the object representing the WSDL
        @param opts an optional hash of options with the following possible keys:
        - \c "comments": (bool) generate comments as values with ^comment^ key, default: False
        - \c "choices": (bool) generate choices as sub hashes ^choices^ key, default: False
        - \c "max_items" (int): max.number of array elements to output, default: 3
    **/
    constructor(WebService ws, *hash<auto> opts) {
        self.ws := ws;
        *hash<auto> h = opts;
        map remove h{$1}, keys DefaultOpts;
        if (h) {
           throw "WSDL-HELPER-ERROR", sprintf("unknown options %y (known values: %y)", keys h, keys DefaultOpts);
        }
        self.opts = DefaultOpts + opts;
        if (self.opts.max_items < 1) {
           throw "WSDL-HELPER-ERROR", sprintf("invalid 'max_items' value %y (condition: >=1)", self.opts.max_items);
        }
    }

    private hash<auto> getTypeInfo(XsdBaseType t) {
        hash res = {
            'xtype': t.name,
        };
        switch (t.name) {
            case "string":
            case "normalizedString":
            case "token":
                res += {
                    "type": "string",
                    "value": "abc",
                };
                break;
            case "anyUri":
                res += {
                    "type": "string",
                    "value": "http://www.qore.com",
                };
                break;
            case "byte":
            case "int":
            case "integer":
            case "long":
            case "negativeInteger":
            case "nonNegativeInteger":
            case "positiveInteger":
            case "nonPositiveInteger":
            case "short":
            case "unsignedLong":
            case "unsignedInt":
            case "unsignedShort":
            case "unsignedByte":
                res += {
                    "type": "int",
                    "value": 123,
                };
                break;
            case "boolean":
                res += {
                    "type": "bool",
                    "value": True,
                };
                break;
            case "base64Binary":
            case "hexBinary":
                res += {
                    "type": "binary",
                    "value": "<0feba023ffdca62910>",   # TODO: how assign binary const ?
                };
                break;
            case "decimal":
                res += {
                    "type": "number",
                    "value": 123.456,
                };
                break;
            case "date":
                res += {
                    "type": "date",
                    "value": 2015-01-31,
                };
                break;
            case "dateTime":
                res += {
                    "type": "date",
                    "value": 2015-01-31T10:20:30+01:00,
                };
                break;
            case "time":
                res += {
                    "type": "date",
                    "value": 10:20:30Z,
                };
                break;
            case "duration":
                res += {
                    "type": "date",
                    "value": P5Y2M10DT15H,   # TODO
                };
                break;
            case "binary":
                res += {
                    "type": "binary",
                    "value": <abcd>,
                };
                break;
            default:
                res += {
                    "type": t.name,
                    "value": sprintf("unknown type %y", t.name),
                };
                break;
        }
        return res;
    }

    private hash<auto> getTypeInfo(XsdSimpleType t) {
        hash<auto> res;
        if (t.type) {
            res = getTypeInfo(t.type);
            res.xtype = t.name;
            if (t.enum) {
                switch (res.type) {
                case "string":
                    res.value = (keys t.enum)[0];
                    break;
                case "int":
                    res.value = sprintf("%s", (keys t.enum)[0]);
                    break;
                default:
                    res.value = sprintf("%s", (keys t.enum)[0]);
                }
                res.comment = sprintf("Enum: %s",  (keys t.enum).join(','));
            }
        } else {
            res.xtype = t.name;
        }
        return res;
    }

    private hash<auto> getTypeInfo(XsdComplexType t) {
        hash<auto> res;
        if (t.elementmap) {
            res.type = "hash";
        } else if (t.simpleType) {
            res = getTypeInfo(t.simpleType);
        }
        res.attrs = exists t.attrs;
        return res;
    }

    hash<auto> getMessage(XsdElement elem, *softlist<auto> comments) {
        hash<auto> vi = getTypeInfo(elem.type);
        auto val;

        if (opts.comments) {
            if (elem.minOccurs == 0) {
                comments += "optional";
            }
            if (elem.minOccurs > 1) {
                comments += sprintf("minOccurs:%d", elem.minOccurs);
            }
            if (elem.maxOccurs > 1 || elem.maxOccurs < 0) {
                comments += sprintf("maxOccurs:%d", elem.maxOccurs);
            }
        }
        if (vi.type) {
            if (vi.type == 'hash') {
                val = {};
                if (elem.type instanceof XsdComplexType) {
                    XsdComplexType ct = cast<XsdComplexType>(elem.type);
                    foreach string name2 in (keys ct.elementmap) {
                        val += getMessage(ct.elementmap{name2});
                    }
                    foreach hash<ChoiceInfo> choice in (ct.choices) {
                        if (opts.choices) {
                            hash<auto> ch;
                            int j = 1;
                            foreach string name2 in (keys choice.elementmap) {
                                ch += getMessage(choice.elementmap{name2}, opts.comments ? sprintf("choice[%d]", j) : NOTHING);
                                j++;
                            }
                            val{sprintf("^choices%d^", $#+1)} = ch;
                        } else {
                            val += getMessage(choice.elementmap.firstValue(), opts.comments ? sprintf("choice[1/%d]", ct.choices.size()) : NOTHING);
                        }
                    }
                }
            } else {
                if (opts.comments && vi.comment) {
                    comments += vi.comment;
                }
                val = vi.value;
            }
        }

        auto v;
        if (comments || vi.attrs) {
            v = hash();
            if (comments) {
                v{'^comment^'} = comments.join(';');
            }
            if (vi.attrs) {
                foreach string name2 in (keys cast<XsdComplexType>(elem.type).attrs) {
                    hash<auto> vi2 = getTypeInfo(cast<XsdComplexType>(elem.type).attrs{name2}.type);
                    if (vi2.type) {
                        v{'^attributes^'}{name2} = vi2.value;
                    }
                }
            }
            if (exists val) {
                if (vi.type == 'hash') {
                    v += val;
                } else {
                    v{'^value^'} = val;
                }
            }
        } else {
            v = val;
        }
        *softint n = elem.maxOccurs;
        if (n == -1 || n > opts.max_items) {
            n = opts.max_items;
        }
        if (n > 1) {
            list<auto> l;
            int i = 1;
            while (i <= n) {
                if (comments) {
                    v{'^comment^'} = ( list(sprintf("#%d", i))+comments).join(';');
                }
                push l, v;
                i++;
            }
            return (elem.name: l);
        } else {
            return (elem.name: v);
        }
    }

    #! prepare sample message
    /** @param name message name

        @return a hash representing message
    */
    hash<auto> getMessage(string name) {
        *XsdElement e = ws.idocmap{name};
        if (!e)
            throw "MESSAGE-ERROR", sprintf("cannot map message %y to a known element; known elements: %y", ws.idocmap.keys());
        return getMessage(e);
    }

    #! prepare sample message
    /** @param msg WSMessage object

        @return a hash representing message
    */
    auto getMessage(WSMessage msg) {
        auto t = msg.args.firstValue();
        if (t.element)
            return getMessage(t.element);
        if (t.type)
            return getTypeInfo(t.type).value;
    }
}
