# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file WSDL.qm WSDL: Web Services Description Language: http://www.w3.org/TR/wsdl

/*  WSDL.qm Copyright (C) 2012 - 2016 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# make sure we have the required qore version
%requires qore >= 0.8.12

# requires XML functionality
%requires xml

# need mime definitions
%requires Mime >= 1.3.4.1

# do not use $ for vars
%new-style

%disable-warning unreferenced-variable

module WSDL {
    version = "0.3.6";
    desc = "WSDL module providing functionality for SOAP";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/*
    WSDL classes
    provides some minimal WSDL and XSD support for SOAP messaging used by the SoapClient class and the SoapHandler

    not complete, needs namespace verification, improved XSD support, element groups, etc
*/

/** @mainpage WSDL Module

    @tableofcontents

    @section wsdlintro Introduction to the WSDL Module

    The %WSDL module provides functionality for <a href="http://en.wikipedia.org/wiki/SOAP">SOAP</a> 1.1 and 1.2.

    The main purpose of this module is to provide the infrastructure for developing SOAP client and server services.

    The main components of this module are as follows:
    - @ref WSDL::WebService "WebService": represents a WSDL file; an easy way to get an object of this type from a URL is by calling WSDL::WSDLLib::getWSDL()
    - @ref WSDL::WSDLLib "WSDLLib": a class of static functions providing helper functions for the module
    - @ref WSDL::WSOperation "WSOperation": a class representing a single operation from a web service
    - @ref WSDL::WSMessageHelper "WSMessageHelper": a class to create sample message used by operation

    See the following for modules using the %WSDL module:
    - <a href="../../SoapClient/html/index.html">SoapClient user module</a>
    - <a href="../../SoapHandler/html/index.html">SoapHandler user module</a>

    @section wsdlrelnotes WSDL Module Release Notes

    @subsection wsdl_0_3_6 WSDL v0.3.6
    - reimplmented operation to support multi binding, operation can be assigned to more bindings
    - support for HTTP binding and content-types, "^content-type^" attribute can identify content type to be used
    - extended SOAP binding serialization and deserialization with "^header^" key

    @subsection wsdl_0_3_5_1 WSDL v0.3.5.1
    - supress emitting a SOAPAction header in requests if the binding gives an empty string (<a href="https://github.com/qorelanguage/qore/issues/1226">issue 1226</a>)
    - updated @ref WSDL::WSOperation::serializeRequest() to allow the SOAPAction header to be overridden in each request (<a href="https://github.com/qorelanguage/qore/issues/1226">issue 1226</a>)
    - respect XML generation flags in request generation
    - fixed parsing empty base64Binary and hexBinary elements (<a href="https://github.com/qorelanguage/qore/issues/1227">issue 1227</a>)

    @subsection wsdl_0_3_5 WSDL v0.3.5
    - fixed many message serialization and deserialization issues
    - added @ref WSDL::WebService::getOperation()
    - allow for environment variable substitution in WSDLLib::getWSDL() when retrieving files
    - fixed charset=... header value
    - added @ref WSDL::WSMessageHelper
    - added @ref WSDL::WebService::getReport()

    @subsection wsdl_0_3_4 WSDL v0.3.4
    - updated to a user module

    @subsection wsdl_0_3_3 WSDL v0.3.3
    - added initial support for the anyAttribute element of complexType
    - added initial support for SOAP header processing
    - added initial support for multiple portType and bindings in a WSDL

    @subsection wsdl_0_3_2 WSDL v0.3.2
    - fixed bugs de/serializing negative values for "int" and "short"

    @subsection wsdl_0_3_1 WSDL v0.3.1
    - improved XSD imports and namespace handling

    @subsection wsdl_0_3_0 WSDL v0.3.0
    - implemented WSDLLib class of helper functions
    - implemented support for xsd import statements in WSDLs

    @subsection wsdl_0_2_0 WSDL v0.2.0
    - use parseXMLAsData() instead of parseXML()
    - implemented initial simpleType support
    - fixed xsd:date serialization and deserialization
*/

#! main WSDL namespace
public namespace WSDL {
    #! this WSDL implementation version
    public const version     = "0.3.6";

    #! SOAP 1.1 envelope URI
    public const SOAP_11_ENV  = "http://schemas.xmlsoap.org/soap/envelope/";
    #! SOAP 1.2 envelope URI
    public const SOAP_12_ENV  = "http://www.w3.org/2003/05/soap-envelope";

    #! SOAP 1.1 namespace URI
    public const SOAP_11_NS   = "http://schemas.xmlsoap.org/wsdl/soap/";

    #! SOAP 1.2 namespace URI
    public const SOAP_12_NS   = "http://schemas.xmlsoap.org/wsdl/soap12/";

    #! XSD namespace URI
    public const XSD_NS       = "http://www.w3.org/2001/XMLSchema";
    #! XSI namespace URI
    public const XSI_NS       = "http://www.w3.org/2001/XMLSchema-instance";

    #! HTTP namespace URI
    public const HTTP_NS      = "http://schemas.xmlsoap.org/wsdl/http/";
    #! MIME namespace URI
    public const MIME_NS      = "http://schemas.xmlsoap.org/wsdl/mime/";

    #! soap 1.1 envelope namespaces
    public const ENVELOPE_11_NS = (
        "soapenv:Envelope": (
            "^attributes^": (
                "xmlns:soapenv": SOAP_11_ENV,
                "xmlns:xsd": XSD_NS,
                "xmlns:xsi": XSI_NS,
            ),
        ),
    );

    #! soap 1.2 envelope namespaces
    public const ENVELOPE_12_NS = (
        "soapenv:Envelope": (
            "^attributes^": (
                "xmlns:soapenv": SOAP_12_ENV,
              "xmlns:xsd": XSD_NS,
              "xmlns:xsi": XSI_NS,
            ),
        ),
    );

    #! soap encoding URI
    public const SOAP_ENCODING = "http://schemas.xmlsoap.org/soap/encoding/";

    #! mapping from Qore types to xsd types for xsd type "anyType"
    public const any_type_map = (
        Type::String      : "string",
        Type::Int         : "long",
        Type::Boolean     : "boolean",
        Type::Date        : "dateTime",
        Type::Float       : "decimal",
        Type::NothingType : "string",
        Type::NullType    : "string",
        Type::Binary      : "base64Binary",
    );

    # error codes
    const SOAP_SERIALIZATION_ERROR = "SOAP-SERIALIZATION-ERROR";
    const SOAP_DESERIALIZATION_ERROR = "SOAP-DESERIALIZATION-ERROR";
    const WSDL_ERROR = "WSDL-ERROR";

    #! SOAP HTTP transport URI
    const SOAP_TRANSPORT_HTTP = "http://schemas.xmlsoap.org/soap/http";

    #! known/supported transports
    public const SOAP_TRANSPORT = (
        SOAP_TRANSPORT_HTTP: True,
        );

    #! range of "short" values (16 bits)
    public const RANGE_SHORT = (-32768, 32767);

    #! range of "int" values (32 bits)
    public const RANGE_INT = (-2147483648, 2147483647);
}

#! contains helper methods for retrieving WSDLs from a URL
public class WSDL::WSDLLib {
    #! Mime types recognized as SOAP messages
    const SoapMimeTypes = (MimeTypeSoapXml, MimeTypeXml, MimeTypeXmlApp);

    #! retrieves a local file and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "file"
    */
    static data getFile(string fn, bool as_string = True) {
        *data rv = as_string ? ReadOnlyFile::readTextFile(fn) : ReadOnlyFile::readBinaryFile(fn);
        if (!exists rv)
            throw "WSDL-LIB-ERROR", sprintf("file %y is empty or could not be read as a normal file", fn);
        return rv;
    }

    #! retrieves a file from a URL with HTTP and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "http"
    */
    static string getHTTP(string url, *string path, *HTTPClient hc, *hash headers, bool as_string = True) {
        if (hc)
            hc.setURL(url);
        else
            hc = new HTTPClient(("url": url));
        string body = hc.get(path ? path : "/", headers);
        return as_string ? body : binary(body);
    }

    #! retrieves a file from a URL with the FTP protocol and returns the file's contents as binary or string data
    /** called by WSDLLib::getFileFromURL() in case the scheme is "ftp"
    */
    static data getFTP(string url, string path, bool as_string = True) {
        string file = basename(path);
        if (!file)
            throw "WSDL-LIB-ERROR", sprintf("missing file name in URL %y", url);

        FtpClient f(url);
        f.connect();

        string dir = dirname(path);
        if (dir)
            f.cwd(dir);

        return as_string ? f.getAsString(file) : f.getAsBinary(file);
    }

    #! retrieves a file from a URL
    /** in case the URL is actually a file path, environment variable substitution
        is performed on the path string
     */
    static data getFileFromURL(string url, string def_protocol = "file", *HTTPClient http_client, *hash http_headers, bool as_string = True, *string def_path, *reference new_def_path) {
        return WSDLLib::getFileFromURL(url, parse_url(url), def_protocol, http_client, http_headers, as_string, def_path, \new_def_path);
    }

    #! retrieves a file from an already-parsed URL
    /** in case the URL is actually a file path, environment variable substitution
        is performed on the path string
     */
    static data getFileFromURL(string url, hash u, string def_protocol = "file", *HTTPClient http_client, *hash http_headers, bool as_string = False, *string def_path, *reference new_def_path) {
        if (!exists u.protocol)
            u.protocol = def_protocol;

        switch (u.protocol) {
            case "file": {
                string path;
                if (u.host)
                    path = u.host;
                if (u.path) {
                    if (path)
                        path += DirSep;
                    path += u.path;
                }
                # do environment variable substitution
                map path = replace(path, "\$" + $1, ENV.$1), (path =~ x/\$(\w+)/g);

                if (def_path && !absolute_path(path))
                    path = def_path + DirSep + path;
                else
                    new_def_path = dirname(path);
                return WSDLLib::getFile(path, as_string);
            }

            case /^http(s)?$/:
                return WSDLLib::getHTTP(url, u.path, http_client, http_headers, as_string);

            case /^ftp(s)?$/:
                return WSDLLib::getFTP(url, u.path, as_string);

            default:
                throw "WSDL-LIB-ERROR", sprintf("do not know how to retrieve data with scheme %y given in URL %y", u.protocol, url);
        }
    }

    #! returns the argument
    static WebService getWSDL(WebService wsdl) {
        return wsdl;
    }

    #! returns a WSDL string form a file name, optional HTTPClient object and optional header hash
    /** in case the \a wsdl argument is actually a file path, environment variable substitution
        is performed on the path string
     */
    static string getWSDL(string wsdl, *HTTPClient http_client, *hash http_headers, *reference new_def_path) {
        if (wsdl =~ /^<\?xml/)
            return wsdl;
        return WSDLLib::getFileFromURL(wsdl, "file", http_client, http_headers, NOTHING, NOTHING, \new_def_path);
    }

    #! takes a hash representation of a SOAP message and handles multipart messages, checks the content-type, and handles hrefs in the message
    static hash parseMultiPartSOAPMessage(hash msg) {
        if (exists msg."_qore_multipart") {
            if (msg."_qore_multipart" != "related")
                throw "SOAP-MESSAGE-ERROR", sprintf("don't understand multipart/%s messages, expected multipart/related", msg."_qore_multipart");

            any bdry = msg."_qore_multipart_boundary";
            if (!strlen(bdry))
                throw "SOAP-MESSAGE-ERROR", sprintf("multipart message received without multipart boundary; headers: %y", msg - "body");

            hash mpmsg;
            list l = split("\r\n--" + bdry, msg.body);

            for (int i = 1; i < (elements l - 1); ++i) {
                string m = l[i];

                int ie = index(m, "\r\n\r\n");
                if (ie == -1) {
                    throw "SOAP-MESSAGE-ERROR", sprintf("part %d has no headers: %y", i, m);
                }
                hash hh;
                foreach string hl in (split("\r\n", substr(m, 2, ie))) {
                    trim hl;
                    (string hi, any ignore, string ha) = hl =~ x/^(.*):([ \t])*(.*)$/;
                    hi = tolower(hi);
                    #printf("hl: %y hi: %y ha: %y\n", hl, hi, ha);exit();
                    hh{hi} = ha;
                }
                if (!exists hh."content-id")
                    throw "SOAP-MESSAGE-ERROR", sprintf("expecting part header Content-ID in part %d; headers: %y", i, hh);

                any b;
                if (hh."content-transfer-encoding" == "binary") {
                    # unfortunately we have to do some tricks to get the binary data out here
                    # FIXME: tricks probably not necessary with qore 0.8.1+
                    m = force_encoding(m, "ascii");
                    # recalculate byte offset
                    ie = index(m, "\r\n\r\n");
                    #printf("ie: %d m: %d\n", ie, strlen(m));exit();
                    b = binary(substr(m, ie + 4));

                    #File f(); f.open2("t.bin", O_CREAT|O_WRONLY|O_TRUNC); f.write(b); exit();
                }
                else {
                    b = substr(m, ie + 4);

                    if (hh."content-type" =~ /charset=/) {
                        string c = (hh."content-type" =~ x/charset=([^;]+)/)[0];
                        b = force_encoding(b, c);
                    }
                }

                if (hh."content-id" !~ /^\<.*\>$/)
                    throw "SOAP-MESSAGE-ERROR", sprintf("expected part ID to have the following format: <id>, instead got %s", hh."content-id");

                hash p = (
                    "hdr": hh,
                    "body": b,
                    );

                if ((!exists msg."_qore_multipart_start" && i == 1)
                    || (exists msg."_qore_multipart_start" && msg."_qore_multipart_start" == hh."content-id")) {
                    mpmsg.body = p;
                }
                else {
                    string id = substr(hh."content-id", 1, -1);
                    mpmsg.part{id} = p;
                }
            }
            return {
                'content-type': mpmsg.body.hdr."content-type",
                'header': msg.header + mpmsg.body.hdr,
                'body': mpmsg.body.body,
                'parts': mpmsg.part,
            };
        } else {
            return {
                'content-type': msg."_qore_orig_content_type",
                'header': msg.header,
                'body': msg.body,
            };
        }
    }

    #! takes a hash representation returned by parseMultiPartSOAPMessage and parses it to a Qore data structure, checks the content-type, and handles hrefs in the message
    static *hash parseSOAPMessage(hash msg) {
        if (WSDLLib::isContentType(msg."content-type", SoapMimeTypes)) {
            hash xmldata;
            if (msg.body) {
                xmldata = parse_xml(msg.body);
            }
            if (msg.parts) {
                # parse entire data structure to find "href"s or href attributes
                WSDLLib::substHref(\xmldata, msg.parts);
            }
            if (!exists xmldata) {
                # fake data, e.g. when URLEncoded
                xmldata."content-type" = msg."content-type";
                xmldata.body = NOTHING;
            }
            return xmldata;
        } else {
            string ct = msg."content-type";
            hash h."content-type" = (ct =~ x/^([^;]+)/)[0];
            if (ct =~ /charset=/) {
                string c = (ct =~ x/charset=([^;]+)/)[0];
                h.body = force_encoding(msg.body, c);
            } else {
                h.body = binary(msg.body);  # needed or is it already ?
            }
            return h;
        }
    }

    /*private in module*/ static bool isContentType(string ct, list MimeTypes) {
        ct = ltrim(ct);
        foreach string sct in (MimeTypes) {
            # Content-Type := type "/" subtype *[";" parameter] ... so we can test if string is starting at index 0
            if (bindex(ct, sct) == 0)
                return True;
        }
        return False;
    }


    /*private in module*/ static checkContentType(string ct, list MimeTypes) {
        if (!WSDLLib::isContentType(ct, MimeTypes)) {
            throw "SOAP-MESSAGE-ERROR", sprintf("don't know how to handle content-type %y (expecting one of: %y)", ct, MimeTypes);
        }
    }

    private static processHref(reference xmldata, string hr, hash parts) {
        if (hr !~ /^cid:/)
            throw "SOAP-MESSAGE-ERROR", sprintf("messages references non-local part %y; cannot handle non-local parts", hr);
        hr = substr(hr, 4);
        if (!exists parts{hr})
            throw "SOAP-MESSAGE-ERROR", sprintf("message references non-existent part %y", hr);
        xmldata = parts{hr}.body;
    }

    private static substHref(reference xmldata, hash parts) {
        foreach string k in (keys xmldata) {
            if (exists xmldata{k}."^attributes^".href)
                WSDLLib::processHref(\xmldata{k}, xmldata{k}."^attributes^".href, parts);
            else if (exists xmldata{k}.href)
                WSDLLib::processHref(\xmldata{k}, xmldata{k}.href, parts);
            else if (xmldata{k}.typeCode() == NT_LIST) {
                foreach any e in (\xmldata{k})
                    WSDLLib::substHref(\e, parts);
            }
            else if (xmldata{k}.typeCode() == NT_HASH)
                WSDLLib::substHref(\xmldata{k}, parts);
        }
    }
}

#! base class with helper methods for XSD data processing
public class WSDL::XsdBase {
    /*
    static private hash doType(string t) {
        #printf("DEBUG: XsdBase::doType(%y)\n", t);
        (*string ns, *string type) = t =~ x/(\w+):(\w+)/;
        return !exists type ? ("val": t) : ("ns": ns, "val": type);
    }
    */

    static removeNS(reference v) {
        foreach hash h in (\v) {
            foreach string k in (h.keyIterator()) {
                (*string ns, *string name) = k =~ x/(\w+):(\w+)/;
                if (ns) {
                    if (h{k}.typeCode() == NT_HASH)
                        h{k}.ns = ns;
                    if (h{name}) {
                        softlist l = h{name};
                        l += remove h{k};
                        h{name} = l;
                    }
                    else
                        h{name} = remove h{k};
                }
            }
        }
    }

    static removeNS2(reference v) {
        foreach hash h in (\v) {
            foreach string k in (h.keyIterator()) {
                (*string ns, *string name) = k =~ x/(\w+):(\w+)/;
                if (ns) {
                    if (h{k}.typeCode() == NT_HASH)
                        h{k}.".ns" = ns;
                    if (h{name}) {
                        softlist l = h{name};
                        l += remove h{k};
                        h{name} = l;
                    }
                    else
                        h{name} = remove h{k};
                }
            }
        }
    }
}

#! base class for XSD data classes
public class WSDL::XsdData inherits WSDL::XsdBase {
    any getValue(*hash mrh, any val) {
        if (exists val."^attributes^".href) {
            string href = substr(val."^attributes^".href, 1);

            if (!exists mrh.mrh{href})
                throw "INVALID-REFERENCE", sprintf("multiRef id: %y does not exist", href);

            return mrh.mrh{href};
        }
        return val;
    }
}

#! base class for XSD classes with a "name" attribute
public class WSDL::XsdNamedData inherits WSDL::XsdData {
    public {
        # name of object
        string name;
        #! input namespace prefix (if any given)
        *string ns;
        #! descriptive name flag
        descriptive_name;
    }

    constructor(string n_name, string n_ns) {
        name = n_name;
        ns = n_ns;
        # if the name has a space in it, then it's a descriptive name
        descriptive_name = (name =~ / /);
    }

    constructor(reference e, *string desc_name) {
        WSDL::XsdBase::removeNS(\e);
        *hash a = e."^attributes^";
        if (a.name)
            name = a.name;
        else if (a.ref) {
            # remove namespace
            (*string ns, *string n_name) = a.ref =~ x/(\w+):(\w+)/;
            name = n_name ?? a.ref;
        }
        else
            name = desc_name ?? "<unnamed type>";
        # if the name has a space in it, then it's a descriptive name
        descriptive_name = (name =~ / /);
    }

    string getName() {
        return name;
    }

    *string getInputNamespacePrefix() {
        return ns;
    }

    bool hasRealName() {
        return !descriptive_name;
    }
}

public class WSDL::XsdAbstractType inherits WSDL::XsdNamedData {
    public {
        #! reference to namespaces
        Namespaces nsc;

        #! my namespace output prefix
        string ons;
    }

    constructor(reference e, Namespaces n_nsc, *string desc_name) : XsdNamedData(\e, desc_name) {
        nsc = n_nsc;
        resolveNamespace();
    }

    constructor(string name, string ns, Namespaces n_nsc) : XsdNamedData(name, ns) {
        nsc = n_nsc;
        resolveNamespace();
    }

    private resolveNamespace() {
        if (!ns) {
            *string tns = nsc.getTargetNamespaceUri();
            if (!tns)
                throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace for %s %y was not given and there is no current target namespace", self.className(), name);
            ons = nsc.getOutputNamespacePrefix(tns);
        }
        else
            ons = nsc.translateOutputNamespacePrefix(ns);
        #printf("DEBUG: type %y ns: %y ons: %y\n", name, ns, ons);
    }

    checkExtends(XsdAbstractType t, string ename) {
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible", name, ename, t.name);
    }

    string getNameWithNS() {
        return ons + ":" + name;
    }

    bool isNillable() {
        return False;
    }

    bool isRequired() {
        return True;
    }

    bool requiresValue() {
        return !isNillable() && isRequired();
    }

    string getOutputNamespacePrefix() {
        return ons;
    }

    abstract any serialize(any val, *softbool omitType, *softbool keepBinary);
    abstract any deserialize(string en, *TypeMap tmap, *hash mrh, any val);
}

#! class for XSD base types
public class WSDL::XsdBaseType inherits WSDL::XsdAbstractType {
    public {
    }

    constructor(string t, Namespaces nsc, string ns = "xsd") : XsdAbstractType(t, ns, nsc) {
    }

    any serialize(any val, *softbool omitType, *softbool keepBinary) {
        *hash comments;
        if (val.typeCode() == NT_HASH) {
            foreach string k in (val.keyIterator()) {
                if (k =~ /^\^comment/) {
                    comments{k} = val{k};
                }
            }
            val = val."^value^";
        }
        *string type;
        # set type according to Qore type if xsd type is anyType
        if (name == "anyType") {
            # we have to specify the type in this case
            omitType = False;
            type = any_type_map{val.type()};
            if (!type)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize xsd type anyType from Qore type %y", val.type());
        }
        else {
            type = name;
        }
        switch (type) {
            case "byte": {
                int v = int(val);
                if ((v & 0xff) != v)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "short": {
                int v = int(val);
                if (v < RANGE_SHORT[0] || v > RANGE_SHORT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "int": {
                int v = int(val);
                if (v < RANGE_INT[0] || v > RANGE_INT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedByte": {
                int v = int(val);
                if ((v & 0xff) != v)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", type, v);
                break;
            }

            case "unsignedShort": {
                int v = int(val);
                if (v < 0 || v > RANGE_SHORT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedInt": {
                int v = int(val);
                if (v < 0 || v > RANGE_INT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedLong": {
                int v = int(val);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", type, v);
                break;
            }

            case "negativeInteger": {
                int v = int(val);
                if (v >= 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts negative values (value supplied: %d)", name, v);
                break;
            }

            case "nonNegativeInteger": {
                int v = int(val);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts non-negative values (value supplied: %d)", name, v);
                break;
            }

            case "nonPositiveInteger": {
                int v = int(val);
                if (v > 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts non-positive values (value supplied: %d)", name, v);
                break;
            }

            case "positiveInteger": {
                int v = int(val);
                if (v <= 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts positive values (value supplied: %d)", type, v);
                break;
            }

            case "date":
                val = format_date("YYYY-MM-DD", date(val));
                break;

            case "dateTime":
                val = format_date("YYYY-MM-DDTHH:mm:SS", date(val));
                break;

            case "boolean":
                val = val ? "true" : "false";
                break;

            case "time":
                val = format_date("hh:mm:ss.ms", date(val));
                break;

            case "base64Binary":
                if (keepBinary) {
                    val = binary(val);
                } else {
                    val = make_base64_string(val);
                }
                break;

            case "hexBinary":
                if (keepBinary) {
                    val = binary(val);
                } else {
                    val = make_hex_string(val);
                }
                break;
        }

        #printf("DEBUG: FORCE: type: %y, nstype: %y, val: %y\n", type, nstype, val);
        if (omitType)
            if (comments) {
                return comments + (
                    "^value^": val
                );
            } else
                return val;
        else
            return (
                comments +
                "^attributes^": (
                    "xsi:type": sprintf("%s:%s", ons, type),
                ),
                "^value^": val,
            );
    }

    any deserialize(string en, *TypeMap tmap, *hash mrh, any val) {
        string type;
        if (val.typeCode() == NT_HASH && val.hasKey("^value^")) {
            if (val."^attributes^"."xsi:type") {
                type = val."^attributes^"."xsi:type";
                string t = (type =~ x/\w+:(\w+)/)[0];
                if (exists t)
                    type = t;

                if (name != "anyType" && type != name)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting base type %y, got %y", name, val."^attributes^"."xsi:type");
            }
            else
                type = name;
            val = val."^value^";
        }
        else
            type = name;

        switch (type) {
            case "string":
            case "anyURI":
                return string(val);

            case "integer": {
                # note that we do not convert xsd:integer to a qore integer if we would lose precision
                int v = int(val);
                return v == val ? v : val;
            }

            case "byte":
                val = int(val);
                if ((val & 0xff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "short":
                val = int(val);
                if (val < RANGE_SHORT[0] || val > RANGE_SHORT[1])
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "int":
                val = int(val);
                if (val < RANGE_INT[0] || val > RANGE_INT[1])
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "long":
                return int(val);

            case "unsignedByte":
                val = int(val);
                if ((val & 0xff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedShort":
                val = int(val);
                if ((val & 0xffff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedInt":
                val = int(val);
                if ((val & 0xffffffff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedLong":
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return int(val);

            case "negativeInteger":
                if (val >= 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts negative values (value supplied: %d)", name, val);
                return int(val);

            case "nonNegativeInteger":
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts non-negative values (value supplied: %d)", name, val);
                return int(val);

            case "nonPositiveInteger":
                if (val > 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts non-positive values (value supplied: %d)", name, val);
                return int(val);

            case "positiveInteger":
                if (val <= 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts positive values (value supplied: %d)", name, val);
                return int(val);

            case "date":
                # remove dashes from date
                val =~ s/-//g;
                return date(val);

            case "dateTime":
                return date(substr(val, 0, 4) + substr(val, 5, 2) + substr(val, 8, 2) +
                            substr(val, 11, 2) + substr(val, 14, 2) + substr(val, 17, 2));

            case "time":
                return date("19700101" + substr(val, 0, 2) + substr(val, 3, 2) + substr(val, 6, 2)) +
                       milliseconds(substr(val, 9, 3));

            case "boolean":
                if (val =~ /true/i)
                    return True;
                if (val =~ /false/i)
                    return False;
                return boolean(val);

            case "decimal":
                return float(val);

            case "base64Binary":
                if (val.typeCode() == NT_BINARY) {
                    return val;
                } else {
                    return val.empty() ? binary() : parse_base64_string(val);
                }

            case "hexBinary":
                if (val.typeCode() == NT_BINARY) {
                    return val;
                } else {
                    return val.empty() ? binary() : parse_hex_string(val);
                }

            default: {
                if (name == "anyType")  {
                    *XsdAbstractType t = tmap.tryGet(type);
                    if (t)
                        return t.deserialize(en, tmap, mrh, val);
                }
                throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }
}

#! class for XSD array types; currently only supports "binary"; used, for example with HTTP MultiPart messages
public class WSDL::XsdArrayType inherits WSDL::XsdAbstractType {
    constructor(string t, Namespaces nsc) : XsdAbstractType(t, "ns1", nsc) {
        if (t != "binary")
            throw "XSD-ARRAYTYPE-ERROR", sprintf("don't know how to handle arrays of type %y", t);
    }

    any serialize(any val, *softbool omitType, *softbool keepBinary) {
        switch (name) {
            case "binary": {
                int t = val.typeCode();
                if (t === NT_STRING)
                    val = binary(val);
                else if (t !== NT_BINARY)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize type %y from type %y; requires string or binary", name, t);
                return val;
            }

            default: {
                throw SOAP_SERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }

    any deserialize(string en, *TypeMap tmap, *hash mrh, any val) {
        switch (name) {
            case "binary": {
                if (val.typeCode() != NT_BINARY)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize type %y from type %y; requires binary", name, val.typeName());
                return val;
            }

            default: {
                throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }
}

#! XSD typed data class
public class WSDL::XsdTypedData inherits WSDL::XsdNamedData {
    public {
        any type;
    }

    constructor(reference e) : XsdNamedData(\e) {
    }
}

#! XSD attribute class
public class WSDL::XsdAttribute inherits WSDL::XsdTypedData {
    public {
        string use = "optional";

        const AllowedUseValues = (
            "optional": True,
            "required": True,
            "prohibited": True,
            );
    }

    constructor(hash attr, Namespaces nsc, *XsdAbstractType n_type, XsdLateResolverHelper unresolved) : XsdTypedData(\attr) {
        *hash aa = attr."^attributes^";
        if (aa.type) {
            type = nsc.doType(aa.type);

            if (aa.use) {
                if (!AllowedUseValues.(aa.use))
                    throw "XSD-ATTRIBUTE-ERROR", sprintf("attribute %y: use %y is unrecognized; recognized use values: %y", name, aa.use, AllowedUseValues.keys());
                use = aa.use;
            }

            # add self to unresolved list if element type cannot be resolved
            if (!(type instanceof XsdAbstractType))
                unresolved.add(self);
        }
    }

    any getValue(string val) {
        return type.deserialize(name, NOTHING, NOTHING, val);
    }
}

#! XSD element class
public class WSDL::XsdElement inherits WSDL::XsdTypedData {
    public {
        int minOccurs = 1;
        int maxOccurs = 1;
        bool nillable = False;
        *string ref;
        bool usedocns;
    }

    constructor(hash e, Namespaces nsc, *XsdAbstractType n_type, XsdLateResolverHelper unresolved, bool n_usedocns) : XsdTypedData(\e) {
        usedocns = n_usedocns;

        if (!ns)
            ns = nsc.getTargetNamespaceUri();

        if (n_type) {
            type = n_type;
            return;
        }

        *hash a = e."^attributes^";

        if (exists a.minOccurs)
            minOccurs = int(a.minOccurs);

        if (exists a.maxOccurs)
            if (a.maxOccurs == "unbounded")
                maxOccurs = -1;
            else
                maxOccurs = int(a.maxOccurs);

        if (maxOccurs != -1 && minOccurs > maxOccurs)
            throw "XSD-ELEMENT-ERROR", sprintf("minOccurs (%d) > maxOccurs (%d) for element %s", minOccurs, maxOccurs, name);

        if (a.nillable == "true")
            nillable = True;

        if (a.type) {
            type = nsc.doType(a.type);

            # add self to unresolved list if element type cannot be resolved
            if (!(type instanceof XsdAbstractType)) {
                #printf("DEBUG: self: %y\n", self);
                unresolved.add(self);
            }
        }
        else if (e.simpleType)
            type = new XsdSimpleType(e.simpleType, nsc, unresolved, usedocns, sprintf("simpleType for element %y", name));
        else if (e.hasKey("complexType")) {
            type = new XsdComplexType(e.complexType, nsc, unresolved, usedocns, sprintf("complexType for element %y", name));
            if (!type.isRequired() && !exists a.minOccurs)
                minOccurs = 0;
            if (type.isNillable() && !exists a.nillable)
                nillable = True;
        }
        else if (e."^attributes^".ref) {
            ref = e."^attributes^".ref;
            unresolved.add(self);
        }
    }

    assimilate(WSDL::XsdElement other) {
        map self.$1 = other.$1, other.keyIterator(), !exists self.$1;
        # we have to use the namespace of the referenced element
        ns = other.ns;
    }

    bool isRequired() {
        return minOccurs > 0;
    }

    bool isNillable() {
        return nillable;
    }

    /*
    bool isRequired() {
        #printf("DBG %y: required nillable: %y minOccurs: %y type: %y\n", name, nillable, minOccurs, ((type instanceof XsdAbstractType && type.isRequired()) | True));
        return !nillable && minOccurs && ((type instanceof XsdAbstractType && type.isRequired()) | True);
    }
    */

    any serialize(any h, *softbool omitType, string key, string typename) {
        if (type.typeCode() == NT_HASH)
            printf("ERROR: %y\n", self);

        if (h."^type^" && h."^type^" instanceof XsdAbstractType && h.hasKey("^val^")) {
            XsdAbstractType ntype = cast<XsdAbstractType>(h."^type^");
            ntype.checkExtends(type, name);
            return serializeAsIntern(ntype, h."^val^", omitType, key, name);
        }

        return serializeAsIntern(type, h, omitType, key, typename);
    }

    private any serializeAsIntern(XsdAbstractType type, any h, *softbool omitType, string key, string typename) {
        #printf("DEBUG: XsdElement::serializeAsIntern() name: %y (with type: %y) h: %y key: %y typename: %y (%y) minOccurs: %y nillable: %y (%y %y)\n", name, ((!omitType || type != self.type) && type.hasRealName()), h, key, typename, type.getName(), minOccurs, nillable, !exists h, !minOccurs);

        int tc = h.typeCode();
        if (tc == NT_LIST && h.size() == 1)
            h = h[0];

        if (!exists h || (tc == NT_LIST && h.empty())) {
            if (!minOccurs)
                return;

            if (nillable || type.isNillable()) {
                hash rh = ("xsi:nil": "true");
                if ((!omitType || type != self.type) && type.hasRealName())
                    rh += ("xsi:type": type.getNameWithNS());
                return ("^attributes^": rh);
            }

            if (!type.isRequired())
                return;

            if (!type.requiresValue())
                return ("^value^": NOTHING);

            throw SOAP_SERIALIZATION_ERROR, sprintf("missing element %y value for %s::%s (minOccurs: %d, type %y)", name, typename, key, minOccurs, type.getName());
        }

        *hash pf;
        if ((!omitType || type != self.type) && type.hasRealName())
            pf = ("^attributes^": ("xsi:type": !usedocns ? type.getName() : type.getNameWithNS()));

        if (tc == NT_LIST) {
            int len = h.size();
            if (maxOccurs == 1 && len > 1)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y of type %y from a list with %d elements because maxOccurs = 1", name, type.getName(), len);
            if (len > maxOccurs && maxOccurs > 0)
                throw SOAP_SERIALIZATION_ERROR, sprintf("list for element %y of type %y has %d element%s, but maxOccurs = %d", name, type.getName(), elements h, elements h == 1 ? "" : "s", maxOccurs);
            if (len < minOccurs)
                throw SOAP_SERIALIZATION_ERROR, sprintf("list for element %y of type %y has %d element%s, but minOccurs = %d", name, type.getName(), elements h, elements h == 1 ? "" : "s", minOccurs);

            list l = ();
            foreach any e in (h) {
                l += (pf + type.serialize(e, omitType));
            }
            return l;
        }
        if (minOccurs > 1)
            throw SOAP_SERIALIZATION_ERROR, sprintf("only one element passed to element %y of type %y, but minOccurs = %d", name, type.getName(), minOccurs);

        #printf("DEBUG: element %y type %s: %y omitType: %y h: %y\n", name, type.className(), type.name, omitType, h);
        return (pf + type.serialize(h, omitType));
    }

    any deserialize(*TypeMap tmap, *hash mrh, any val, bool present) {
        #printf("XsdElement::deserialize() name: %y type: %y (nillable: %y) val: %y present: %y\n", name, type.getName(), type.isNillable(), val, present);
        *hash a = val."^attributes^";
        if (a)
            WSDL::XsdBase::removeNS(\a);

        if ((!exists val && !present) || a.nil == "true") {
            if (nillable || type.isNillable() || !minOccurs)
                return;
            throw SOAP_DESERIALIZATION_ERROR, sprintf("NOTHING passed for element %y type %y, but nillable=False and minOccurs: %d", name, type.getName(), minOccurs);
        }

        if (val.typeCode() == NT_LIST) {
            int el = elements val;
            if (maxOccurs != -1 && el > maxOccurs)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, maxOccurs: %d but list is %d elements long", name, maxOccurs, el);
            if (el < minOccurs)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, minOccurs: %d but list is %d elements long", name, minOccurs, el);

            list l;
            foreach any e in (val)
                l[elements l] = type.deserialize(name, tmap, mrh, getValue(mrh, e));
            return l;
        }

        if (minOccurs > 1)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("single value passed for element %y, but minOccurs: %d", name, minOccurs);

        return type.deserialize(name, tmap, mrh, getValue(mrh, val));
    }
}

#! XSD simple type class
public class WSDL::XsdSimpleType inherits WSDL::XsdAbstractType {
    public {
        hash enum;
        any type;
        bool usedocns;
    }

    constructor(hash st, Namespaces nsc, XsdLateResolverHelper unresolved, bool n_usedocns, *string desc_name) : XsdAbstractType(\st, nsc, desc_name) {
        usedocns = n_usedocns;
        #any a = st."^attributes^";
        delete st."^attributes^";

        WSDL::XsdBase::removeNS(\st);

        if (st.restriction) {
            *hash r = st.restriction;

            any base = r."^attributes^".base;
            if (!base)
                throw "XSD-SIMPLETYPE-ERROR", sprintf("missing 'base' attribute in simpleType %y restriction", name);

            type = nsc.doType(base);

            # add base type to unresolved list if type cannot be resolved
            if (!(type instanceof XsdData))
                unresolved.add(self);

            WSDL::XsdBase::removeNS(\r);

            if (r.enumeration)
                enum = map {$1."^attributes^".value: True}, r.enumeration;
        }
        else
            throw "XSD-SIMPLETYPE-ERROR", sprintf("missing restriction element in simpleType %y", name);

        #printf("DEBUG: st: %y\n", self); exit();
    }

    any serialize(any val, *softbool omitType, *softbool keepBinary) {
        *hash rh;
        if (val.typeCode() == NT_HASH) {
            foreach string k in (val.keyIterator()) {
                if (k =~ /^\^comment/) {
                    rh{k} = remove val{k};
                }
            }
            if (val.size() == 1 && val.firstKey() == "^value^")
                val = val."^value^";
        }
        if (enum && !enum{val})
            throw "SOAP-SERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y is not in the enumeration list (%y)", val, name, enum.keys());

        return rh + type.serialize(val, omitType);
    }

    any deserialize(string en, *TypeMap tmap, *hash mrh, any val) {
        any v = type.deserialize(en, tmap, mrh, val);

        if (enum && !enum{v})
            throw "SOAP-DESERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y while deserializing element %y is not in the enumeration list (%y)", v, name, en, enum.keys());

        return v;
    }
}

#! XSD complex type class
public class WSDL::XsdComplexType inherits WSDL::XsdAbstractType {
    public {
        any array;
        any restriction;
        *string extension;

        bool usedocns;

        *hash elementmap;
        bool anyAttribute = False;

        bool nillable = False;
        bool required = False;
        bool requires_value = False;

        # attributes
        hash attrs;

        # any annotated documentation
        *string documentation;

        # simpleContent type
        any simpleType;

        # finalization flag
        bool finalized = False;

        # multiple choice blocks
        list choices = ();
    }

    private {
        #! type of complexType object
        string cx_type;

        const XET_ALL      = "ALL";
        const XET_CHOICE   = "CHOICE";
        const XET_SEQUENCE = "SEQUENCE";
        const XET_SIMPLE   = "SIMPLE";
        const XET_NONE     = "NONE";
    }

    # ct can be NOTHING in case of an empty complex type
    constructor(*hash ct, Namespaces nsc, XsdLateResolverHelper unresolved, bool n_usedocns, *string desc_name) : XsdAbstractType(\ct, nsc, desc_name) {
        usedocns = n_usedocns;
        #any a = ct."^attributes^";
        delete ct."^attributes^";

        *hash d = ct.complexContent;
        if (d) {
            WSDL::XsdBase::removeNS(\d);
            if (d.restriction) {
                WSDL::XsdBase::removeNS(\d.restriction);

                any base = d.restriction."^attributes^".base;

                # FIXME: handle namespace
                (*string ns, *string tn) = base =~ x/(\w+):(\w+)/;
                if (exists tn) {
                    if (tn == "Array") {
                        # FIXME check that namespace is SOAP encoding
                        any aa = d.restriction.attribute."^attributes^";
                        WSDL::XsdBase::removeNS(\aa);
                        if (!exists aa.arrayType)
                            throw WSDL_ERROR, sprintf("cannot parse complexType restriction: %y", d.restriction);

                        # FIXME: handle multiple dimensions?
                        (*string ans, *string atn) = aa.arrayType =~ x/(\w+):(\w+)\[\]$/;
                        if (exists atn) {
                            array.val = atn;
                            array.ns  = ans;
                        }
                        else
                            array.val = aa.arrayType;

                        delete d.restriction.attribute;
                        #printf("DEBUG: ans: %y atn: %y aa: %y\n", ans, atn, aa);
                        return;
                    }
                    else {
                        restriction = tn;
                    }
                }

                delete d.restriction."^attributes^";

                parseData(d.restriction, unresolved);
            }
            else if (d.extension) {
                #any etype = nsc.doType(d.extension."^attributes^".base);
                #if (!(etype instanceof XsdAbstractType))
                #    unresolved.add(self);
                extension = d.extension."^attributes^".base;

                # FIXME: check for soap encoding namespace
                extension =~ s/(.*:)(.*)/$2/;
                delete d.extension."^attributes^";
                WSDL::XsdBase::removeNS(\d.extension);

                parseData(d.extension, unresolved);
            }
            else
                throw "XSD-COMPLEXCONTENT-ERROR", sprintf("can't parse complexContent %y %y information", getName(), d.firstKey());
        }
        else if (ct.simpleContent) {
            d = ct.simpleContent;
            WSDL::XsdBase::removeNS(\d);
            cx_type = XET_SIMPLE;
            simpleType = nsc.doType(d.extension."^attributes^".base);
            remove d.extension."^attributes^";
            if (!(simpleType instanceof XsdAbstractType))
                unresolved.add(self);
            WSDL::XsdBase::removeNS(\d.extension);
            parseAttributes(\d.extension, unresolved);
        }
        else if (ct)
            parseData(ct, unresolved);
        else {
            # empty complex type
            cx_type = XET_NONE;
            required = True;
            requires_value = False;
        }
    }

    finalize(TypeMap tmap, Namespaces nsc) {
        if (finalized)
            return;
        finalized = True;

        # process restriction info
        if (restriction) {
            # combine base type and new type
            XsdAbstractType t = tmap.get(restriction);
            if (!(t instanceof XsdComplexType))
                throw WSDL_ERROR, sprintf("cannot restrict complexType %y with type %y", name, t.name);
            cast<XsdComplexType>(t).finalize(tmap, nsc);
            elementmap = cast<XsdComplexType>(t).elementmap + elementmap;
            #printf("DEBUG: extended %s with %s (%y)\n", name, restriction, cast<XsdComplexType>(t).elementmap.keys());
        }
        # process extension info
        else if (extension) {
            XsdAbstractType t = tmap.get(extension);
            if (!(t instanceof XsdComplexType))
                throw WSDL_ERROR, sprintf("cannot extend complexType %y with type %y", name, t.name);
            cast<XsdComplexType>(t).finalize(tmap, nsc);
            # combine base type and new type
            elementmap = cast<XsdComplexType>(t).elementmap + elementmap;
            #printf("DEBUG: extended %s (%s) with %s (%y) elements: %y\n", name, self.uniqueHash(), extension, cast<XsdComplexType>(t).elementmap.keys(), elementmap.keys());
        }

        # process array info
        if (array) {
            any et = array.val;
            *XsdAbstractType t = tmap.tryGet(et);
            array = new XsdArrayType(t ? t : et, nsc);
        }
    }

    #! throws an exception if the types are not compatible
    checkExtends(XsdAbstractType t, string ename) {
        if (extension == t.name || t == self)
            return;
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible%s", name, ename, t.name, extension ? sprintf("; %y extends %y", name, extension) : "");
    }

    private parseData(hash d, XsdLateResolverHelper unresolved) {
        delete d.ns;
        if (d.annotation) {
            *hash ah = remove d.annotation;
            if (ah.size() == 1 && ah.firstKey() =~ /documentation$/)
                documentation = trim(ah.firstValue());
        }
        if (!d)
            return;

        parseAttributes(\d, unresolved);

        if (!d) {
            cx_type = XET_NONE;
            required = True;
            requires_value = False;
            return;
        }

        if (d.size() > 1)
            throw WSDL_ERROR, sprintf("%s: expecting a single element in the complexType hash, got: %y", name, d.keys());

        string k = d.firstKey();
        if (k == "all") {
            cx_type = XET_ALL;
            WSDL::XsdBase::removeNS(\d.all);
            elementmap = parseElements(d.all.element, unresolved);
        }
        else if (k == "choice") {
            cx_type = XET_CHOICE;
            WSDL::XsdBase::removeNS(\d.choice);
            elementmap = parseElements(d.choice.element, unresolved);
        }
        else if (k == "sequence") {
            cx_type = XET_SEQUENCE;
            WSDL::XsdBase::removeNS(\d.sequence);
            if (d.sequence.element)
                elementmap = parseElements(d.sequence.element, unresolved);
            WSDL::XsdBase::removeNS(\d.sequence.choice);
            foreach hash ch in (d.sequence.choice) {
                #printf("ch: %y\n", ch);
                *hash h = parseElements(ch.element, unresolved, False);
                if (h) {
                    hash ech.elementmap = h;
                    if (ch."^attributes^".minOccurs > 0)
                        ech.required = True;
                    choices += ech;
                }
            }
        }
        else
            throw "XSD-COMPLEXTYPE-ERROR", sprintf("unknown keys in %y", d);
    }

    private parseAttributes(reference d, XsdLateResolverHelper unresolved) {
        # process attributes if any
        foreach hash ah in (remove d.attribute) {
            if (ah."^attributes^") {
                XsdAttribute attr(ah, nsc, NOTHING, unresolved);
                attrs.(attr.name) = attr;
            }
        }

        if (d.hasKey("anyAttribute")) {
            anyAttribute = True;
            delete d.anyAttribute;
        }
    }

    bool isNillable() {
        return nillable;
    }

    bool isRequired() {
        return required;
    }

    bool requiresValue() {
        return requires_value;
    }

    private *hash parseElements(softlist el, XsdLateResolverHelper unresolved, bool for_object = True) {
        #printf("DEBUG: XsdComplexType::parseElements(%y)\n", el);
        hash h;
        foreach hash e in (el) {
            #printf("DEBUG: XsdComplexType::parseElements() ns: %y e: %y\n", nsc.getTargetNamespaceUri(), e);
            XsdElement elem(e, nsc, NOTHING, unresolved, usedocns);
            h.(elem.name) = elem;

            if (for_object && !required && elem.isRequired())
                required = True;
        }

        if (for_object) {
            if (h.size() == 1 && h.firstValue().isNillable())
                nillable = True;
        }

        if (for_object && required && !nillable)
            requires_value = True;

        return h;
    }

    private *hash serializeElement(string key, XsdElement element, any h, *softbool omitType) {
        any v = h{key};
        string e_ons;
        #printf("DEBUG: XsdComplexType::serializeElement() key: %y v: %y h: %y ns: %y\n", key, v, h, nsc.getTargetNamespaceUri());
        any e = element.serialize(v, omitType, key, name);

        if (!exists e && !element.isRequired())
            return;

        /*
        if (e_ons != ons && e_ons != "xsd") {
            if (e.typeCode() != NT_HASH)
                e = ("^value^": e);
            e."^attributes^" = ("xmlns": nsc.getOutputNamespaceUri(ons));
        }
        */

        hash rv.(!usedocns ? key : (nsc.getOutputNamespacePrefix(element.ns) + ":" + key)) = e;
        return rv;
    }

    *hash serialize(any h, *softbool omitType, *softbool keepBinary) {
        if (exists array)
            return array.serialize(h, omitType);

        # process attributes first
        *hash ah;
        hash rh;
        if (h.typeCode() == NT_HASH) {
            if (h."^attributes^") {
                hash mah = remove h."^attributes^";
                foreach string k in (mah.keyIterator()) {
                    if (!attrs{k})
                        throw SOAP_SERIALIZATION_ERROR, sprintf("cannot set unknown attribute %y of element %y; known attributes: %y", k, getName(), attrs.keys());
                    if (attrs{k}.use == "prohibited")
                        throw SOAP_SERIALIZATION_ERROR, sprintf("cannot set attribute %y of element %y; the WSDL marks this attribute as prohibited", k, getName());
                    ah{k} = mah{k};
                }
            }
            # check for required attributes
            foreach XsdAttribute attr in (attrs.iterator()) {
                if (attr.use == "required" && !exists ah.(attr.name))
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y without attribute %y; the WSDL marks this attribute as required", getName(), attr.name);
            }
            foreach string k in (h.keyIterator()) {
                if (k =~ /^\^comment/) {
                    rh{k} = remove h{k};
                }
            }
        }


        if (cx_type == XET_SIMPLE) {
            if (exists h."^value^")
                h = h."^value^";
            rh."^value^" = simpleType.serialize(h, omitType);
        }
        else if (cx_type != XET_NONE) {
            if (exists h && h.typeCode() != NT_HASH)
                throw SOAP_SERIALIZATION_ERROR, sprintf("expecting hash argument to serialize from complexType %y (got %y, type %y)", getName(), h, type(h));

            if (cx_type == XET_SEQUENCE || cx_type == XET_ALL) {
                foreach string p in (elementmap.keyIterator()) {
                    #printf("DEBUG element: %y (%y)\nvalue: %y\n", p, elementmap{p}, h{p});
                    rh += serializeElement(p, elementmap{p}, h, omitType);
                    delete h{p};
                }

                # when generating example messages we need generate all choices, in this case extra ^choices^ tag is used
                # choice name is unique in element so ne merge all choices together first
                *hash hch;
                foreach string k in (h.keyIterator()) {
                    if (k =~ /^\^choices/) {
                        hch += remove h{k};
                    }
                }
                # also serialize each choice block, if any
                foreach hash ch in (choices) {
                    *hash vh = h.(ch.elementmap.keys());
                    *hash vhch = hch.(ch.elementmap.keys());
                    if (!vh && !vhch) {
                        if (ch.required)
                            throw SOAP_SERIALIZATION_ERROR, sprintf("expecting one of %y to serialize choice / union in complexType %y but no such keys were supplied", ch.elementmap.keys(), getName());
                    }
                    else {
                        if (vh) {
                            rh += serializeChoice(ch.elementmap, vh, omitType, False);
                            # remove the serialized key from the input hash for the check below
                            map remove h{$1}, keys vh;
                        }
                        if (vhch) {
                            rh += serializeChoice(ch.elementmap, vhch, omitType, True);
                            map remove hch{$1}, keys vhch;
                        }
                    }
                }

                if (h) {
                    any kl = h.size() == 1 ? h.firstKey() : h.keys();
                    throw SOAP_SERIALIZATION_ERROR, sprintf("%y %s of type %y (valid elements: %y)", kl, kl.lsize() == 1 ? "is an invalid member" : "are invalid members", getName(), elementmap.keys());
                }
                if (hch) {
                    throw SOAP_SERIALIZATION_ERROR, sprintf("unknown choice members %y provided via ^choices^ in %y", keys hch, getName());
                }
            }
            else { # "choice" - union
                rh = serializeChoice(elementmap, h, omitType, False);
            }
        }
        else { # "none"
            rh."^value^" = NOTHING;
        }

        #printf("DEBUG name: %y desc: %y\n", name, descriptive_name);
        if (name && !omitType && !descriptive_name)
            rh."^attributes^" += ("xsi:type": "ns1:" + name) + ah;
        else if (ah)
            rh."^attributes^" += ah;
        #printf("DEBUG complex type %s returning %y from %y\n", name, rh, h);
        return rh;
    }

    private hash serializeChoice(hash emap, hash h, *softbool omitType, bool all_members) {
        # normally there is only one choice but we also need output example message where all options are enumerated
        if (!all_members && elements h > 1)
            throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize choice / union in complexType %y with more than 1 member (%y)", getName(), h.keys());
        *hash rh;
        foreach string key in (keys h) {
            if (!emap{key})
                throw SOAP_SERIALIZATION_ERROR, sprintf("%y is an invalid member of choice / union in complexType %y; expecting one of: %y", key, getName(), emap.keys());

            # add namespace if necessary
            rh += serializeElement(key, emap{key}, h, omitType);
        }
        # add namespace if necessary
        return rh;
    }

    *hash deserialize(string en, *TypeMap tmap, *hash mrh, any oval) {
        if (exists array)
            return array.deserialize(en, tmap, mrh, oval);

        if (!exists oval) {
            if (!required)
                return;
        }

        hash rh;

        *hash val = oval;
        *hash attr = val."^attributes^";

        # attribute hash
        *hash ah;
        if (attr) {
            # parse incoming valid attributes
            foreach XsdAttribute xa in (attrs.iterator()) {
                *string attr_val = val."^attributes^".(xa.name);
                if (xa.use == "required" && !exists attr_val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y without attribute %y; the WSDL marks this attribute as required", getName(), xa.name);
                if (exists attr_val) {
                    if (attr.use == "prohibited")
                        throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y with attribute %y; the WSDL marks this attribute as prohibited", getName(), xa.name);
                    ah.(xa.name) = xa.getValue(attr_val);
                }
            }

            delete val."^attributes^";

            # ensure types match
            *string tn = attr."xsi:type";
            if (exists tn) {
                (*string ns, *string tname) = tn =~ x/(.*):(.*)/;
                if (exists tname)
                    tn = tname;
                if (tn != name) {
                    # check for compatible extension
                    *XsdAbstractType t = tmap.tryGet(tn);
                    #printf("DEBUG: type provided %y: %y\n", tn, t.name);
                    if (t) {
                        t.checkExtends(self, en);
                        return t.deserialize(en, tmap, mrh, oval);
                    }

                    throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting ComplexType type %y for element %y, got %y", getName(), en, tn);
                }
            }
        }

        if (val.typeCode() == NT_HASH) {
            WSDL::XsdBase::removeNS2(\val);

            #any ns = val.".ns";
            val -= ".ns";
        }

        if (cx_type == XET_SIMPLE) {
            if (!exists val && !required)
                return;
            any sv = simpleType.deserialize(name, tmap, mrh, val);
            if (sv.typeCode() == NT_HASH)
                rh = sv;
            else
                rh."^value^" = sv;
        }
        else if (cx_type != XET_NONE) {
            if (exists val && val.typeCode() != NT_HASH)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y type %y from qore type %y (expecting hash)", en, getName(), val.type());

            if (cx_type == XET_SEQUENCE || cx_type == XET_ALL) {
                #printf("XsdComplexType::deserialize() name: %y val: %y required: %y\n", getName(), val, required);
                # if we have one element
                if (elementmap.size() == 1 && val.size() == 1
                    && val.firstKey() == elementmap.firstKey()
                    && !exists val{elementmap.firstKey()} && !required && !choices)
                    return;

                foreach string p in (elementmap.keyIterator()) {
                    #printf("element %y\n", p);
                    rh{p} = elementmap{p}.deserialize(tmap, mrh, getValue(mrh, val{p}), val.hasKey(p));
                    delete val{p};
                }
                # also parse each choice block, if any
                foreach hash ch in (choices) {
                    *hash vh = val.(ch.elementmap.keys());
                    *hash h = parseChoice(vh, ch.elementmap, en, tmap, mrh, ch.required);
                    if (h)
                        rh += h;
                    delete val.(h.keys());
                    #printf("choice em: %y h: %y\n", ch.elementmap.keys(), h);
                }
                delete val."^attributes^";
                if (val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("invalid element %y passed in type %y for element %y (expecting %y)", (keys val)[0], getName(), en, keys elementmap);
            }
            else { # "choice" - union
                rh += parseChoice(val, elementmap, en, tmap, mrh, True);
            }
        }

        if (ah)
            rh."^attributes^" = ah;
        return rh;
    }

    private *hash parseChoice(hash val, hash emap, string en, *TypeMap tmap, *hash mrh, *bool required) {
        list kl = val.keys();
        if (elements kl > 1)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("too many elements supplied for choice / union in type %y for element %y (%y)", getName(), en, kl);
        *string key = kl[0];
        if (!exists key) {
            if (required)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("missing element for choice / union in type %y for element %y (expecting one of: %y)", getName(), en, emap.keys());
            return;
        }
        if (!exists emap{key})
            throw SOAP_DESERIALIZATION_ERROR, sprintf("element %y is not a valid element for choice / union in type %y for element %y (valid elements: %y)", key, getName(), en, emap.keys());

        return (key: emap{key}.deserialize(tmap, mrh, getValue(mrh, val{key}), val.hasKey(key)));
    }
}

#! web service operation class
public class WSDL::WSOperation inherits WSDL::XsdNamedData {
    public {
        WSMessage input;
        WSMessage output;
        *string input_name;
        *string output_name;
        TypeMap tmap;

        Namespaces nsc;

        *string soapAction;  # TODO: remove   SoapHandler, SoapClient
        *string request_name;

        # params per associated binding
        hash bindings;
    }

    constructor(any p, TypeMap n_tmap, Namespaces n_nsc, *hash messages) : XsdNamedData(\p) {
        tmap = n_tmap;
        nsc = n_nsc;

        if (p.input) {
            hash msghash = processNSValue(p.input."^attributes^");

            *WSMessage msg = messages.(msghash.message.val);
            if (!msg)
                throw WSDL_ERROR, sprintf("missing definition for input message %y required by operation %y", msghash.name.val, name);
            input = msg;

            #printf("DBG: WSOperation::constructor() name: %y msghash: %y\n", name, msghash);
            if (msghash.name)
                input_name = msghash.name.val ? msghash.name.val : msghash.name;
        }

        if (p.output) {
            hash msghash = processNSValue(p.output."^attributes^");

            *WSMessage msg = messages.(msghash.message.val);
            if (!msg)
                throw WSDL_ERROR, sprintf("missing definition for output message %y required by operation %y", msghash.name.val, name);

            output = msg;
            if (msghash.name)
                output_name = msghash.name.val ? msghash.name.val : msghash.name;
        }

        *string op_ns = nsc.getTargetNamespaceUri();
        if (op_ns && op_ns !~ /\/$/)
            op_ns += "/";
        soapAction = op_ns ? op_ns + name : name;
    }

    setDocStyle(reference idocmap) {
        # docstyle = True;  # property per binding

        foreach string key in (input.args.keyIterator()) {
            # FIXME: could be a type here instead of an element
            if (!input.args{key}.element.name) {
                return;
            }

            string element = input.args{key}.element.name;
            idocmap{element} = input.args{key}.element;
            if (!request_name)
                request_name = element;   # TODO: should not affect operation when calling from binding ??
        }
    }

    setTopLevelRequestElement(string name) {
        request_name = name;
    }

    string getTopLevelRequestName() {
        return request_name ? request_name : name;
    }

    /** @param name the name of the binding, if not provided then uses the first assigned binding

        @return a binding param hash

        @throw WSDL-BINDING-ERROR unknown binding
     */
    hash getBinding(*string bname) {
        if (bindings && !exists bname)
            return bindings.firstValue();
        if (!exists bindings{bname})
            throw "WSDL-BINDING-ERROR", sprintf("binding %y is not a known binding for operation %y; known bindings: %y", bname, name, bindings.keys());
        return bindings{bname};
    }

    /** @param bname binding name, must be unique in operation
        @param opparams binding getOperationParams

        @throw WSDL-BINDING-ERROR when binding already registered
     */

    addBinding(string bname, hash opparams) {
        if (bindings{bname}) {
            throw "WSDL-BINDING-ERROR", sprintf("binding %y is already registered in operation %y", bname, name);
        }
        opparams.name = bname;
        bindings{bname} = opparams;
    }

    private hash serializeSoapMessage(any h, hash binding, *hash header, *hash nsh, bool request, bool soap12, reference mpm) {
        string io = request ? "input" : "output";
        # setup namespaces for SOAP envelope
        hash rh = nsc.hasSoap12() ? WSDL::ENVELOPE_12_NS : WSDL::ENVELOPE_11_NS;
        string soapenvEnvelope = rh.firstKey();
        rh{soapenvEnvelope}."^attributes^" += nsc.getOutputNamespaceHash(nsh);
        if (header) {
            #printf("DEBUG: %s, header: %y\n", io, header);
            hash outh;
            *hash header2 = header;  # non processed values will be added to soap header
            foreach hash hdr in (binding{io}.header) {
                /*printf("DEBUG: hdr.message/part/msgpart: %y/%y/%y, exists: %y,%y,%y,%y, %y\n", hdr.message, hdr.part, hdr.msgpart,
                       exists header{hdr.message}, exists header{hdr.message}{hdr.part},
                       exists header{hdr.message}{hdr.msgpart}, exists header{hdr.part}, exists header{hdr.msgpart}
                );*/
                # there is not unique part name space as it may contain parts from more message so let's do a little heuristic
                any hh;
                if (exists header{hdr.message} && exists header{hdr.message}{hdr.part}) {
                    hh = header{hdr.message}{hdr.part};
                    remove header2{hdr.message}{hdr.part};
                    if (!header2{hdr.message}) {
                        remove header2{hdr.message};
                    }
                } else if (exists header{hdr.message} && exists header{hdr.message}{hdr.msgpart}) {
                    hh = header{hdr.message}{hdr.msgpart};
                    remove header2{hdr.message}{hdr.msgpart};
                    if (!header2{hdr.message}) {
                        remove header2{hdr.message};
                    }
                } else if (exists header{hdr.part}) {
                    hh = header{hdr.part};
                    remove header2{hdr.part};
                } else if (exists header{hdr.msgpart}) {
                    hh = header{hdr.msgpart};
                    remove header2{hdr.msgpart};
                }
                if (hh) {
                    hash hh2.(hdr.msgpart) = hh;
                    #printf("DEBUG: serialize(%y,%y)\n", hdr.msgpart, hh2);
                    if (binding.docstyle) {
                        hash h = hdr.msg.serializeDocument(hdr.msgpart, NOTHING, NOTHING, hh2); # does not work at least for non-elements
                        remove h."^attributes^".("soapenv:encodingStyle", "xmlns:soapenc");
                        outh += h;
                    } else {
                        hash h = hdr.msg.serialize(hdr.msgpart, NOTHING, NOTHING, hdr.msgpart, hh2); # TODO: it does no add types
                        #printf("DEBUG: result: %y\n", h);
                        # tricky part, flatten hash, TODO: make it more transparently
                        string fk = h.firstKey();
                        h{fk} = h.firstValue().firstValue();   # "ns1:name" : ("ns1: name" | "name": val) -> "ns1:name": val
                        #printf("DEBUG: flatten result: %y\n", h);
                        if (exists outh{fk}) {
                            # it could in theory happoen when two message parts are equal
                            if (outh{fk}.typeCode() != NT_LIST) {
                                outh{fk} = () + outh{fk};
                            }
                            outh{fk} += h{fk};
                        } else {
                            outh += h;
                        }
                    }
                }
            }
            if (header2) {
                # append unprocessed values
                outh += header2;
            }
            #printf("DEBUG: outh: %y\n", outh);
            rh{soapenvEnvelope}."soapenv:Header" = outh;
        }

        # do we have mime/multipart io format?
        if (exists binding{io}.multipart)
            mpm = new MultiPartRelatedMessage();

        #printf("DEBUG: docstyle: %y\n", binding.docstyle);
        if (self{io}) {
            *hash body;
            if (binding.docstyle)
                body = self{io}.serializeDocument(NOTHING, binding{io}, mpm, h);
            else {
                string mname = input_name ? input_name : name + (request ? "":"Response");
                if (binding{io})
                    body = self{io}.serialize(NOTHING, binding{io}, mpm, mname, h);
            }
            if (body) {
                rh{soapenvEnvelope}."soapenv:Body" = body;
            }
        } else if (exists h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("%s value provided for operation %y with no %s message (%y)", request?"request":"response", name, io, h);

        return rh;
    }


    private *data serializeHttpMessage(any h, hash binding, bool request, reference ct, reference enc) {
        string io = request ? "input" : "output";
        if (binding{io}.content.formUrlEncoded) {
            ct = MimeTypeFormUrlEncoded;
            # application/x-www-form-urlencoded Content-Type does not have any parameters
            delete enc;
            # TODO: throws exception when character is > 127, discussed e.g. https://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm
            return mime_get_form_urlencoded_string(self{io}.getNameValue(NOTHING, h));
        } else if (binding{io}.content) {
            hash v = self{io}.resolveValue(binding{io}.content.part, h, True);
            if (v."content-type") {
                if (!binding{io}.content.acceptAllContentTypes) {
                    WSDLLib::checkContentType(v."content-type", binding{io}.content.acceptedContentTypeSubtypes + binding{io}.content.acceptedContentTypes);
                }
                ct = v."content-type";
            } else {
                if (binding{io}.content.acceptAllContentTypes || binding{io}.content.acceptedContentTypes || binding{io}.content.acceptedContentTypeSubtypes.size() != 1) {
                    throw SOAP_SERIALIZATION_ERROR, sprintf("ambiguous content type in message %y related to %s operation %y", self{io}.name, io, name);
                }
                ct = binding{io}.content.acceptedContentTypeSubtypes[0];
            }
            if (v.value.typeCode() == NT_BINARY) {
                delete enc;
                return v.value;
            } else {
                return convert_encoding(v.value, enc);
            }
        }
    }

    #! serializes path part of URL when urlEncoded WSDL is defined
    *string serializePath(any h, hash binding) {
        string path;
        if (binding.location) {
            path = binding.location;
            if (binding.input.urlReplacement) {
                path = "";
                foreach string k in (keys binding.input.urlReplacement) {
                    if (k =~ /^string/) {
                        path += binding.input.urlReplacement{k};
                    } else if (k =~ /^part/) {
                        if (!input) {
                            throw SOAP_SERIALIZATION_ERROR, sprintf("url replacement requested for operation %s with no message (%y)", name, h);
                        }
                        hash v = input.getNameValue(binding.input.urlReplacement{k}, h);
                        path += encode_url(string(v.firstValue()), True);
                    }
                }
            } else if (binding.input.urlEncoded) {
                string s = mime_get_form_urlencoded_string(input.getNameValue(NOTHING, h));
                if (s) {
                    path += binding.location =~ /\?/ ? "&" : "?";
                    path += s;
                }
            }
        }
        return path;
    }

    #! serializes a request to an XML string or HTTP payload for the operation.
    /** @param h the request to serialize
        @param bname SOAP binding name or empty to get the first assigned binding
        @param header optional soap header info to serialize if required (ex: authorization info). In the first step headers are matched to binding/input/header WSDL definition, remaining headers are passed as-is
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @param nsh an optional namespace hash for the output message
        @param xml_opts optional XML generation options
        @param req_soapaction if present will override any SOAPAction value for the request

        @return a hash with keys:
        - \c body: XML string in the SOAP request format or body part of HTTP message (string or binary). Target content type is evaluated from WSDL or in case of ambiguity
        using "^attributes^"."^content-type^". Provided content type must match allowed types in WSDL. Also "application/x-www-form-urlencoded" or any general type are supported.
        - \c hdr: hash of HTTP headers
        - \c path: the path part of URL. Used when urlEncoded is defined
        - \c method: the HTTP request method
        */
    hash serializeRequest(any h, *string bname, *hash header, *string enc, *hash nsh, *int xml_opts, *string req_soapaction) {
        hash binding = getBinding(bname);

        if (!exists req_soapaction)
            req_soapaction = bindings{name}.soapAction;

        string ct;
        if (nsc.hasSoap12()) {
            ct = MimeTypeSoapXml;
            if (req_soapaction)
                ct += sprintf(";action: %s", req_soapaction);
        } else
            ct = MimeTypeXml;

        enc = enc ?? get_default_encoding();

        hash rv = (
            "path": serializePath(h, binding),
            "method": binding.httpMethod ?? "POST",
        );

        if (binding.httpMethod) {
            rv.body = serializeHttpMessage(h, binding, True, \ct, \enc);
        } else {
            MultiPartRelatedMessage mpm;
            rv.body = make_xml(serializeSoapMessage(h, binding, header, nsh, True, nsc.hasSoap12(), \mpm), xml_opts, enc);
            if (mpm) {
                mpm.splicePart(rv.body, sprintf("<%s>", binding.input.body.parts), nsc.hasSoap12() ? MimeTypeSoapXml : MimeTypeXml);

                hash rv = mpm.getMsgAndHeaders();
                if (req_soapaction) {
                    if (nsc.hasSoap12())
                        ct += sprintf(";action: %s", req_soapaction);
                }
            }
        }

        if (exists enc) {
            ct += sprintf(";charset=%s", enc);
        }
        rv.hdr."Content-Type" = ct;

        if (req_soapaction)
            rv.hdr += ("SOAPAction": req_soapaction);

        return rv;
    }

    hash serializeRequest(any h, *hash header, *string enc, *hash nsh, *int xml_opts, *string req_soapaction) {
        return serializeRequest(h, NOTHING, header, enc, nsh, xml_opts, req_soapaction);
    }

    #! serializes a SOAP response to an XML string for the operation
    /** @param h the response to serialize
        @param bname SOAP binding name, leave empty to get the first assigned binding
        @param header SOAP header hash. In the first step headers are matched to binding/input/header WSDL definition, remaining headers are passed as-is
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @param nsh namespace hash
        @param soap12 set to True if the response should use SOAP 1.2 encoding
        @param xml_opts optional XML generation options

        @return a hash with keys:
        - \c body: XML string in the SOAP request format or body part of HTTP message (string or binary). Target content type is evaluated from WSDL or in case of ambiguity
        using "^attributes^"."^content-type^". Provided content type must match allowed types in WSDL.
        - \c hdr: hash of HTTP headers
    */
    hash serializeResponse(any h, *string bname, *hash header, *string enc, *hash nsh, *bool soap12, *int xml_opts) {
        hash binding = getBinding(bname);
        if (exists soap12) {
            if (soap12) {
                if (!nsc.hasSoap12())
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize response for operation %y with SOAP 1.2 encoding; this operation does not support SOAP 1.2", name);
            }
            else {
                if (!nsc.hasSoap11())
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize response for operation %y with SOAP 1.1 encoding; this operation does not support SOAP 1.1", name);
            }
        }
        else
            soap12 = nsc.hasSoap12();

        enc = enc ?? get_default_encoding();
        hash rv;
        string ct;

        if (binding.httpMethod) {
            rv.body = serializeHttpMessage(h, binding, False, \ct, \enc);
        } else {
            MultiPartRelatedMessage mpm;
            # do we have mime/multipart output format?
            if (exists binding.output.multipart)
                mpm = new MultiPartRelatedMessage();

            rv.body = make_xml(serializeSoapMessage(h, binding, header, nsh, False, soap12, \mpm), xml_opts, enc);

            ct = soap12 ? MimeTypeSoapXml : MimeTypeXml;
            if (exists mpm) {
                mpm.splicePart(rv.body, sprintf("<%s>", binding.output.body.parts), ct);
                return mpm.getMsgAndHeaders();
            }
        }

        if (exists enc) {
            ct += sprintf(";charset=%s", enc);
        }

        rv.hdr = ("Content-Type": ct);
        return rv;
    }

    hash serializeResponse(any h, *hash header, *string enc, *hash nsh, *bool soap12, *int xml_opts) {
        return serializeResponse(h, NOTHING, header, enc, nsh, soap12, xml_opts);
    }

    private list processMultiRef(hash body) {
        # setup message info hash and multiRef lookup hash key, if any are present
        hash mrh = (
            # save original msg body hash
            "body": body,
            );
        # remove namespacr prefixes from body element keys
        WSDL::XsdBase::removeNS2(\mrh.body);

        if (body.multiRef) {
            foreach any mr in (body.multiRef)
                mrh.mrh.(mr."^attributes^".id) = mr;

            # resolve interior references to multiRefs
            foreach string id in (mrh.mrh.keyIterator()) {
                foreach string key in (mrh.mrh{id}.keyIterator()) {
                    if (key == "^attributes^")
                        continue;

                    #printf("multiRef id: %y key: %y val: %y\n", id, key, mrh.mrh{id}{key});

                    if (mrh.mrh{id}{key}.typeCode() == NT_LIST) {
                        foreach any e in (\mrh.mrh{id}{key}) {
                            any href = substr(e."^attributes^".href, 1);
                            if (exists href) {
                                if (!exists mrh.mrh{href})
                                    throw "INVALID-MULTIREF", sprintf("multiRef id: %y does not exist", href);
                                e = mrh.mrh{href};
                            }
                        }
                    }
                    else if (mrh.mrh{id}{key}.typeCode() == NT_HASH) {
                        any href = substr(mrh.mrh{id}{key}."^attributes^".href, 1);
                        if (exists href) {
                            if (!exists mrh.mrh{href})
                                throw "INVALID-MULTIREF", sprintf("multiRef id: %y does not exist", href);
                            mrh.mrh{id}{key} = mrh.mrh{href};
                        }
                    }
                }
            }

            delete body.multiRef;
        }
        #printf("mrh: %y\n", mrh.mrh);
        #printf("operation: %y\n", self);

        # remove namespace tags from element names
        WSDL::XsdBase::removeNS2(\body);
        remove body.".ns";

        return (mrh, body);
    }

    private any deserializeSoapMessage(hash o, hash binding, bool request) {
        #printf("DEBUG: deserializeSoapMessage(%N, %y)\n", o, request);
        string io = request ? "input" : "output";
        WSDL::XsdBase::removeNS2(\o);
        WSDL::XsdBase::removeNS2(\o.Envelope);
        hash rv;
        if (binding{io}.header) {
            *hash header = o.Envelope.Header;
            WSDL::XsdBase::removeNS2(\header);

            #printf("DEBUG: Deserialize SOAP headers: %N\n", header);
            hash hrv;
            foreach hash hdr in (binding{io}.header) {
                if (header.hasKey(hdr.msgpart)) {
                    # seems it may appear part name conflict between messages when namespace is stripped
                    hash v;
                    if (binding.docstyle) {
                        hrv{hdr.msg.name} += hdr.msg.deserializeDocument(NOTHING, header, hdr.msgpart, True);
                    } else {
                        hrv{hdr.msg.name} += hdr.msg.deserialize(NOTHING, header, hdr.msgpart, True);
                    }
                }
            }
            #printf("DEBUG: Deserialized SOAP headers: %N\n", hrv);
            if (exists hrv) {
                rv."^header^" = hrv;
            }
        }

        *hash body = o.Envelope.Body;

        if (!self{io}) {
            if (exists body)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("%s value given for operation %y with no %s message: %y", request ? "request" : "response", name, io, body);
            return rv;
        }
        else if (!exists body)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("no %s body value given for operation %y", request ? "request" : "response", name);

        (*hash mrh, hash msg) = processMultiRef(body);

        if (!request) {
            # check for Soap Fault, if so raise an exception immediately with the fault info
            WSDL::XsdBase::removeNS2(\body);

            if (body.Fault) {
                WSDL::XsdBase::removeNS(\body.Fault);
                delete body.Fault.".ns";
                if (nsc.hasSoap12()) {
                    WSDL::XsdBase::removeNS(\body.Fault.Code);
                    WSDL::XsdBase::removeNS(\body.Fault.Reason);
                    string desc = sprintf("The following fault response was received from the server: code: %y", body.Fault.Code.Value);
                    any sc = body.Fault.Code.Subcode;
                    while (exists sc) {
                        WSDL::XsdBase::removeNS(\sc);
                        desc += sprintf(", subcode: %y", sc.Value);
                        sc = sc.Subcode;
                    }
                    foreach any rn in (body.Fault.Reason.Text) {
                        desc += sprintf(", text: %y", rn);
                    }

                    throw "SOAP-SERVER-FAULT-RESPONSE", desc, body.Fault;
                }
                else {
                    string desc = sprintf("The following fault response was received from the server: code: %y", body.Fault.faultcode);
                    if (exists body.Fault.faultstring)
                        desc += sprintf(", faultstring: %y", body.Fault.faultstring);
                    if (exists body.Fault.desc)
                        desc += sprintf(", desc: %y", body.Fault.desc);

                    throw "SOAP-SERVER-FAULT-RESPONSE", desc, body.Fault;
                }
            }
        }

        #any ns = msg.".ns";
        msg -= ("ns", ".ns");
        if (binding.docstyle) {
            if (exists rv) {
                return rv + self{io}.deserializeDocument(mrh, msg, NOTHING, True);
            } else {
                return self{io}.deserializeDocument(mrh, msg);
            }
        }

        string mname = input_name ? input_name : name + (request ? "" : "Response");
        if (!msg{mname})
            throw SOAP_DESERIALIZATION_ERROR, sprintf("missing %s message name %y as top-level element; got elements: %y", io, mname, keys msg);
        msg = remove msg{mname};
        XsdBase::removeNS2(\msg);
        msg -= (".ns", "ns");

        if (exists rv) {
            return rv + self{io}.deserialize(mrh, msg, NOTHING, True);
        } else {
            return self{io}.deserialize(mrh, msg);
        }
    }

    private *hash deserializeHttpMessage(hash v, hash binding, bool request) {
        string io = request ? "input" : "output";
        *string ct = v."content-type";
        if (!exists ct) {
            throw SOAP_DESERIALIZATION_ERROR, sprintf("missing content-type in input hash: %y", v);
        }
        if (binding{io}.urlEncoded) {
            throw SOAP_DESERIALIZATION_ERROR, sprintf("urlencoded message deserialization is not supported in binding: %y", binding.name);
        }
        if (binding{io}.content.formUrlEncoded) {
            WSDLLib::checkContentType(ct, list(MimeTypeFormUrlEncoded));
            v.body = binary_to_string(v.body);
            hash h = mime_parse_form_urlencoded_string(v.body); # TODO: data have no encoding
            return self{io}.deserialize(NOTHING, h, NOTHING, True);
        } else if (binding{io}.content) {

            if (!binding{io}.content.acceptAllContentTypes) {
                WSDLLib::checkContentType(ct, binding{io}.content.acceptedContentTypeSubtypes + binding{io}.content.acceptedContentTypes);
            }
            hash v2;
            v2{binding{io}.content.part} = v.body;
            hash h = self{io}.deserialize(NOTHING, v2, binding{io}.content.part, True);
            string k = h.firstKey();
            h{k}."^value^" = remove h{k};
            h{k}."^attributes^"."^content-type^" = ct;
            return h;
        }
    }

    #! parses a hash representing a parsed XML request (parsed with parseXMLAsData()) for the operation and returns the corresponding Qore data structure
    /** @param o the parsed SOAP or HTTP request with @ref WSDLLib::parseSOAPMessage() for the operation
        @param bname SOAP binding name, leave empty to use the first assigned binding
        @return the Qore data structure corresponding to the request data. When SOAP header is deserialized according binding/input WSDL then data are passed under "^header^" key.
        In case of HTTP binding the content type is matched against WSDL binding when wildcards are supported and current content type value is applied to "^attributes^"."^content-type^".
    */
    any deserializeRequest(hash o, *string bname) {
        hash binding = getBinding(bname);
        if (binding.httpMethod) {
            return deserializeHttpMessage(o, binding, True);
        } else {
            return deserializeSoapMessage(o, binding, True);
        }
    }

    #! parses a hash representing a parsed XML response (parsed with parse_xml()) for the operation and returns the corresponding Qore data structure
    /** @param o the parsed SOAP or HTTP request with @ref WSDLLib::parseSOAPMessage() for the operation
        @param bname SOAP binding name, leave empty to use the first assigned binding
        @return the Qore data structure corresponding to the response data. When SOAP header is deserialized according binding/output WSDL then data are passed under "^header^" key.
        In case of HTTP binding the content type is matched against WSDL binding when wildcards are supported and current content type value is applied to "^attributes^"."^content-type^".
    */
    any deserializeResponse(hash o, *string bname) {
        hash binding = getBinding(bname);
        if (binding.httpMethod) {
            return deserializeHttpMessage(o, binding, False);
        } else {
            return deserializeSoapMessage(o, binding, False);
        }
    }

    private hash processNSValue(hash h) {
        foreach string k in (keys h) {
            (*string ns, *string name) = h{k} =~ x/(\w+):(\w+)/;
            if (!name)
                h{k}.val = h{k};
            else {
                h{k}.ns = ns;
                h{k}.val = name;
            }
        }
        return h;
    }

    #! returns True if the operation is a SOAP 1.2 operation
    /** @return True if the operation is a SOAP 1.2 operation
    */
    bool isSoap12() {
        return nsc.hasSoap12();
    }

    #! returns the target namespace for the operation
    /** @return the target namespace for the operation
    */
    string getTargetNS() {
        return nsc.getTargetNamespaceUri();
    }
}

#! web service message class
public class WSDL::WSMessage inherits WSDL::XsdNamedData {
    public {
        hash args;
        # part map; maps element names to part names
        hash pmap;
        bool encoded = False;

        # keep a reference to Namespaces
        Namespaces nsc;

        # keep a reference to the type map
        TypeMap tmap;
    }

    constructor(hash m, ElementMap emap, TypeMap n_tmap, Namespaces n_nsc) : XsdNamedData(\m) {
        nsc = n_nsc;
        tmap = n_tmap;

        #printf("DEBUG: WSMessage::constructor() m: %y emap: %y\n", m, emap);

        name = m."^attributes^".name;
        foreach any p in (m.part) {
            any arg = p."^attributes^";
            if (arg.element) {
                (*string ns, *string ename) = arg.element =~ x/(\w+):(\w+)/;
                if (!ename)
                    ename = arg.element;

                if (arg.name && arg.name != ename)
                    pmap{ename} = arg.name;

                args{ename}.element = emap.get(nsc.getNamespaceUri(ns), ename);
            }
            else {
                args{arg.name} = arg;
                args{arg.name}.type = nsc.doType(p."^attributes^".type);
            }
        }
    }

    hash serialize(*string key, any msginfo, any mpm, string n_name, any h) {
        hash rh;
        #printf("DEBUG: message %s: h: %y\n", name ,h);

        foreach string k in (key ? key : args.keyIterator()) {
            any v;
            if (h.hasKey(k))
                v = remove h{k};
            else if (pmap{k} && !exists h{k})
                v = remove h.(pmap{k});

            /*
            if (!exists h{k}) {
                if (pmap{k} && !exists h{k})
                    h{k} = remove h.(pmap{k});
                else
                    throw SOAP_SERIALIZATION_ERROR, sprintf("missing message argument %y (got %y instead)", k, h.keys());
            }
            */

            any hv;
            #printf("DEBUG: arg %y with %y\n", k, args{k});
            #printf("DEBUG: arg %y with %y\n", k, v."^val^" ?? v);
            string ons;
            if (args{k}.element) {
                hv = args{k}.element.serialize(v, !encoded, k, name);
                ons = nsc.getOutputNamespacePrefix(args{k}.element.ns);
            }
            else {
                hv = args{k}.type.serialize(v, !encoded);
                ons = args{k}.type.getOutputNamespacePrefix();
            }
            #printf("DEBUG: arg %s got %y from %y (%y)\n", k, hv, v, exists args{k}.element ? args{k}.element : args{k}.type);

            #printf("DEBUG: WSMessage::serialize() k: %y args: %y, parts: %y\n", k, keys args, msginfo.parts);
            if (msginfo.parts{k}) {
                any ct = msginfo.parts{k};
                if (ct.typeCode() == NT_LIST)
                    ct = shift ct;
                mpm.addPart(hv, sprintf("<%s>", k), ct);
                hv."^attributes^".href = "cid:" + k;
            }

            string en = args{k}.element ? (ons + ":" +  k) : k;
            rh{en} = hv;
        }

        if (h.typeCode() == NT_HASH && h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", h.keys(), name);

        if (encoded)
            rh."^attributes^" += (
                "soapenv:encodingStyle": SOAP_ENCODING,
                "xmlns:soapenc": SOAP_ENCODING,
            );

        hash rvh.("ns1:" + n_name) = rh;

        return rvh;
    }

    hash serializeDocument(*string key, any msginfo, any mpm, any h) {
        hash rh;

        if (!key && args.size() == 1) {
            string key = args.firstKey();
            if (h.typeCode() != NT_HASH || !h.hasKey(key)) {
                hash nh;
                nh{key} = h;
                h = nh;
            }
        }
        foreach string k in (key ? key : args.keyIterator()) {
            any val = remove h{k};
            if (val.typeCode() == NT_HASH)
                XsdBase::removeNS2(\val);
            string ons;
            any th;
            if (args{k}.element) {
                th = args{k}.element.serialize(val, !encoded, k, name);
                ons = nsc.getOutputNamespacePrefix(args{k}.element.ns);
                rh.(ons + ":" + args{k}.element.name) = th;
            } else {
                th = args{k}.type.serialize(val, !encoded);
                #ons = args{k}.type.getOutputNamespacePrefix();
                rh.("ns1:" + args{k}.name) = th;
            }
        }

        if (h.typeCode() == NT_HASH && h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", h.keys(), name);

        if (encoded)
            rh."^attributes^" += (
                "soapenv:encodingStyle": SOAP_ENCODING,
                "xmlns:soapenc": SOAP_ENCODING,
            );

        #printf("DEBUG: message %s: force_ns: %y args: %y h: %y\n", name, force_ns, keys args, h);

        return rh;
    }

    any deserialize(*hash mrh, hash val, *string key, bool keepHash = False) {
        #printf("DBG WSMessage::deserialize() args: %y pmap: %y val: %y\n", args.keys(), pmap, val); #XXX
        hash ro;

        foreach string k in (exists key ? key : args.keyIterator()) {

            bool present = val.hasKey(k);
            any v = remove val{k};
            if (v.typeCode() == NT_HASH)
                XsdBase::removeNS2(\v);

            string rk = k;
            if (pmap{k} && !args.(pmap{k}))
                rk = pmap{k};

            ro{rk} = args{k}.element
                ? args{k}.element.deserialize(tmap, mrh, getValue(mrh, v), present)
                : args{k}.type.deserialize(name, tmap, mrh, getValue(mrh, v));
        }

        if (val && !exists key)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", val.keys(), name);

        # if there is only one argument, return it directly
        return (ro.size() == 1 && !keepHash) ? ro.firstValue() : ro;
    }

    any deserializeDocument(*hash mrh, any val, *string key, bool keepHash = False) {
        hash rh;

        *hash attr = remove val."^attributes^";

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\n", args.keys(), val);

        if (args.size() == 1) {
            string k = args.firstKey();
            if (val.typeCode() != NT_HASH || !val.hasKey(k)) {
                any v = val;
                val = hash();
                val{k} = v;
            }
        }

        foreach string k in (exists key ? key : args.keyIterator()) {
            bool present = val.hasKey(k);
            any v = remove val{k};
            XsdBase::removeNS2(\v);

            string rk = k;
            if (pmap{k} && !args.(pmap{k}))
                rk = pmap{k};

            rh{rk} = args{k}.element ?
                args{k}.element.deserialize(tmap, mrh, v, present) :
                args{k}.type.deserialize(name, tmap, mrh, getValue(mrh, v));
        }

        if (val && !exists key)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", val.keys(), name);

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\nRH: %y\n", args.keys(), val, rh);
        return (rh.size() == 1 && !keepHash) ? rh.firstValue() : rh;
    }

    hash getNameValue(*string key, any h, *softbool keepBinary) {
        hash rv;
        foreach string k in (key ? key : args.keyIterator()) {
            hash v = resolveValue(k, h, keepBinary);
            rv{k} = v.value;
        }
        return rv;
    }

    hash resolveValue(string key, any h, *softbool keepBinary) {
        if (args{key}.element) {
            throw SOAP_SERIALIZATION_ERROR, sprintf("cannot get element value %y in message %y. Type part is needed", key, name);
        }
        hash rv;
        any v;
        if (h.hasKey(key))
            v = h{key};
        else if (pmap{key} && !exists h{key})
            v = h.(pmap{key});
        rv.value = args{key}.type.serialize(v, False, keepBinary){"^value^"};
        if (v.typeCode() == NT_HASH) {
            rv."content-type" = v."^attributes^"."^content-type^";
        }
        return rv;
    }
}

# private helper class for lazy name resolution
class WSDL::XsdLateResolverHelper {
    private { list l = (); }

    constructor() {
    }

    add(any v) {
        l += v;
    }

    list getList() {
        return l;
    }

    clearResolved() {
        l = map $1, l, !isResolved($1);
    }

    bool isResolved(XsdSimpleType t) {
        return t.type instanceof XsdData;
    }

    bool isResolved(XsdTypedData t) {
        return t.type instanceof XsdData;
    }

    bool isResolved(XsdComplexType t) {
        return t.simpleType instanceof XsdData;
    }

    bool isResolved(any t) {
        return False;
    }
}

#! class for WSDL bindings
public class WSDL::Binding inherits WSDL::XsdNamedData {
    private {
        string port;
        bool docstyle = False;
        *string httpMethod;
        *string soapTransport;
    }

    constructor(hash data, Namespaces nsc, reference portTypes, reference idocmap, *hash messages) : XsdNamedData(\data) {
        # get binding attributes
        {
            *hash ba = data."^attributes^";

            (*string ns, *string prt) = ba.type =~ x/(?:(\w+):)?(\w+)/;
            if (!prt)
                throw WSDL_ERROR, sprintf("missing port type for binding %y", name);
            port = prt;
        }

        if (data.binding) {
            *hash bba = data.binding."^attributes^";
            if (bba.verb) {
                # HTTP binding
                httpMethod = bba.verb;
            }

            if (bba.transport) {
                # SOAP binding
                if (!SOAP_TRANSPORT.(bba.transport))
                    throw WSDL_ERROR, sprintf("unsupported transport %y in binding %y (known transports: %y)", bba.transport, name, SOAP_TRANSPORT.keys());
                soapTransport = bba.transport;
            }
            if (!soapTransport && !httpMethod)
                throw WSDL_ERROR, sprintf("missing SOAP verb or transport in binding %y (known SOAP transports: %y)", name, SOAP_TRANSPORT.keys());

            if (bba.style == "document") {
                docstyle = True;
            }
        }

        foreach hash ophash in (data.operation) {
            string opname = ophash."^attributes^".name;

            if (!exists portTypes{port}.operations{opname})
                throw WSDL_ERROR, sprintf("binding %y references unknown porttype %y operation %y", name, port, opname);

            hash op;
            op.name = opname;
            WSDL::XsdBase::removeNS(\ophash);

            *string sa = ophash.operation."^attributes^".soapAction;
            if (exists sa) {
                #printf("GOT: %s sa: %y\n", opname, sa);
                op.soapAction = sa;
            } else {
                *string op_ns = portTypes{port}.operations{opname}.nsc.getTargetNamespaceUri();
                if (op_ns && op_ns !~ /\/$/)
                    op_ns += "/";
                op.soapAction = op_ns ? op_ns + opname : opname;
            }

            if (docstyle || ophash.operation."^attributes^".style == "document") {
                op.docstyle = True;
                portTypes{port}.operations{opname}.setDocStyle(\idocmap);  # TODO
            }

            if (httpMethod) {
                *string loc = ophash.operation."^attributes^".location;
                if (loc) {
                    op.location = loc;
                } else {
                    throw WSDL_ERROR, sprintf("location is missing binding %y, operation %y", name, opname);
                }
            }

            foreach string io in (("input", "output")) {
                if (ophash{io}) {
                    WSDL::XsdBase::removeNS(\ophash{io});
                    if (exists ophash{io}.body) {
                        # any pa = ophash{io}.body."^attributes^";
                        op{io}.body = ophash{io}.body."^attributes^";
                        op{io}.body.encoded = ophash{io}.body."^attributes^".use == "encoded";  # TODO: move to WSOperation

                        delete ophash{io}.body;
                    }

                    if (ophash{io}.("body", "content", "part") && !exists portTypes{port}.operations{opname}{io})
                        throw WSDL_ERROR, sprintf("cannot assign %s message definition in binding %y for operation %y with no %s: %y", io, name, opname, io, ophash);

                    if (exists ophash{io}.multipartRelated) {
                        if (exists op{io}.body)
                            throw WSDL_ERROR, sprintf("%s binding %y for operation %y specifies both body and multipart elements", io, name, opname);

                        op{io}.multipart = Mime::MPT_RELATED;
                        op{io}.parts = {};
                        WSDL::XsdBase::removeNS(\ophash{io}.multipartRelated);

                        if (!exists ophash{io}.multipartRelated.part)  # TODO: do I need explicite check or is is handled by validator ?
                            throw WSDL_ERROR, sprintf("binding %y is missing part definition(s) in %s message definition for operation %y: %y", name, io, opname, ophash);

                        foreach any part in (ophash{io}.multipartRelated.part) {
                            WSDL::XsdBase::removeNS(\part);
                            #any a = part."^attributes^";
                            part -= "^attributes^";
                            if (exists part.body) {
                                any pa = part.body."^attributes^";
                                if (pa.use != "literal")
                                    throw WSDL_ERROR, sprintf("unsupported body part without use=\"literal\": %y", part.body);

                                op{io}.body = pa;
                            } else if (exists part.content) {
                                foreach any c in (part.content) {
                                    WSDL::XsdBase::removeNS(\c);
                                    any pa = c."^attributes^";
                                    any name = pa.part;
                                    if (!exists name)
                                        throw WSDL_ERROR, sprintf("unsupported content part without part attribute: %y", c);
                                    any type = pa.type;
                                    if (!exists type)
                                        throw WSDL_ERROR, sprintf("unsupported content part without type attribute: %y", c);

                                    if (!exists op{io}.parts{name})
                                        op{io}.parts{name} = type;
                                    else {
                                        if (op{io}.parts{name}.typeCode() != NT_LIST)
                                            op{io}.parts{name} = list(op{io}.parts{name});
                                        op{io}.parts{name} += type;
                                    }
                                }
                            } else
                                throw WSDL_ERROR, sprintf("cannot parse part: %y", part);

                                #printf("DEBUG: part: %y\nmsg: %y\n", part, op{io});;
                        }
                        delete ophash{io}.multipartRelated;
                    }


                    if (exists ophash{io}.header) {
                        foreach hash hdr in (ophash{io}.header) {
                            *hash ma = hdr."^attributes^";

                            if (!ma.message)
                                throw WSDL_ERROR, sprintf("%s binding %y for operation %y specifies a soap header element without a 'message' attribute (attr: %y)", io, name, opname, ma);

                            if (!ma.part)
                                throw WSDL_ERROR, sprintf("%s binding %y for operation %y specifies a soap header element without a 'part' attribute (attr: %y)", io, name, opname, ma);

                            hash h = nsc.doType(ma.message);
                            *WSMessage msg = messages.(h.val);
                            if (!exists msg)
                                throw WSDL_ERROR, sprintf("%s binding %y for operation %y references unknown message %y in the soap header element", io, name, opname, h.val);

                            bool enc  = ma.use == "encoded";
                            if (enc != msg.encoded) {
                                ma.msg = msg.copy();
                                ma.msg.encoded = enc;
                            } else {
                                ma.msg = msg;
                            }
                            hash pmap2;
                            map pmap2{$1.value}=$1.key, msg.pmap.pairIterator();
                            ma.msgpart = pmap2{ma.part} ?? ma.part;
                            #printf("DEBUG: match part to message: part: %y, msg.pmap: %y->%y, ma.msgpart: %y\n", ma.part, msg.pmap, pmap2, ma.msgpart);
                            if (op{io}.header) {
                                if (op{io}.header.typeCode() != NT_LIST) {
                                    op{io}.header = () + op{io}.header;
                                }
                                op{io}.header += ma;
                            } else {
                                op{io}.header = ma;
                            }
                        }
                        delete ophash{io}.header;
                    }

                    if (ophash{io}.hasKey("urlReplacement")) {
                        string loc = op.location;
                        int i = 0;
                        hash l;
                        while (i < loc.size()) {
                            int j = index(loc, "(", i);
                            if (j < 0) {
                                j = loc.size();
                            }
                            if (j > i) {
                                l{sprintf("string^%d", l.size()+1)} = substr(loc, i, j-i);
                            }
                            if (j < loc.size()) {
                                i = j+1;
                                j = index(loc, ")", i);
                                if (j == i) {
                                    throw WSDL_ERROR, sprintf("empty replace token in %y near %y", loc, substr(loc, i-1, loc.size()));
                                } else if (j < 0) {
                                    throw WSDL_ERROR, sprintf("missing close parentheses in %y near %y", loc, substr(loc, i-1, loc.size()));
                                }
                                string p = substr(loc, i, j-i);
                                # if (messages)   TODO test messages / part here probably not ?
                                l{sprintf("part^%d", l.size()+1)} = p;
                                j++;
                            }
                            i = j;
                        }
                        op{io}.urlReplacement = l;
                        delete ophash{io}.urlReplacement;
                    }

                    if (ophash{io}.hasKey("urlEncoded")) {
                        op{io}.urlEncoded = True;
                        delete ophash{io}.urlEncoded;
                    }

                    if (exists ophash{io}.content) {
                        op{io}.content.acceptedContentTypes = ();  # type / *
                        op{io}.content.acceptedContentTypeSubtypes = ();  # type / subtype
                        *string p;
                        foreach any cnt in (ophash{io}.content) {
                            WSDL::XsdBase::removeNS(\cnt);
                            cnt = remove cnt."^attributes^";
                            bool isFormUrlEncoded = cnt.type == MimeTypeFormUrlEncoded;
                            if ((isFormUrlEncoded && op{io}.content.type) ||
                                (!isFormUrlEncoded && op{io}.content.formUrlEncoded)) {
                                throw WSDL_ERROR, sprintf("%y content type must be single in message %y", MimeTypeFormUrlEncoded, ophash{io}.content);
                            }
                            if (isFormUrlEncoded) {
                                op{io}.content.formUrlEncoded = True;
                                continue;
                            }

                            if (!cnt.type || cnt.type == "*/*") {
                                op{io}.content.acceptAllContentTypes = True;
                            } else {
                                hash act;
                                list st = cnt.type.split("/");
                                if (st.size() != 2) {
                                    throw WSDL_ERROR, sprintf("Content type %y does not match 'type/subtype' pattern", cnt.type);
                                }
                                if (bindex(st[0], "*") != -1) {
                                    throw WSDL_ERROR, sprintf("Content type %y contains unexpected asterisk in type part", cnt.type);
                                }
                                act.type = st[0];
                                if (st[1] == "*") {
                                    push op{io}.content.acceptedContentTypes, st[0]+"/";
                                } else {
                                    if (bindex(st[1], "*") != -1) {
                                        throw WSDL_ERROR, sprintf("Content type %y contains unexpected asterisk in subtype part", cnt.type);
                                    }
                                    push op{io}.content.acceptedContentTypeSubtypes, st[0]+"/"+st[1];
                                }
                            }

                            if (!exists cnt.part) {
                                cnt.part = "";
                            }
                            if (exists p && p != cnt.part) {
                                throw WSDL_ERROR, sprintf("ambiguous part %y in message %y in binding %y for %s operation %y", cnt.part, portTypes{port}.operations{opname}{io}.name, name, io, opname);
                            }
                            p = cnt.part;
                        }

                        if (exists p) {
                            if (p == "") {
                                if (portTypes{port}.operations{opname}{io}.args.size() != 1) {
                                    throw WSDL_ERROR, sprintf("multiple parts %y in message %y in binding %y for %s operation %y", keys portTypes{port}.operations{opname}{io}.args, portTypes{port}.operations{opname}{io}.name, name, io, opname);
                                }
                                p = portTypes{port}.operations{opname}{io}.args.firstKey();
                            } else {
                                if (!exists portTypes{port}.operations{opname}{io}.args{p}) {
                                    throw WSDL_ERROR, sprintf("missing part %y in message %y in binding %y for %s operation %y", p, portTypes{port}.operations{opname}{io}.name, name, io, opname);
                                }
                            }
                            op{io}.content.part = p;
                        }
                        delete ophash{io}.content;
                    }

                    delete ophash{io}.("^attributes^", "ns");

                    if (ophash{io}) {
                        throw WSDL_ERROR, sprintf("unknown element(s) in binding %y for %s operation %y: %y", name, io, opname, keys ophash{io});
                    }
                }
            }

            if (op.output.content.formUrlEncoded) {
                throw WSDL_ERROR, sprintf("%y type is not supported as output type in binding %y for output operation %y", MimeTypeFormUrlEncoded, name, opname);
            }

            portTypes{port}.operations{opname}.addBinding(name,
                (
                "httpMethod": httpMethod,
                "soapTransport": soapTransport,
                ) + op
            );
        }

        #binding = data;
    }


    string getPort() {
        return port;
    }
/*
    bool isSoapBinding() {
        return exists soapTransport;
    }

    bool isHttpBinding() {
        return exists httpMethod;
    }
    */
}

# private namespace prefix redefinition class
class WSDL::NamespacePrefixHelper {
    public {
    }

    private {
        Namespaces nsc;

        # overriden prefixes
        hash h;

        # overridden target namespace
        bool targ_ns;

        # overridden default namespace
        bool def_ns;
    }

    constructor(Namespaces n_nsc, *hash nsattr) {
        nsc = n_nsc;

        if (nsattr) {
            nsc.addNamespaces(nsattr, self);
            if (nsattr.targetNamespace) {
                nsc.pushTargetNamespace(nsattr.targetNamespace);
                targ_ns = True;
            }
            if (nsattr.xmlns) {
                nsc.pushDefaultNamespace(nsattr.xmlns);
                def_ns = True;
            }
        }
    }

    destructor() {
        if (def_ns)
            nsc.popDefaultNamespace();
        if (targ_ns)
            nsc.popTargetNamespace();
        if (h)
            nsc.restorePrefixes(h);
    }

    save(string k, string v) {
        h{k} = v;
    }
}

#! namespace container class
public class WSDL::Namespaces {
    public {
    }

    private {
        #! maps output namespace prefixes to namespace URIs
        hash ns = (
            "xsd": XSD_NS,
            );

        #! maps namespace URIs to output namespace prefixes
        hash nsr = (
            XSD_NS: "xsd",
            );

        #! hash for valid XSD namespaces, maps input namespace prefixes -> True if it refers to an XSD schema
        hash xsd_schema = (
            "xsd": True,
            );

        #! hash mapping input namespace prefixes to namespaces URIs
        hash imap = (
            "xsd": XSD_NS,
            );

        #! hash mapping input namespace URIs to input namespace prefixes
        hash imapr = (
            XSD_NS: "xsd",
            );

        #! integer providing a sequence for output namespace prefixes
        int nsn;

        #! if True then has SOAP 1.1
        bool hassoap11 = False;

        #! if True then has SOAP 1.2
        bool hassoap12 = False;

        #! current target namespace
        *string target_ns;

        #! target namespace stack;
        list nss = ();

        #! default namespace for unprefixed definitions
        *string default_ns;

        #! default namespace stack;
        list dss = ();
    }

    #! creates the object with the WSDL definitions attribute hash
    constructor(hash nsh, *Namespaces nsc) {
        nsn = nsc ? nsc.nsn : 1;

        if (nsh.targetNamespace)
            target_ns = nsh.targetNamespace;

        # set default namespace for unprefixed definitions
        if (nsh.xmlns)
            default_ns = nsh.xmlns;

        #printf("*** DEBUG: Namespaces::constructor() nsh: %y imap: %y\n", nsh, imap);
        addNamespaces(nsh);
        #printf("*** DEBUG: Namespaces::constructor() imap: %y\n", imap);
    }

    *string getDefaultNs() {
        return default_ns;
    }

    addNamespaces(hash nsh, *NamespacePrefixHelper nph) {
        foreach string k in (nsh.keyIterator()) {
            *string ns = (k =~ x/xmlns:(\w+)/)[0];

            if (!ns)
                continue;

            if (imap{ns}) {
                # ignore if the definition is the same
                if (imap{ns} == nsh{k})
                    continue;

                if (nph) {
                    string ov = imap{ns};
                    if (imapr{ov} == target_ns)
                        remove imapr{ov};
                    if (nsh{ns} == XSD_NS)
                        remove xsd_schema{ns};
                    nph.save(ns, ov);
                }
                else
                    throw "WSDL-NAMESPACE-ERROR", sprintf("namespace prefix %y defined twice", ns);
            }
            addNamespaceIntern(ns, nsh{k});
        }
    }

    restorePrefixes(hash h) {
        map addNamespaceIntern($1.key, $1.value, True), h.pairIterator();
    }

    private addNamespaceIntern(string ns, string val, *bool override) {
        imap{ns} = val;

        if (override || !imapr{val})
            imapr{val} = ns;

        if (val == XSD_NS)
            xsd_schema{ns} = True;

        if (!hassoap11 && val == SOAP_11_NS)
            hassoap11 = True;

        if (!hassoap12 && val == SOAP_12_NS)
            hassoap12 = True;
    }

    #! merges namespaces when parsing imported schemas
    merge(Namespaces nsc) {
        nsn = nsc.nsn;
        foreach string k in (nsc.ns.keyIterator()) {
            string v = nsc.ns{k};

            if (ns{k}) {
                if (ns{k} == v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", k, v, ns{k});
            }
            if (!nsr{v}) {
                ns{k} = v;
                nsr{v} = k;
            }
        }
        # merge input namespace mappings
        foreach string k in (nsc.imap.keyIterator()) {
            string v = nsc.imap{k};
            if (imap{k}) {
                if (imap{k} == v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", k, v, imap{k});
            }
            imap{k} = v;
        }
    }

    #! returns the namespace URI for the given output namespace prefix
    string getOutputNamespaceUri(string nsp) {
        *string n_ns = ns{nsp};
        if (!n_ns)
            throw "WSDL-NAMESPACE-ERROR", sprintf("output namespace prefix %y is unknown (known output namespace prefixes: %y)", nsp, ns.keys());
        return n_ns;
    }

    #! returns a hash of namespace attributes for outgoing SOAP messages
    *hash getOutputNamespaceHash(*hash nsh) {
        hash h;
        map h.("xmlns:" + $1.key) = $1.value, ns.pairIterator();

        foreach string k in (nsh.keyIterator()) {
            string xs = "xmlns:" + k;
            if (h{xs}) {
                if (h{xs} != nsh{k})
                    throw "WSDL-NAMESPACE-ERROR", sprintf("namespace %y has already been added automatically as %y and therefore cannot be overridden as %y", k, h{xs}, nsh{k});
            }
            else
                h{xs} = nsh{k};
        }

        return h;
    }

    #! returns the primary target namespace Uri
    *string getTargetNamespaceUri() {
        return target_ns;
    }

    #! returns the namespace URI for the given prefix or the target namespace Uri
    *string getNamespaceUri(*string nsp) {
        if (exists nsp)
            return getInputNamespaceUri(nsp);
        return getTargetNamespaceUri();
    }

    #! pushes the current target namespace URI on the stack when parsing schemas and sets the current target namespace URI to the current value
    pushTargetNamespace(string ns) {
        nss += target_ns;
        target_ns = ns;
    }

    #! restores any previous target namespace URI from the stack to the current target namespace URI
    popTargetNamespace() {
        target_ns = pop nss;
    }

    #! pushes the current default namespace URI on the stack when parsing schemas and sets the current default namespace URI to the current value
    pushDefaultNamespace(string ns) {
        dss += default_ns;
        default_ns = ns;
    }

    #! restores any previous default namespace URI from the stack to the current default namespace URI
    popDefaultNamespace() {
        default_ns = pop dss;
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getOutputNamespacePrefix(string ns) {
        *string nsa = nsr{ns};
        if (nsa)
            return nsa;
        return registerNamespaceIntern(ns);
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getTargetNamespaceInputPrefix() {
        if (!target_ns)
            throw "NAMESPACE-ERROR", sprintf("no target namespace");
        return imapr{target_ns};
    }

    #! registers a namespace internally
    private string registerNamespaceIntern(string n_ns) {
        # create namespace prefix
        string nsa = sprintf("ns%d", nsn++);
        # register namespace in forward and reverse maps
        ns{nsa} = n_ns;
        nsr{n_ns} = nsa;

        return nsa;
    }

    #! returns a hash of namespace prefixes to namespaces URIs actually used
    *hash getReferencedNamespaceMap() {
        return ns;
    }

    #! returns True if using SOAP 1.1, False if not
    bool hasSoap11() {
        return hassoap11;
    }

    #! returns True if using SOAP 1.2, False if not
    bool hasSoap12() {
        return hassoap12;
    }

    #! returns True if if the input namespace prefix refers to the XSD namespace URI
    *bool isSchema(string ns) {
        return xsd_schema{ns};
    }

    #! returns the input namespace URI from the input namespace prefix
    string getInputNamespaceUri(string nsa) {
        *string rv = imap{nsa};
        if (!rv)
            throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace %y is unknown (known input namespaces: %y)", nsa, imap.keys());
        return rv;
    }

    any doType(string t) {
        #printf("DEBUG: XsdBase::doType(%y)\n", t);
        (*string ns, *string type) = t =~ x/(\w+):(\w+)/;
        if (!type) {
            #printf("DEBUG: XsdBase::doType(%y) xsd: %y\n", t, default_ns);
            if (default_ns == XSD_NS)
                return new XsdBaseType(t, self);

            return ("val": t);
        }

        # if this is in the XML Schema namespace, then it's a base type
        if (xsd_schema{ns})
            return new XsdBaseType(type, self);

        return ("ns": getOutputNamespacePrefix(getInputNamespaceUri(ns)), "val": type);
    }

    #! returns the output namespace prefix for the given input namespace prefix
    string translateOutputNamespacePrefix(*string nsa) {
        return getOutputNamespacePrefix(getInputNamespaceUri(nsa));
    }
}

# private class
class WSDL::MapBase {
    public {}

    private {
        hash dh;
    }

    list keys() {
        return dh.keys();
    }

    AbstractIterator iterator() {
        return dh.iterator();
    }
}

# private class
class WSDL::TypeMap inherits WSDL::MapBase {
    add(XsdAbstractType t) {
        if (dh{t.name})
            throw WSDL_ERROR, sprintf("type %y declared twice", t.name);
        dh{t.name} = t;
    }

    XsdAbstractType get(string name) {
        if (!dh{name})
            throw WSDL_ERROR, sprintf("no such type %y; known types: %y", name, dh.keys());
        return dh{name};
    }

    *XsdAbstractType tryGet(string name) {
        return dh{name};
    }
}

# private class
class WSDL::ElementMap inherits WSDL::MapBase {
    add(XsdElement e) {
        string ns = e.ns;
        if (dh{ns}{e.name})
            throw WSDL_ERROR, sprintf("element %y declared twice in namespace %y", e.name, ns);
        dh{ns}{e.name} = e;
    }

    XsdElement get(string ns, string name) {
        if (!dh{ns})
            throw WSDL_ERROR, sprintf("no such namespace %y; known namespaces: %y", ns, dh.keys());
        if (!dh{ns}{name})
            throw WSDL_ERROR, sprintf("no such element %y in namespace %y; known elements: %y", name, ns, dh{ns}.keys());
        return dh{ns}{name};
    }

    *XsdElement tryGet(string ns, string name) {
        return dh{ns}{name};
    }
}

#! main class representing a parsed WSDL file
/** This is the main class for handling SOAP communication and is based on a WSDL file
*/
public class WSDL::WebService inherits WSDL::XsdBase {
    public {
        #! the WSDL string
        string wsdl;

        #! namespace container
        Namespaces nsc;

        hash base_type;
        list wsdl_services = ();
        hash idocmap;
        hash opmap;
        ElementMap emap();
        hash messages;
        TypeMap tmap();
        bool usedocns = False;
        hash portType;
        *code try_import;
        #! default path for retrieving XSD references
        *string def_path;
    }

    private {
        # service definitions; name -> service hash
        hash services;

        # service bindings; name -> hash
        hash binding;
    }

    #! creates the WebService object
    /** @param str the XML string representing the WSDL
        @param opts an optional hash of options with the following possible keys:
        - \c "def_path": the default path to use when retrieving referenced XSDs
        - \c "try_import": a call reference or closure to be passed a string name for XSD imports without any scheme to retrieve the data, must take a string argument (the resource name) and return a string (the resource data)
        - \c "http_client": a HTTPClient object for retrieving data from import commands
        - \c "http_headers": a hash of optional HTTP header info to use when retrieving data from import commands
    */
    constructor(string str, *hash opts) {
        hash h = parse_xml(str);

        # save WSDL text
        wsdl = str;

        try_import = opts.try_import;
        def_path = opts.def_path;

        # remove namespace (normally "wsdl:") prefix from keys if present
        WSDL::XsdBase::removeNS(\h);
        WSDL::XsdBase::removeNS(\h.definitions);
        nsc = new Namespaces(h.definitions."^attributes^");
        #getNSPrefixes(h.definitions."^attributes^");
        #printf("%y\n", h.definitions.types);

        if (exists h.definitions.types)
            parseTypes(h.definitions.types, opts.http_client instanceof HTTPClient ? opts.http_client : NOTHING, opts.http_headers);

        if (exists h.definitions.message)
            parseMessages(h.definitions.message);

        if (exists h.definitions.portType)
            parsePortType(h.definitions.portType);

        if (exists h.definitions.binding)
            parseBinding(h.definitions.binding);

        if (exists h.definitions.service)
            parseService(h.definitions.service);
    }

    #! returns the given operation or throws an exception if it cannot be found; operations are searched in portTypes in the order they are declared
    WSOperation getOperation(string opname) {
        foreach hash pt in (portType.iterator()) {
            if (pt.operations{opname})
                return pt.operations{opname};
        }
        list l = ();
        map l += $1.operations.keys(), portType.iterator();
        throw "WSDL-OPERATION-ERROR", sprintf("cannot retrieve operation %y; known operations: %y", opname, l);
    }

    #! returns the given operation or throws an exception if it cannot be found
    WSOperation getOperation(string port, string opname) {
        *WSOperation op = portType{port}.operations{opname};
        if (op)
            return op;
        if (!portType{port})
            throw "WSDL-OPERATION-ERROR", sprintf("port %y is not a defined port; known ports: %y", port, portType.keys());
        throw "WSDL-OPERATION-ERROR", sprintf("operation %y is not known in port %y; known operations: %y", opname, port, portType{port}.operations.keys());
    }

    #! returns a list of hashes giving supported operation names for each port in the WSDL
    /** @return a list of hashes giving supported operation names for each port in the WSDL; each hash has the following keys:
        - \c "port": the name of the port defining the operation
        - \c "operation": the @ref WSDL::WSOperation object for the operation
     */
    list listOperations() {
        list l = ();
        foreach hash ph in (portType.pairIterator()) {
            foreach WSOperation op in (ph.value.operations.iterator()) {
                l += (
                    "port": ph.name,
                    "operation": op,
                    );
            }
        }
        return l;
    }

    #! return a @ref WSDL::Binding object describing the requested binding
    /** @param name the name of the binding

        @return a @ref WSDL::Binding object

        @throw WSDL-BINDING-ERROR unknown binding
     */
    WSDL::Binding getBinding(string name) {
        *Binding b = binding{name};
        if (!b)
            throw "WSDL-BINDING-ERROR", sprintf("binding %y is not a known binding; known bindings: %y", name, binding.keys());
        return b;
    }

    #! returns a list of services defined in the WSDL
    /** @return a list of hashes of services defined in the WSDL; each hash has the following keys:
        - \c "name": the name of the service
        - \c "port": a hash of port information; the keys are port names and the values have the following keys:
        - \c "address": the location of the port
        - \c "binding": the binding of the port
     */
    list listServices() {
        return services.values();
    }

    #! returns a hash describing the requested service
    /** @param name the name of the service
        @return a hash describing the service with the following keys:
        - \c "name": the name of the service
        - \c "port": a hash of port information; where each hash is keyed by port name and the values have the following keys:
          - \c "address": the location of the port
          - \c "binding": the binding of the port

        @throw WSDL-SERVICE-ERROR the service is not known
     */
    hash getService(string name) {
        *hash h = services{name};
        if (!h)
            throw "WSDL-SERVICE-ERROR", sprintf("service %y is not a known service; known services: %y", name, services.keys());
        return h;
    }

    hash getType(string name, any v) {
        #printf("DBG getType() %y: %y\n", name, tmap);
        return ("^type^": tmap.get(name), "^val^": v);
    }

    private XsdBaseType getBaseType(string t) {
        if (exists base_type{t})
            return base_type{t};

        return base_type{t} = new XsdBaseType(t, nsc);
    }

    private resolveType(XsdSimpleType t) {
        throw "WSDL-TYPE-ERROR", sprintf("cannot resolve simpleType: %y type %y", t.name, t.type);
    }

    private resolveType(XsdElement xe) {
        if (xe.ref) {
            # find element
            (*string ns, string name) = (xe.ref =~ x/^(?:(\w+):)(\w+)$/);
            XsdElement e = emap.get(nsc.getNamespaceUri(ns), name);
            if (e.type.typeCode() == NT_HASH)
                resolveType(e);
            #printf("resolved to e: %y type: %y\n", e.name, e.type.name);
            xe.assimilate(e);
            #throw "OOPS", sprintf("e: %y", xe);
        }
        else if (xe.type.typeCode() == NT_HASH)
            xe.type = resolveType(xe.type);
    }

    private resolveType(XsdTypedData xd) {
        xd.type = resolveType(xd.type);
    }

    private resolveType(XsdComplexType ct) {
        ct.simpleType = resolveType(ct.simpleType);
    }

    private XsdAbstractType resolveType(hash v) {
        if (exists v.ns && nsc.isSchema(v.ns))
            return getBaseType(v.val);

        # find type
        return tmap.get(v.val);
    }

    # parse XSD schema types
    private parseTypes(*hash data, any http_client, any http_headers) {
        WSDL::XsdBase::removeNS(\data);

        XsdLateResolverHelper unresolved();

        foreach *hash schema in (data.schema) {
            *hash sa = schema."^attributes^";
            #if (!sa)
            #    throw "OOPS";
            NamespacePrefixHelper nph(nsc, sa);

            bool usedocns = sa.elementFormDefault == "qualified";

            #printf("DEBUG: schema tn: %y\n", schema."^attributes^"."targetNamespace");
            WSDL::XsdBase::removeNS(\schema);
            #printf("DEBUG: WebService::parseTypes() schema: %y\n", schema);

            # process XSD import if present
            foreach hash import in (schema.import) {
                *hash a = import."^attributes^";
                # import file
                if (a.schemaLocation) {
                    hash h = parse_url(a.schemaLocation);
                    string xsd;
                    if (!h.protocol && try_import)
                        xsd = call_function(try_import, a.schemaLocation);
                    else
                        xsd = WSDLLib::getFileFromURL(a.schemaLocation, "file", http_client, http_headers, NOTHING, def_path);

                    # parse XML to Qore data structure ignoring XML element order
                    hash xh = parse_xml(xsd);

                    # parse namespace definitions in schema attributes
                    if (xh.size() != 1)
                        throw WSDL_ERROR, sprintf("expecing a single element indicating an XSD schema in the imported file; got instead: %y", xh.keys());

                    # get schema member name
                    any sk = xh.firstKey();

                    #printf("*** DEBUG %y: sk: %y a: %y\n", a.schemaLocation, sk, xh{sk}."^attributes^");

                    # use temporary Namespaces object for import
                    Namespaces n_nsc = nsc;
                    nsc = new Namespaces(xh{sk}."^attributes^", nsc);
                    on_exit
                        nsc = n_nsc;
                    on_success
                        n_nsc.merge(nsc);

                    # verify that the top-level key indicates an XSD schema definition
                    (*string ns, *string mem) = (sk =~ x/^(\w+):(\w+)$/);
                    if (ns && !nsc.isSchema(ns))
                        throw WSDL_ERROR, sprintf("expecing imported schema definition to be in XSD namespace %y, got %y: %y instead", XSD_NS, ns, nsc.getInputNamespaceUri(ns));

                    parseTypes(xh);
                }
            }

            foreach hash st in (schema.simpleType) {
                XsdSimpleType t(st, nsc, unresolved, usedocns);
                tmap.add(t);
                #printf("DEBUG: st: %y\n", t.name);
            }

            foreach hash ct in (schema.complexType) {
                XsdComplexType t(ct, nsc, unresolved, usedocns);
                tmap.add(t);
                #printf("DEBUG: ct: %y\n", t.name);
            }

            # make element map
            foreach any el in (schema.element) {
                any attr = el."^attributes^";
                XsdElement element;
                if (exists attr.type) {
                    any t = nsc.doType(attr.type);
                    if (!(t instanceof XsdData)) {
                        t = t.val;
                        hash eattr.name = attr.name;
                        *XsdAbstractType et = tmap.tryGet(t);
                        if (!et)
                            eattr.type = t;

                        #printf("DEBUG: adding element %y type %y\n", attr.name, t);
                        element = new WSDL::XsdElement(("^attributes^": eattr), nsc, et, unresolved, usedocns);
                    }
                    else {
                        #printf("DEBUG: adding element %y type %y\n", attr.name, t);
                        element = new WSDL::XsdElement(("^attributes^":("name":attr.name)), nsc, t, unresolved, usedocns);
                    }
                }
                else {
                    #printf("DEBUG: adding element %y\n", attr.name);
                    element = new WSDL::XsdElement(el, nsc, NOTHING, unresolved, usedocns);
                }

                emap.add(element);
            }
        }

        # resolve types
        map resolveType($1), unresolved.getList();
        unresolved.clearResolved();

        # finalize complex types
        foreach XsdAbstractType t in (tmap.iterator()) {
            if (!(t instanceof XsdComplexType))
                continue;

            cast<XsdComplexType>(t).finalize(tmap, nsc);
        }

        # finalize complex types in elements
        foreach hash eh in (emap.iterator()) {
            foreach XsdElement el in (eh.iterator()) {
                if (!(el.type instanceof XsdComplexType))
                    continue;

                XsdComplexType ct = el.type;
                ct.finalize(tmap, nsc);
            }
        }

        # resolve types
        map resolveType($1), unresolved.getList();
    }

    private parseMessages(*softlist message) {
        # parse messages
        foreach hash m in (message) {
            WSMessage msg(m, emap, tmap, nsc);
            foreach string arg in (msg.args.keyIterator()) {
                #printf("DEBUG: WebService::parseMessages(): %y: %y\n", arg, msg);
                #printf("DEBUG: WebService::parseMessages(): %y: %y\n", arg, msg.args{arg}.type);
                if (exists msg.args{arg}.type && !(msg.args{arg}.type instanceof XsdData))
                    msg.args{arg}.type = resolveType(msg.args{arg}.type);
            }
            messages.(msg.name) = msg;
        }
    }

    private parseService(*softlist svcs) {
        foreach hash svc in (svcs) {
            WSDL::XsdBase::removeNS(\svc);
            string svcname = svc."^attributes^".name;
            foreach hash port in (svc.port) {
                WSDL::XsdBase::removeNS(\port);
                hash pa = port."^attributes^";
                string name = pa.name;
                services{svcname}.name = svcname;
                services{svcname}.port{name} = pa;
                services{svcname}.port{name}.address = port.address."^attributes^".location;

                if (!pa.binding)
                    throw WSDL_ERROR, sprintf("service %y port %y has no binding", svcname, name);

                (*string ns, *string bind) = pa.binding =~ x/(?:(\w+):)?(\w+)/;
                if (!bind)
                    throw WSDL_ERROR, sprintf("cannot parse service %y port %y binding: %y", svcname, name, pa.binding);

                if (!binding{bind})
                    throw WSDL_ERROR, sprintf("service %y port %y refers to non-existant binding %y; known bindings: %y", svcname, name, bind, binding.keys());

                services{svcname}.port{name}.binding = binding{bind};
            }
        }
    }

    private parsePortType(*softlist data) {
        # setup list of services defined in this WSDL
        foreach hash port in (data) {
            WSDL::XsdBase::removeNS(\port);
            #printf("DEBUG: portType: %y\n", port);
            string name = port."^attributes^".name;
            wsdl_services += name;
            foreach any p in (port.operation) {
                WSOperation op(p, tmap, nsc, messages);
                portType{name}.operations.(op.name) = op;
                #printf("DEBUG: %y registered operation %y\n", name, op.name);
                opmap.(op.name) = op;
            }
        }
    }

    private parseBinding(*softlist bindings) {
        foreach hash data in (bindings) {
            WSDL::Binding b(data, nsc, \portType, \idocmap, messages);
            binding.(b.getName()) = b;
        }
    }

    #! returns True if the WSDL describes a SOAP 1.2 service
    /** @return True if the WSDL describes a SOAP 1.2 service
    */
    bool isSoap12() {
        return nsc.hasSoap12();
    }

    #! returns the XML string for the WSDL
    /** @return the XML string for the WSDL
    */
    string getWSDL() {
        return wsdl;
    }

    #! returns the XML string for the WSDL, adjusting the URLs for binding locations depending on the caller
    /** @return the XML string for the WSDL
    */
    string getWSDL(string base_url) {
        string wstr = wsdl;

        foreach hash sh in (services.iterator()) {
            foreach hash ph in (sh.port.iterator()) {
                wstr = replace(wstr, ph.address, base_url + "/" + sh.name);
            }
        }

        return wstr;
    }

    private string getOperationParams(WSMessage msg) {
        return sprintf("%s(%s)", msg.name, (foldl $1 + "," + $2, (keys msg.args)));
    }

    #! prepare a WebService report enumerating the services and operations of the WSDL, outputs to the output stream given as the first argument
    /** @param stream the output stream for the report data
        @param wsdl_name name of the WSDL, typically a file name

        @return human readable text report
    */
    getReport(StringOutputStream stream, *string wsdl_name) {
        StreamWriter w(stream);
        w.printf("wsdl: %s\n", wsdl_name);
        foreach hash svc in (listServices()) {
            w.printf("  service: %s\n", svc.name);
            #hash svc = getService(svc_name);
            foreach string port in (keys svc.port) {
                w.printf("    port: %s\n", port);
                w.printf("      binding: %s\n", svc.port{port}.binding.name);
                w.printf("      address: %s\n", svc.port{port}.address);
                hash pt = portType{svc.port{port}.binding.getPort()};
                w.printf("      operations:\n");
                foreach string name in (keys pt.operations) {
                    WSOperation op = pt.operations{name};
                    w.printf("        %s\n", name);
                    if (op.input) {
                        w.printf("          input: %s\n", getOperationParams(op.input));
                    }
                    if (op.output) {
                        w.printf("          output: %s\n", getOperationParams(op.output));
                    }
                }
            }
        }
    }

    #! prepare a WebService report enumerating the services and operations of the WSDL
    /** @param wsdl_name name of the WSDL, typically a file name

        @return human readable text report
    */
    string getReport(*string wsdl_name) {
        StringOutputStream stream();
        getReport(stream, wsdl_name);
        return stream.getData();
    }
}

#! helper class implementing sample message generation
/** This is the class for generating sample SOAP messages based on a WSDL file
*/
public class WSDL::WSMessageHelper {
    private {
        WebService ws;
        hash opts;
    }

    #! creates the WebService object
    /** @param _ws the object representing the WSDL
        @param _opts an optional hash of options with the following possible keys:
        - \c "comments": (bool) generate comments as values with ^comment^ key, default: False
        - \c "choices": (bool) generate choices as sub hashes ^choices^ key, default: False
        - \c "max_items" (int): max.number of array elements to output, default: 3
    **/
    const DefaultOpts = (
        "comments": False,
        "choices": False,
        "max_items": 3,
    );
    constructor(WebService _ws, *hash _opts) {
        ws = _ws;
        *hash h = _opts;
        map remove h{$1}, keys DefaultOpts;
        if (h) {
           throw "WSDL-HELPER-ERROR", sprintf("unknown options %y (known values: %y)", keys h, keys DefaultOpts);
        }
        opts = DefaultOpts + _opts;
        if (opts.max_items < 1) {
           throw "WSDL-HELPER-ERROR", sprintf("wrong 'max_items' value %y (condition: >=1)", opts.max_items);
        }
    }

    private hash getTypeInfo(XsdBaseType t) {
        hash res = (
            'xtype': t.name,
        );
        switch (t.name) {
            case "string":
            case "normalizedString":
            case "token":
                res.type = "string";
                res.value = "abc";
                break;
            case "anyUri":
                res.type = "string";
                res.value = "http://www.qore.com";
                break;
            case "byte":
            case "int":
            case "integer":
            case "long":
            case "negativeInteger":
            case "nonNegativeInteger":
            case "positiveInteger":
            case "nonPositiveInteger":
            case "short":
            case "unsignedLong":
            case "unsignedInt":
            case "unsignedShort":
            case "unsignedByte":
                res.type = "int";
                res.value = 123;
                break;
            case "boolean":
                res.type = "bool";
                res.value = True;
                break;
            case "base64Binary":
            case "hexBinary":
                res.type = "binary";
                res.value = "<0feba023ffdca6291>";   # TODO: how assign binary const ?
                break;
            case "decimal":
                res.type = "number";
                res.value = 123.456;
                break;
            case "date":
                res.type = "date";
                res.value = 2015-01-31;
                break;
            case "dateTime":
                res.type = "date";
                res.value = 2015-01-31T10:20:30+01:00;
                break;
            case "time":
                res.type = "date";
                res.value = 10:20:30Z;
                break;
            case "duration":
                res.type = "date";
                res.value = P5Y2M10DT15H;   # TODO
                break;
        }
        return res;
    }

    private hash getTypeInfo(XsdSimpleType t) {
        hash res;
        if (t.type) {
            res = getTypeInfo(t.type);
            res.xtype = t.name;
            if (t.enum) {
                switch (res.type) {
                case "string":
                    res.value = (keys t.enum)[0];
                    break;
                case "int":
                    res.value = sprintf("%s", (keys t.enum)[0]);
                    break;
                default:
                    res.value = sprintf("%s", (keys t.enum)[0]);
                }
                res.comment = sprintf("Enum: %s",  (keys t.enum).join(','));
            }
        } else {
            res.xtype = t.name;
        }
        return res;
    }

    private hash getTypeInfo(XsdComplexType t) {
        hash res;
        if (t.elementmap) {
            res.type = "hash";
        } else if (t.simpleType) {
            res = getTypeInfo(t.simpleType);
        }
        res.attrs = exists t.attrs;
        return res;
    }

    hash getMessage(XsdElement elem, *softlist comments) {
        hash vi = getTypeInfo(elem.type);
        any val;

        if (opts.comments) {
            if (elem.minOccurs == 0) {
                comments += "optional";
            }
            if (elem.minOccurs > 1) {
                comments += sprintf("minOccurs:%d", elem.minOccurs);
            }
            if (elem.maxOccurs > 1 || elem.maxOccurs < 0) {
                comments += sprintf("maxOccurs:%d", elem.maxOccurs);
            }
        }
        if (vi.type) {
            if (vi.type == 'hash') {
                val = hash();
                foreach string name2 in (keys elem.type.elementmap) {
                    val += getMessage(elem.type.elementmap{name2});
                }
                foreach hash choice in (elem.type.choices) {
                    if (opts.choices) {
                        hash ch;
                        int j = 1;
                        foreach string name2 in (keys choice.elementmap) {
                            ch += getMessage(choice.elementmap{name2}, opts.comments ? sprintf("choice[%d]", j) : NOTHING);
                            j++;
                        }
                        val{sprintf("^choices%d^", $#+1)} = ch;
                    } else {
                        val += getMessage(choice.elementmap.firstValue(), opts.comments ? sprintf("choice[1/%d]", elem.type.choices.size()) : NOTHING);
                    }
                }
            } else {
                if (opts.comments && vi.comment) {
                    comments += vi.comment;
                }
                val = vi.value;
            }
        }

        any v;
        if (comments || vi.attrs) {
            v = hash();
            if (comments) {
                v{'^comment^'} = comments.join(';');
            }
            if (vi.attrs) {
                v{'^attributes^'} = ();
                foreach string name2 in (keys elem.type.attrs) {
                    hash vi2 = getTypeInfo(elem.type.attrs{name2}.type);
                    if (vi2.type) {
                        v{'^attributes^'}{name2} = vi2.value;
                    }
                }
            }
            if (exists val) {
                if (vi.type == 'hash') {
                    v += val;
                } else {
                    v{'^value^'} = val;
                }
            }
        } else {
            v = val;
        }
        *softint n = elem.maxOccurs;
        if (n == -1 || n > opts.max_items) {
            n = opts.max_items;
        }
        if (n > 1) {
            list l;
            int i = 1;
            while (i <= n) {
                if (comments) {
                    v{'^comment^'} = ( list(sprintf("#%d", i))+comments).join(';');
                }
                push l, v;
                i++;
            }
            return (elem.name: l);
        } else {
            return (elem.name: v);
        }
    }

    #! prepare sample message
    /** @param name message name

        @return a hash representing message
    */
    hash getMessage(string name) {
        return getMessage(ws.idocmap{name});
    }

    #! prepare sample message
    /** @param msg WSMessage object

        @return a hash representing message
    */
    hash getMessage(WSMessage msg) {
        return getMessage(msg.args.firstValue().element);
    }
}
